const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/diff-Ba4fQ92W.js","assets/index-C1uuhD5W.js","assets/index-N1qhX2HM.css"])))=>i.map(i=>d[i]);
import { q as generateUtilityClass, t as generateUtilityClasses, r as reactExports, e as useDefaultProps, aT as duration, aU as Transition, aa as useTheme, aV as useTimeout, G as useForkRef, K as useSlot, g as clsx, j as jsxRuntimeExports, h as composeClasses, k as styled, m as memoTheme, aW as getTransitionProps, p as createSvgIcon, aX as mergeSlotProps, w as capitalize, J as rootShouldForwardProp, x as createSimplePaletteValueFilter, aY as clamp, E as useEnhancedEffect, ag as useEventCallback, ak as ownerDocument, aZ as extractEventHandlers, aN as isFocusVisible, a7 as isHostComponent, v as useRtl, ar as useSlotProps, am as slotShouldForwardProp, a_ as useSearchParams, a$ as parseQuery, b0 as renderQuery, a3 as useNavigate, aS as useAtom, B as Box, I as IconButton, c as routes, n as Button, T as Typography, C as CircularProgress, a9 as useAtomValue, b1 as _objectWithoutPropertiesLoose, b2 as requireReact, b3 as _extends, b4 as resolveComponentProps, b5 as shouldForwardProp, aM as alpha, b as Chip, a2 as getDefaultExportFromCjs, a4 as SchoolIcon, b6 as MenuItem, aH as useQueryClient, b7 as useIsMobile, b8 as __vitePreload, A as Alert } from "./index-C1uuhD5W.js";
import { S as SwitchBase, B as Breadcrumbs, F as FolderOpenIcon, f as flashManConfigAtom, j as useSuspenseQuery, d as FolderIcon, k as useContentsEx, l as useActiveContent, m as useContentTree, b as useRepositoryList, D as DEFAULT_REPO_ID, A as Autocomplete, T as ToggleButtonGroup, i as ToggleButton, a as useOctokit, n as useGithubToken, o as getFlashCardContent, L as Link, e as FormControlLabel, R as RadioGroup, h as Radio, p as learnConfigAtom } from "./hooks-BogG25WI.js";
import { L as ListItemButton, a as ListItemText } from "./ListItemText-DdsbBg4Q.js";
import { C as ChevronRightIcon, G as Grid } from "./ChevronRight-D0aGvTM6.js";
import { k as useControlled, c as useRefWithInit, E as EMPTY_OBJECT, e as useIsoLayoutEffect, d as useOnMount, p as EMPTY_ARRAY, f as useMergedRefs, a as FormControl, b as FormLabel, j as InputLabel, S as Select, T as TextareaAutosize } from "./useOnMount-BxoUUqFc.js";
import { v as visuallyHidden, u as useThemeProps$2, I as InputAdornment } from "./visuallyHidden-DZnaolx9.js";
import { T as TextField } from "./TextField-BbDGCLkb.js";
import { C as Card, a as CardContent } from "./CardContent-ChCAlgOZ.js";
import { b as getLearningHistoriesBySha, c as addLearningHistories } from "./learningHistories-CvuHvNjP.js";
import { L as LinearProgress } from "./LinearProgress-BS5i-iMP.js";
function getCollapseUtilityClass(slot) {
  return generateUtilityClass("MuiCollapse", slot);
}
generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const useUtilityClasses$4 = (ownerState) => {
  const {
    orientation,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `${orientation}`],
    entered: ["entered"],
    hidden: ["hidden"],
    wrapper: ["wrapper", `${orientation}`],
    wrapperInner: ["wrapperInner", `${orientation}`]
  };
  return composeClasses(slots, getCollapseUtilityClass, classes);
};
const CollapseRoot = styled("div", {
  name: "MuiCollapse",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.state === "entered" && styles2.entered, ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && styles2.hidden];
  }
})(memoTheme(({
  theme
}) => ({
  height: 0,
  overflow: "hidden",
  transition: theme.transitions.create("height"),
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      height: "auto",
      width: 0,
      transition: theme.transitions.create("width")
    }
  }, {
    props: {
      state: "entered"
    },
    style: {
      height: "auto",
      overflow: "visible"
    }
  }, {
    props: {
      state: "entered",
      orientation: "horizontal"
    },
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px",
    style: {
      visibility: "hidden"
    }
  }]
})));
const CollapseWrapper = styled("div", {
  name: "MuiCollapse",
  slot: "Wrapper"
})({
  // Hack to get children with a negative margin to not falsify the height computation.
  display: "flex",
  width: "100%",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "auto",
      height: "100%"
    }
  }]
});
const CollapseWrapperInner = styled("div", {
  name: "MuiCollapse",
  slot: "WrapperInner"
})({
  width: "100%",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "auto",
      height: "100%"
    }
  }]
});
const Collapse = /* @__PURE__ */ reactExports.forwardRef(function Collapse2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCollapse"
  });
  const {
    addEndListener,
    children,
    className,
    collapsedSize: collapsedSizeProp = "0px",
    component,
    easing,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    orientation = "vertical",
    slots = {},
    slotProps = {},
    style,
    timeout = duration.standard,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const ownerState = {
    ...props,
    orientation,
    collapsedSize: collapsedSizeProp
  };
  const classes = useUtilityClasses$4(ownerState);
  const theme = useTheme();
  const timer = useTimeout();
  const wrapperRef = reactExports.useRef(null);
  const autoTransitionDuration = reactExports.useRef();
  const collapsedSize = typeof collapsedSizeProp === "number" ? `${collapsedSizeProp}px` : collapsedSizeProp;
  const isHorizontal = orientation === "horizontal";
  const size = isHorizontal ? "width" : "height";
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, nodeRef);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node);
      } else {
        callback(node, maybeIsAppearing);
      }
    }
  };
  const getWrapperSize = () => wrapperRef.current ? wrapperRef.current[isHorizontal ? "clientWidth" : "clientHeight"] : 0;
  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "absolute";
    }
    node.style[size] = collapsedSize;
    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node, isAppearing) => {
    const wrapperSize = getWrapperSize();
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "";
    }
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: "enter"
    });
    if (timeout === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node.style[size] = `${wrapperSize}px`;
    node.style.transitionTimingFunction = transitionTimingFunction;
    if (onEntering) {
      onEntering(node, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback((node, isAppearing) => {
    node.style[size] = "auto";
    if (onEntered) {
      onEntered(node, isAppearing);
    }
  });
  const handleExit = normalizedTransitionCallback((node) => {
    node.style[size] = `${getWrapperSize()}px`;
    if (onExit) {
      onExit(node);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleExiting = normalizedTransitionCallback((node) => {
    const wrapperSize = getWrapperSize();
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: "exit"
    });
    if (timeout === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node.style[size] = collapsedSize;
    node.style.transitionTimingFunction = transitionTimingFunction;
    if (onExiting) {
      onExiting(node);
    }
  });
  const handleAddEndListener = (next) => {
    if (timeout === "auto") {
      timer.start(autoTransitionDuration.current || 0, next);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next);
    }
  };
  const externalForwardedProps = {
    slots,
    slotProps,
    component
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref: handleRef,
    className: clsx(classes.root, className),
    elementType: CollapseRoot,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      style: {
        [isHorizontal ? "minWidth" : "minHeight"]: collapsedSize,
        ...style
      }
    }
  });
  const [WrapperSlot, wrapperSlotProps] = useSlot("wrapper", {
    ref: wrapperRef,
    className: classes.wrapper,
    elementType: CollapseWrapper,
    externalForwardedProps,
    ownerState
  });
  const [WrapperInnerSlot, wrapperInnerSlotProps] = useSlot("wrapperInner", {
    className: classes.wrapperInner,
    elementType: CollapseWrapperInner,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    in: inProp,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    nodeRef,
    timeout: timeout === "auto" ? null : timeout,
    ...other,
    children: (state, {
      ownerState: incomingOwnerState,
      ...restChildProps
    }) => {
      const stateOwnerState = {
        ...ownerState,
        state
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
        ...rootSlotProps,
        className: clsx(rootSlotProps.className, {
          "entered": classes.entered,
          "exited": !inProp && collapsedSize === "0px" && classes.hidden
        }[state]),
        ownerState: stateOwnerState,
        ...restChildProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(WrapperSlot, {
          ...wrapperSlotProps,
          ownerState: stateOwnerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(WrapperInnerSlot, {
            ...wrapperInnerSlotProps,
            ownerState: stateOwnerState,
            children
          })
        })
      });
    }
  });
});
if (Collapse) {
  Collapse.muiSupportAuto = true;
}
const CheckBoxOutlineBlankIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}));
const CheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}));
const IndeterminateCheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}));
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass("MuiCheckbox", slot);
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]);
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    indeterminate,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize(color2)}`, `size${capitalize(size)}`]
  };
  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
  return {
    ...classes,
    // forward the disabled and checked classes to the SwitchBase
    ...composedClasses
  };
};
const CheckboxRoot = styled(SwitchBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.indeterminate && styles2.indeterminate, styles2[`size${capitalize(ownerState.size)}`], ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  variants: [{
    props: {
      color: "default",
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.alpha((theme.vars || theme).palette.action.active, (theme.vars || theme).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2,
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.alpha((theme.vars || theme).palette[color2].main, (theme.vars || theme).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
        color: (theme.vars || theme).palette[color2].main
      },
      [`&.${checkboxClasses.disabled}`]: {
        color: (theme.vars || theme).palette.action.disabled
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: false
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ reactExports.forwardRef(function Checkbox2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCheckbox"
  });
  const {
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon: iconProp = defaultIcon,
    indeterminate = false,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size = "medium",
    disableRipple = false,
    className,
    slots = {},
    slotProps = {},
    ...other
  } = props;
  const icon = indeterminate ? indeterminateIconProp : iconProp;
  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  const ownerState = {
    ...props,
    disableRipple,
    color: color2,
    indeterminate,
    size
  };
  const classes = useUtilityClasses$3(ownerState);
  const externalInputProps = slotProps.input ?? inputProps;
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    elementType: CheckboxRoot,
    className: clsx(classes.root, className),
    shouldForwardComponentProp: true,
    externalForwardedProps: {
      slots,
      slotProps,
      ...other
    },
    ownerState,
    additionalProps: {
      type: "checkbox",
      icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
        fontSize: icon.props.fontSize ?? size
      }),
      checkedIcon: /* @__PURE__ */ reactExports.cloneElement(indeterminateIcon, {
        fontSize: indeterminateIcon.props.fontSize ?? size
      }),
      disableRipple,
      slots,
      slotProps: {
        input: mergeSlotProps(typeof externalInputProps === "function" ? externalInputProps(ownerState) : externalInputProps, {
          "data-indeterminate": indeterminate
        })
      }
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
    ...rootSlotProps,
    classes
  });
});
function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
  return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
}
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function getNewValue(currentValue, step, direction, min, max) {
  return direction === 1 ? Math.min(currentValue + step, max) : Math.max(currentValue - step, min);
}
function asc(a, b) {
  return a - b;
}
function findClosest(values, currentValue) {
  const {
    index: closestIndex
  } = values.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }
    return acc;
  }, null) ?? {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min) {
  const nearest = Math.round((value - min) / step) * step + min;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values,
  newValue,
  index
}) {
  const output = values.slice();
  output[index] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  const doc = ownerDocument(sliderRef.current);
  if (!sliderRef.current?.contains(doc.activeElement) || Number(doc?.activeElement?.getAttribute("data-index")) !== activeIndex) {
    sliderRef.current?.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (typeof newValue === "object" && typeof oldValue === "object") {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
const axisProps = {
  horizontal: {
    offset: (percent) => ({
      left: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  "horizontal-reverse": {
    offset: (percent) => ({
      right: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: (percent) => ({
      bottom: `${percent}%`
    }),
    leap: (percent) => ({
      height: `${percent}%`
    })
  }
};
const Identity$1 = (x) => x;
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max = 100,
    min = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    rootRef: ref,
    scale = Identity$1,
    step = 1,
    shiftStep = 10,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = reactExports.useRef(void 0);
  const [active, setActive] = reactExports.useState(-1);
  const [open2, setOpen] = reactExports.useState(-1);
  const [dragging, setDragging] = reactExports.useState(false);
  const moveCount = reactExports.useRef(0);
  const lastChangedValue = reactExports.useRef(null);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue ?? min,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name
      }
    });
    lastChangedValue.current = value;
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values = values.map((value) => value == null ? min : clamp(value, min, max));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({
    value: min + step * index
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const [focusedThumbIndex, setFocusedThumbIndex] = reactExports.useState(-1);
  const sliderRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, sliderRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    const index = Number(event.currentTarget.getAttribute("data-index"));
    if (isFocusVisible(event.target)) {
      setFocusedThumbIndex(index);
    }
    setOpen(index);
    otherHandlers?.onFocus?.(event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    otherHandlers?.onBlur?.(event);
  };
  const changeValue = (event, valueInput) => {
    const index = Number(event.currentTarget.getAttribute("data-index"));
    const value = values[index];
    const marksIndex = marksValues.indexOf(value);
    let newValue = valueInput;
    if (marks && step == null) {
      const maxMarksValue = marksValues[marksValues.length - 1];
      if (newValue >= maxMarksValue) {
        newValue = maxMarksValue;
      } else if (newValue <= marksValues[0]) {
        newValue = marksValues[0];
      } else {
        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
      }
    }
    newValue = clamp(newValue, min, max);
    if (range) {
      if (disableSwap) {
        newValue = clamp(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index
      });
      let activeIndex = index;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index);
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(event, newValue, index);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, lastChangedValue.current ?? newValue);
    }
  };
  const createHandleHiddenInputKeyDown = (otherHandlers) => (event) => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      event.preventDefault();
      const index = Number(event.currentTarget.getAttribute("data-index"));
      const value = values[index];
      let newValue = null;
      if (step != null) {
        const stepSize = event.shiftKey ? shiftStep : step;
        switch (event.key) {
          case "ArrowUp":
            newValue = getNewValue(value, stepSize, 1, min, max);
            break;
          case "ArrowRight":
            newValue = getNewValue(value, stepSize, isRtl ? -1 : 1, min, max);
            break;
          case "ArrowDown":
            newValue = getNewValue(value, stepSize, -1, min, max);
            break;
          case "ArrowLeft":
            newValue = getNewValue(value, stepSize, isRtl ? 1 : -1, min, max);
            break;
          case "PageUp":
            newValue = getNewValue(value, shiftStep, 1, min, max);
            break;
          case "PageDown":
            newValue = getNewValue(value, shiftStep, -1, min, max);
            break;
          case "Home":
            newValue = min;
            break;
          case "End":
            newValue = max;
            break;
        }
      } else if (marks) {
        const maxMarksValue = marksValues[marksValues.length - 1];
        const currentMarkIndex = marksValues.indexOf(value);
        const decrementKeys = [isRtl ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"];
        const incrementKeys = [isRtl ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        if (decrementKeys.includes(event.key)) {
          if (currentMarkIndex === 0) {
            newValue = marksValues[0];
          } else {
            newValue = marksValues[currentMarkIndex - 1];
          }
        } else if (incrementKeys.includes(event.key)) {
          if (currentMarkIndex === marksValues.length - 1) {
            newValue = maxMarksValue;
          } else {
            newValue = marksValues[currentMarkIndex + 1];
          }
        }
      }
      if (newValue != null) {
        changeValue(event, newValue);
      }
    }
    otherHandlers?.onKeyDown?.(event);
  };
  useEnhancedEffect(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      document.activeElement?.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    otherHandlers.onChange?.(event);
    changeValue(event, event.target.valueAsNumber);
  };
  const previousIndex = reactExports.useRef(void 0);
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width,
      height,
      bottom,
      left
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.startsWith("vertical")) {
      percent = (bottom - finger.y) / height;
    } else {
      percent = (finger.x - left) / width;
    }
    if (axis.includes("-reverse")) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min, max);
    if (step) {
      newValue = roundValueToStep(newValue, step, min);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min, max);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp(newValue, values[activeIndex - 1] || -Infinity, values[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, lastChangedValue.current ?? newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("touchend", handleTouchEnd, {
      passive: true
    });
  });
  const stopListening = reactExports.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  reactExports.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart);
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  reactExports.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    otherHandlers.onMouseDown?.(event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range ? values[0] : min, min, max);
  const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;
  const getRootProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(externalHandlers || {})
    };
    const mergedEventHandlers = {
      ...externalHandlers,
      ...ownEventHandlers
    };
    return {
      ...externalProps,
      ref: handleRef,
      ...mergedEventHandlers
    };
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    otherHandlers.onMouseOver?.(event);
    const index = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    otherHandlers.onMouseLeave?.(event);
    setOpen(-1);
  };
  const getThumbProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(externalHandlers || {}),
      onMouseLeave: createHandleMouseLeave(externalHandlers || {})
    };
    return {
      ...externalProps,
      ...externalHandlers,
      ...ownEventHandlers
    };
  };
  const getThumbStyle = (index) => {
    return {
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: active !== -1 && active !== index ? "none" : void 0
    };
  };
  let cssWritingMode;
  if (orientation === "vertical") {
    cssWritingMode = isRtl ? "vertical-rl" : "vertical-lr";
  }
  const getHiddenInputProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(externalHandlers || {}),
      onFocus: createHandleHiddenInputFocus(externalHandlers || {}),
      onBlur: createHandleHiddenInputBlur(externalHandlers || {}),
      onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})
    };
    const mergedEventHandlers = {
      ...externalHandlers,
      ...ownEventHandlers
    };
    return {
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max),
      "aria-valuemin": scale(min),
      name,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: parameters.step === null && parameters.marks ? "any" : parameters.step ?? void 0,
      disabled,
      ...externalProps,
      ...mergedEventHandlers,
      style: {
        ...visuallyHidden,
        direction: isRtl ? "rtl" : "ltr",
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: "100%",
        height: "100%",
        writingMode: cssWritingMode
      }
    };
  };
  return {
    active,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open: open2,
    range,
    rootRef: handleRef,
    trackLeap,
    trackOffset,
    values,
    getThumbStyle
  };
}
const shouldSpreadAdditionalProps = (Slot) => {
  return !Slot || !isHostComponent(Slot);
};
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
const sliderClasses = generateUtilityClasses("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]);
const useValueLabelClasses = (props) => {
  const {
    open: open2
  } = props;
  const utilityClasses = {
    offset: clsx(open2 && sliderClasses.valueLabelOpen),
    circle: sliderClasses.valueLabelCircle,
    label: sliderClasses.valueLabelLabel
  };
  return utilityClasses;
};
function SliderValueLabel$1(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /* @__PURE__ */ reactExports.cloneElement(children, {
    className: children.props.className
  }, /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [children.props.children, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: clsx(classes.offset, className),
      "aria-hidden": true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.circle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
function Identity(x) {
  return x;
}
const SliderRoot = styled("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`size${capitalize(ownerState.size)}`], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(memoTheme(({
  theme
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${sliderClasses.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (theme.vars || theme).palette.grey[400]
  },
  [`&.${sliderClasses.dragging}`]: {
    [`& .${sliderClasses.thumb}, & .${sliderClasses.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: true
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: true
    },
    style: {
      marginRight: 44
    }
  }]
})));
const SliderRail = styled("span", {
  name: "MuiSlider",
  slot: "Rail"
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
});
const SliderTrack = styled("span", {
  name: "MuiSlider",
  slot: "Track"
})(memoTheme(({
  theme
}) => {
  return {
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: false
      },
      style: {
        display: "none"
      }
    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2,
        track: "inverted"
      },
      style: {
        ...theme.vars ? {
          backgroundColor: theme.vars.palette.Slider[`${color2}Track`],
          borderColor: theme.vars.palette.Slider[`${color2}Track`]
        } : {
          backgroundColor: theme.lighten(theme.palette[color2].main, 0.62),
          borderColor: theme.lighten(theme.palette[color2].main, 0.62),
          ...theme.applyStyles("dark", {
            backgroundColor: theme.darken(theme.palette[color2].main, 0.5)
          }),
          ...theme.applyStyles("dark", {
            borderColor: theme.darken(theme.palette[color2].main, 0.5)
          })
        }
      }
    }))]
  };
}));
const SliderThumb = styled("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2[`thumbColor${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`thumbSize${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: theme.transitions.create(["box-shadow", "left", "bottom"], {
    duration: theme.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (theme.vars || theme).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${sliderClasses.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&:hover, &.${sliderClasses.focusVisible}`]: {
        boxShadow: `0px 0px 0px 8px ${theme.alpha((theme.vars || theme).palette[color2].main, 0.16)}`,
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${sliderClasses.active}`]: {
        boxShadow: `0px 0px 0px 14px ${theme.alpha((theme.vars || theme).palette[color2].main, 0.16)}`
      }
    }
  }))]
})));
const SliderValueLabel = styled(SliderValueLabel$1, {
  name: "MuiSlider",
  slot: "ValueLabel"
})(memoTheme(({
  theme
}) => ({
  zIndex: 1,
  whiteSpace: "nowrap",
  ...theme.typography.body2,
  fontWeight: 500,
  transition: theme.transitions.create(["transform"], {
    duration: theme.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (theme.vars || theme).palette.grey[600],
  borderRadius: 2,
  color: (theme.vars || theme).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: theme.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
})));
const SliderMark = styled("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => {
    const {
      markActive
    } = props;
    return [styles2.mark, markActive && styles2.markActive];
  }
})(memoTheme(({
  theme
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: true
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.background.paper,
      opacity: 0.8
    }
  }]
})));
const SliderMarkLabel = styled("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive"
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body2,
  color: (theme.vars || theme).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: true
    },
    style: {
      color: (theme.vars || theme).palette.text.primary
    }
  }]
})));
const useUtilityClasses$2 = (ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color2 && `color${capitalize(color2)}`, size && `size${capitalize(size)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled", size && `thumbSize${capitalize(size)}`, color2 && `thumbColor${capitalize(color2)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider = /* @__PURE__ */ reactExports.forwardRef(function Slider2(inputProps, ref) {
  const props = useDefaultProps({
    props: inputProps,
    name: "MuiSlider"
  });
  const isRtl = useRtl();
  const {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    "aria-labelledby": ariaLabelledby,
    // eslint-disable-next-line react/prop-types
    component = "span",
    components = {},
    componentsProps = {},
    color: color2 = "primary",
    classes: classesProp,
    className,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max = 100,
    min = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    shiftStep = 10,
    size = "medium",
    step = 1,
    scale = Identity,
    slotProps,
    slots,
    tabIndex,
    track = "normal",
    value: valueProp,
    valueLabelDisplay = "off",
    valueLabelFormat = Identity,
    ...other
  } = props;
  const ownerState = {
    ...props,
    isRtl,
    max,
    min,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color: color2,
    size,
    step,
    shiftStep,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  };
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open: open2,
    active,
    axis,
    focusedThumbIndex,
    range,
    dragging,
    marks,
    values,
    trackOffset,
    trackLeap,
    getThumbStyle
  } = useSlider({
    ...ownerState,
    rootRef: ref
  });
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses$2(ownerState);
  const RootSlot = slots?.root ?? components.Root ?? SliderRoot;
  const RailSlot = slots?.rail ?? components.Rail ?? SliderRail;
  const TrackSlot = slots?.track ?? components.Track ?? SliderTrack;
  const ThumbSlot = slots?.thumb ?? components.Thumb ?? SliderThumb;
  const ValueLabelSlot = slots?.valueLabel ?? components.ValueLabel ?? SliderValueLabel;
  const MarkSlot = slots?.mark ?? components.Mark ?? SliderMark;
  const MarkLabelSlot = slots?.markLabel ?? components.MarkLabel ?? SliderMarkLabel;
  const InputSlot = slots?.input ?? components.Input ?? "input";
  const rootSlotProps = slotProps?.root ?? componentsProps.root;
  const railSlotProps = slotProps?.rail ?? componentsProps.rail;
  const trackSlotProps = slotProps?.track ?? componentsProps.track;
  const thumbSlotProps = slotProps?.thumb ?? componentsProps.thumb;
  const valueLabelSlotProps = slotProps?.valueLabel ?? componentsProps.valueLabel;
  const markSlotProps = slotProps?.mark ?? componentsProps.mark;
  const markLabelSlotProps = slotProps?.markLabel ?? componentsProps.markLabel;
  const inputSlotProps = slotProps?.input ?? componentsProps.input;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: {
      ...shouldSpreadAdditionalProps(RootSlot) && {
        as: component
      }
    },
    ownerState: {
      ...ownerState,
      ...rootSlotProps?.ownerState
    },
    className: [classes.root, className]
  });
  const railProps = useSlotProps({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = useSlotProps({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: {
        ...axisProps2[axis].offset(trackOffset),
        ...axisProps2[axis].leap(trackLeap)
      }
    },
    ownerState: {
      ...ownerState,
      ...trackSlotProps?.ownerState
    },
    className: classes.track
  });
  const thumbProps = useSlotProps({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: {
      ...ownerState,
      ...thumbSlotProps?.ownerState
    },
    className: classes.thumb
  });
  const valueLabelProps = useSlotProps({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: {
      ...ownerState,
      ...valueLabelSlotProps?.ownerState
    },
    className: classes.valueLabel
  });
  const markProps = useSlotProps({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = useSlotProps({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState,
    className: classes.markLabel
  });
  const inputSliderProps = useSlotProps({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootProps,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RailSlot, {
      ...railProps
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, {
      ...trackProps
    }), marks.filter((mark) => mark.value >= min && mark.value <= max).map((mark, index) => {
      const percent = valueToPercent(mark.value, min, max);
      const style = axisProps2[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values.includes(mark.value);
      } else {
        markActive = track === "normal" && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === "inverted" && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(MarkSlot, {
          "data-index": index,
          ...markProps,
          ...!isHostComponent(MarkSlot) && {
            markActive
          },
          style: {
            ...style,
            ...markProps.style
          },
          className: clsx(markProps.className, markActive && classes.markActive)
        }), mark.label != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkLabelSlot, {
          "aria-hidden": true,
          "data-index": index,
          ...markLabelProps,
          ...!isHostComponent(MarkLabelSlot) && {
            markLabelActive: markActive
          },
          style: {
            ...style,
            ...markLabelProps.style
          },
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        }) : null]
      }, index);
    }), values.map((value, index) => {
      const percent = valueToPercent(value, min, max);
      const style = axisProps2[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(ValueLabelComponent, {
          ...!isHostComponent(ValueLabelComponent) && {
            valueLabelFormat,
            valueLabelDisplay,
            value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index) : valueLabelFormat,
            index,
            open: open2 === index || active === index || valueLabelDisplay === "on",
            disabled
          },
          ...valueLabelProps,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, {
            "data-index": index,
            ...thumbProps,
            className: clsx(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
            style: {
              ...style,
              ...getThumbStyle(index),
              ...thumbProps.style
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, {
              "data-index": index,
              "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
              value: values[index],
              ...inputSliderProps
            })
          })
        }, index)
      );
    })]
  });
});
const ArticleIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-5 14H7v-2h7zm3-4H7v-2h10zm0-4H7V7h10z"
}));
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const CloseIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const ExpandMoreIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}));
const HearingIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17 20c-.29 0-.56-.06-.76-.15-.71-.37-1.21-.88-1.71-2.38-.51-1.56-1.47-2.29-2.39-3-.79-.61-1.61-1.24-2.32-2.53C9.29 10.98 9 9.93 9 9c0-2.8 2.2-5 5-5s5 2.2 5 5h2c0-3.93-3.07-7-7-7S7 5.07 7 9c0 1.26.38 2.65 1.07 3.9.91 1.65 1.98 2.48 2.85 3.15.81.62 1.39 1.07 1.71 2.05.6 1.82 1.37 2.84 2.73 3.55.51.23 1.07.35 1.64.35 2.21 0 4-1.79 4-4h-2c0 1.1-.9 2-2 2M7.64 2.64 6.22 1.22C4.23 3.21 3 5.96 3 9s1.23 5.79 3.22 7.78l1.41-1.41C6.01 13.74 5 11.49 5 9s1.01-4.74 2.64-6.36M11.5 9c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5-2.5 1.12-2.5 2.5"
}));
const HomeIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"
}));
const ListIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 13h2v-2H3zm0 4h2v-2H3zm0-8h2V7H3zm4 4h14v-2H7zm0 4h14v-2H7zM7 7v2h14V7z"
}));
const SearchIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}));
const SortIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 18h6v-2H3zM3 6v2h18V6zm0 7h12v-2H3z"
}));
const SortByAlphaIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M14.94 4.66h-4.72l2.36-2.36zm-4.69 14.71h4.66l-2.33 2.33zM6.1 6.27 1.6 17.73h1.84l.92-2.45h5.11l.92 2.45h1.84L7.74 6.27zm-1.13 7.37 1.94-5.18 1.94 5.18zm10.76 2.5h6.12v1.59h-8.53v-1.29l5.92-8.56h-5.88v-1.6h8.3v1.26z"
}));
const VisibilityIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5m0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"
}));
function useTypedSearchParams(route) {
  const [searchParams, setSearchParams] = useSearchParams();
  const queryString = searchParams.toString();
  const queryParams = reactExports.useMemo(
    () => parseQuery(route, queryString ? `?${queryString}` : ""),
    [route, queryString]
  );
  const setQueryParams = reactExports.useCallback(
    (params) => {
      const newSearch = renderQuery(route, params);
      setSearchParams(newSearch);
    },
    [route, setSearchParams]
  );
  const mergeQueryParams = reactExports.useCallback(
    (params) => {
      const updatedParams = { ...queryParams, ...params };
      const newSearch = renderQuery(route, updatedParams);
      setSearchParams(newSearch);
    },
    [route, setSearchParams, queryParams]
  );
  return { queryParams, setQueryParams, mergeQueryParams };
}
function ContentBreadcrumbs(props) {
  const { owner, repo, path: path2, file } = props;
  const navigate = useNavigate();
  const [config2, setConfig] = useAtom(flashManConfigAtom);
  const { breadcrumbsItems, lastPath } = reactExports.useMemo(() => {
    const pathParts = path2?.replace(/^\//, "").split("/") || [];
    const lastPath2 = pathParts.pop();
    const breadcrumbsItems2 = pathParts.reduce((ret, part) => {
      const lastPaths = ret[ret.length - 1]?.path;
      ret.push({
        name: part,
        path: lastPaths ? lastPaths + "/" + part : part
      });
      return ret;
    }, []);
    return { breadcrumbsItems: breadcrumbsItems2, lastPath: lastPath2 };
  }, [path2]);
  const handleSortToggle = () => {
    setConfig((prev) => ({ ...prev, sortByDateDesc: !prev.sortByDateDesc }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className: "ContentBreadcrumbs",
      sx: { display: "flex", marginLeft: "10px", marginRight: "10px" },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Breadcrumbs, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              color: "primary",
              onClick: () => navigate(routes.flashMan.contents.$({ owner, repo })),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(HomeIcon, {})
            }
          ),
          breadcrumbsItems.map(({ name, path: itemPath }, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              onClick: () => navigate(routes.flashMan.contents.$({ owner, repo, path: itemPath })),
              sx: { display: "flex" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FolderOpenIcon, { sx: { marginRight: ".2rem" } }),
                name
              ]
            },
            i
          )),
          lastPath && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { color: "text.secondary", sx: { display: "flex" }, children: [
            file ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArticleIcon, { sx: { marginRight: ".2rem" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FolderOpenIcon, { sx: { marginRight: ".2rem" } }),
            lastPath
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1 } }),
        !file && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleSortToggle, children: config2.sortByDateDesc ? /* @__PURE__ */ jsxRuntimeExports.jsx(SortIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SortByAlphaIcon, {}) }) })
      ]
    }
  );
}
const ContentBreadcrumbs$1 = reactExports.memo(ContentBreadcrumbs);
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
const constructFromSymbol = /* @__PURE__ */ Symbol.for("constructDateFrom");
function constructFrom(date2, value) {
  if (typeof date2 === "function") return date2(value);
  if (date2 && typeof date2 === "object" && constructFromSymbol in date2)
    return date2[constructFromSymbol](value);
  if (date2 instanceof Date) return new date2.constructor(value);
  return new Date(value);
}
function normalizeDates(context, ...dates) {
  const normalize3 = constructFrom.bind(
    null,
    dates.find((date2) => typeof date2 === "object")
  );
  return dates.map(normalize3);
}
function normalizeInterval(context, interval) {
  const [start, end] = normalizeDates(context, interval.start, interval.end);
  return { start, end };
}
function toDate(argument, context) {
  return constructFrom(argument, argument);
}
function addDays(date2, amount, options) {
  const _date = toDate(date2);
  if (isNaN(amount)) return constructFrom(date2, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date2, amount, options) {
  const _date = toDate(date2);
  if (isNaN(amount)) return constructFrom(date2, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date2, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
function add(date2, duration2, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0
  } = duration2;
  const _date = toDate(date2);
  const dateWithMonths = months || years ? addMonths(_date, months + years * 12) : _date;
  const dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  const minutesToAdd = minutes + hours * 60;
  const secondsToAdd = seconds + minutesToAdd * 60;
  const msToAdd = secondsToAdd * 1e3;
  return constructFrom(date2, +dateWithDays + msToAdd);
}
function getTimezoneOffsetInMilliseconds(date2) {
  const _date = toDate(date2);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date2 - +utcDate;
}
function startOfDay(date2, options) {
  const _date = toDate(date2);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function differenceInDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const sign = compareLocalAsc(laterDate_, earlierDate_);
  const difference = Math.abs(
    differenceInCalendarDays(laterDate_, earlierDate_)
  );
  laterDate_.setDate(laterDate_.getDate() - sign * difference);
  const isLastDayNotFull = Number(
    compareLocalAsc(laterDate_, earlierDate_) === -sign
  );
  const result = sign * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function compareLocalAsc(laterDate, earlierDate) {
  const diff = laterDate.getFullYear() - earlierDate.getFullYear() || laterDate.getMonth() - earlierDate.getMonth() || laterDate.getDate() - earlierDate.getDate() || laterDate.getHours() - earlierDate.getHours() || laterDate.getMinutes() - earlierDate.getMinutes() || laterDate.getSeconds() - earlierDate.getSeconds() || laterDate.getMilliseconds() - earlierDate.getMilliseconds();
  if (diff < 0) return -1;
  if (diff > 0) return 1;
  return diff;
}
function getRoundingMethod(method) {
  return (number2) => {
    const round = method ? Math[method] : Math.trunc;
    const result = round(number2);
    return result === 0 ? 0 : result;
  };
}
function differenceInHours(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const diff = (+laterDate_ - +earlierDate_) / millisecondsInHour;
  return getRoundingMethod(options?.roundingMethod)(diff);
}
function differenceInMilliseconds(laterDate, earlierDate) {
  return +toDate(laterDate) - +toDate(earlierDate);
}
function differenceInMinutes(dateLeft, dateRight, options) {
  const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options?.roundingMethod)(diff);
}
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}
function endOfDay(date2, options) {
  const _date = toDate(date2);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date2, options) {
  const _date = toDate(date2);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function isLastDayOfMonth(date2, options) {
  const _date = toDate(date2);
  return +endOfDay(_date) === +endOfMonth(_date);
}
function differenceInMonths(laterDate, earlierDate, options) {
  const [laterDate_, workingLaterDate, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(workingLaterDate, earlierDate_);
  const difference = Math.abs(
    differenceInCalendarMonths(workingLaterDate, earlierDate_)
  );
  if (difference < 1) return 0;
  if (workingLaterDate.getMonth() === 1 && workingLaterDate.getDate() > 27)
    workingLaterDate.setDate(30);
  workingLaterDate.setMonth(workingLaterDate.getMonth() - sign * difference);
  let isLastMonthNotFull = compareAsc(workingLaterDate, earlierDate_) === -sign;
  if (isLastDayOfMonth(laterDate_) && difference === 1 && compareAsc(laterDate_, earlierDate_) === 1) {
    isLastMonthNotFull = false;
  }
  const result = sign * (difference - +isLastMonthNotFull);
  return result === 0 ? 0 : result;
}
function differenceInSeconds(laterDate, earlierDate, options) {
  const diff = differenceInMilliseconds(laterDate, earlierDate) / 1e3;
  return getRoundingMethod(options?.roundingMethod)(diff);
}
function differenceInCalendarYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() - earlierDate_.getFullYear();
}
function differenceInYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(laterDate_, earlierDate_);
  const diff = Math.abs(differenceInCalendarYears(laterDate_, earlierDate_));
  laterDate_.setFullYear(1584);
  earlierDate_.setFullYear(1584);
  const partial = compareAsc(laterDate_, earlierDate_) === -sign;
  const result = sign * (diff - +partial);
  return result === 0 ? 0 : result;
}
function intervalToDuration(interval, options) {
  const { start, end } = normalizeInterval(options?.in, interval);
  const duration2 = {};
  const years = differenceInYears(end, start);
  if (years) duration2.years = years;
  const remainingMonths = add(start, { years: duration2.years });
  const months = differenceInMonths(end, remainingMonths);
  if (months) duration2.months = months;
  const remainingDays = add(remainingMonths, { months: duration2.months });
  const days = differenceInDays(end, remainingDays);
  if (days) duration2.days = days;
  const remainingHours = add(remainingDays, { days: duration2.days });
  const hours = differenceInHours(end, remainingHours);
  if (hours) duration2.hours = hours;
  const remainingMinutes = add(remainingHours, { hours: duration2.hours });
  const minutes = differenceInMinutes(end, remainingMinutes);
  if (minutes) duration2.minutes = minutes;
  const remainingSeconds = add(remainingMinutes, { minutes: duration2.minutes });
  const seconds = differenceInSeconds(end, remainingSeconds);
  if (seconds) duration2.seconds = seconds;
  return duration2;
}
function useLearningHistorySummary(sha) {
  const { data: histories } = useSuspenseQuery({
    queryKey: ["learningHistorySummary", sha],
    queryFn: async () => {
      if (!sha) return [];
      return getLearningHistoriesBySha(sha);
    },
    staleTime: 1e3 * 60 * 5
  });
  const summary = reactExports.useMemo(() => {
    const itemHistories = histories.filter((h) => h.type !== "fin");
    const finHistories = histories.filter((h) => h.type === "fin");
    const cntTries = finHistories.length;
    const cntPass = itemHistories.filter((h) => h.type === "pass").length;
    const cntFail = itemHistories.filter((h) => h.type === "fail").length;
    const cntTotal = cntPass + cntFail;
    const passRate = cntTotal > 0 ? cntPass / cntTotal * 100 : 0;
    const duration2 = finHistories.reduce((sum, h) => sum + h.duration, 0);
    return { histories, cntTries, cntTotal, cntPass, cntFail, passRate, duration: duration2 };
  }, [histories]);
  return summary;
}
function CircularProgressWithLabel(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { position: "relative", display: "inline-flex" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { variant: "determinate", ...props }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          position: "absolute",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", component: "div", color: "text.secondary", children: `${Math.round(props.value)}%` })
      }
    )
  ] });
}
const CircularProgressWithLabel$1 = reactExports.memo(CircularProgressWithLabel);
function formatDuration({ minutes }) {
  return `${minutes}`;
}
function ContentStatus(props) {
  const { content, simple } = props;
  const { sha, type } = content;
  const { passRate, duration: duration2, cntTries } = useLearningHistorySummary(sha);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: type === "file" && cntTries ? simple ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { component: "span", fontSize: 12, children: [
    "(",
    cntTries,
    ")"
  ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1 } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontSize: 12, sx: { marginRight: ".2rem" }, children: formatDuration(intervalToDuration({ start: 0, end: duration2 })) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { fontSize: 12, sx: { marginRight: ".2rem" }, children: [
        cntTries,
        " "
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressWithLabel$1, { value: passRate })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {}) });
}
const ContentStatus$1 = reactExports.memo(ContentStatus);
const StyledCode = styled("code")(() => ({
  fontSize: ".8rem"
}));
function ContentLabel(props) {
  const { className, content, onClick, onFileClick } = props;
  const { name, type } = content;
  const handleClick = reactExports.useCallback(() => {
    if (type === "file") {
      onFileClick?.(content);
    }
    onClick?.(content);
  }, [content, onClick, onFileClick, type]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ListItemButton,
    {
      className,
      onClick: handleClick,
      sx: {
        margin: "8px 14px",
        padding: 0
      },
      children: [
        type === "dir" && /* @__PURE__ */ jsxRuntimeExports.jsx(FolderIcon, {}),
        type === "file" && /* @__PURE__ */ jsxRuntimeExports.jsx(ArticleIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { sx: { marginLeft: ".4rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledCode, { children: name }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentStatus$1, { content }) })
      ]
    }
  );
}
const ContentLabel$1 = reactExports.memo(ContentLabel);
function ContentList(props) {
  const { owner, repo, path: path2 = "", searchQuery = "", filterType = "all" } = props;
  const contents = useContentsEx({ owner, repo, path: path2 });
  const { setActiveContent } = useActiveContent({ owner, repo });
  const { sortByDateDesc } = useAtomValue(flashManConfigAtom);
  const items = reactExports.useMemo(() => {
    const items2 = contents instanceof Array ? contents.slice(0) : [contents];
    if (sortByDateDesc) {
      items2.sort((a, b) => b.lastModified?.localeCompare(a.lastModified || "") || 0);
    }
    return items2;
  }, [contents, sortByDateDesc]);
  const filteredItems = reactExports.useMemo(() => {
    if (!searchQuery) return items;
    return items.filter((item) => item.name.toLowerCase().includes(searchQuery.toLowerCase()));
  }, [items, searchQuery]);
  const finalItems = reactExports.useMemo(() => {
    if (filterType === "all") return filteredItems;
    return filteredItems;
  }, [filteredItems, filterType]);
  reactExports.useEffect(() => {
    if (!(contents instanceof Array)) {
      const item = contents;
      setActiveContent(item);
    }
  }, [contents, setActiveContent]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ContentBreadcrumbs$1, { owner, repo, path: path2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}), children: finalItems instanceof Array && finalItems.length > 0 ? finalItems.map((content) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      ContentLabel$1,
      {
        content,
        owner,
        repo,
        onClick: setActiveContent
      },
      content.sha
    )) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { padding: 4, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: searchQuery ? "  ." : " ." }) }) })
  ] });
}
const ContentList$1 = reactExports.memo(ContentList);
function createUseThemeProps(name) {
  return useThemeProps$2;
}
function getSimpleTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiSimpleTreeView", slot);
}
generateUtilityClasses("MuiSimpleTreeView", ["root", "item", "itemContent", "itemGroupTransition", "itemIconContainer", "itemLabel", "itemCheckbox"]);
const TreeViewContext = /* @__PURE__ */ reactExports.createContext(null);
const useTreeViewContext = () => {
  const context = reactExports.useContext(TreeViewContext);
  if (context == null) {
    throw new Error(["MUI X: Could not find the Tree View context.", "It looks like you rendered your component outside of a SimpleTreeView or RichTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  return context;
};
const TreeViewStyleContext = /* @__PURE__ */ reactExports.createContext({
  classes: {},
  slots: {},
  slotProps: {}
});
const useTreeViewStyleContext = () => {
  return reactExports.useContext(TreeViewStyleContext);
};
const useTreeViewBuildContext = (parameters) => {
  const {
    store,
    apiRef,
    rootRef
  } = parameters;
  const publicAPI = useRefWithInit(() => store.buildPublicAPI()).current;
  initializeInputApiRef(publicAPI, apiRef);
  const runItemPlugins = reactExports.useCallback((itemPluginProps) => {
    let finalRootRef = null;
    let finalContentRef = null;
    const pluginPropEnhancers = [];
    const pluginPropEnhancersNames = {};
    store.itemPluginManager.listPlugins().forEach((itemPlugin) => {
      const itemPluginResponse = itemPlugin({
        props: itemPluginProps,
        rootRef: finalRootRef,
        contentRef: finalContentRef
      });
      if (itemPluginResponse?.rootRef) {
        finalRootRef = itemPluginResponse.rootRef;
      }
      if (itemPluginResponse?.contentRef) {
        finalContentRef = itemPluginResponse.contentRef;
      }
      if (itemPluginResponse?.propsEnhancers) {
        pluginPropEnhancers.push(itemPluginResponse.propsEnhancers);
        Object.keys(itemPluginResponse.propsEnhancers).forEach((propsEnhancerName) => {
          pluginPropEnhancersNames[propsEnhancerName] = true;
        });
      }
    });
    const resolvePropsEnhancer = (currentSlotName) => (currentSlotParams) => {
      const enhancedProps = {};
      pluginPropEnhancers.forEach((propsEnhancersForCurrentPlugin) => {
        const propsEnhancerForCurrentPluginAndSlot = propsEnhancersForCurrentPlugin[currentSlotName];
        if (propsEnhancerForCurrentPluginAndSlot != null) {
          Object.assign(enhancedProps, propsEnhancerForCurrentPluginAndSlot(currentSlotParams));
        }
      });
      return enhancedProps;
    };
    const propsEnhancers = Object.fromEntries(Object.keys(pluginPropEnhancersNames).map((propEnhancerName) => [propEnhancerName, resolvePropsEnhancer(propEnhancerName)]));
    return {
      contentRef: finalContentRef,
      rootRef: finalRootRef,
      propsEnhancers
    };
  }, [store]);
  const wrapItem = reactExports.useCallback(({
    itemId,
    children,
    idAttribute
  }) => {
    let finalChildren = children;
    const itemsWrapper = store.itemPluginManager.listWrappers();
    for (let i = itemsWrapper.length - 1; i >= 0; i -= 1) {
      const itemWrapper = itemsWrapper[i];
      finalChildren = itemWrapper({
        store,
        itemId,
        children: finalChildren,
        idAttribute
      });
    }
    return finalChildren;
  }, [store]);
  return reactExports.useMemo(() => ({
    runItemPlugins,
    wrapItem,
    publicAPI,
    store,
    rootRef
  }), [runItemPlugins, wrapItem, publicAPI, store, rootRef]);
};
function initializeInputApiRef(publicAPI, apiRef) {
  if (apiRef != null && apiRef.current == null) {
    apiRef.current = publicAPI;
  }
}
function TreeViewProvider(props) {
  const {
    store,
    apiRef,
    rootRef,
    classes = EMPTY_OBJECT,
    slots = EMPTY_OBJECT,
    slotProps = EMPTY_OBJECT,
    children
  } = props;
  const contextValue = useTreeViewBuildContext({
    store,
    apiRef,
    rootRef
  });
  const styleContextValue = reactExports.useMemo(() => ({
    classes,
    slots: {
      collapseIcon: slots.collapseIcon,
      expandIcon: slots.expandIcon,
      endIcon: slots.endIcon
    },
    slotProps: {
      collapseIcon: slotProps.collapseIcon,
      expandIcon: slotProps.expandIcon,
      endIcon: slotProps.endIcon
    }
  }), [classes, slots.collapseIcon, slots.expandIcon, slots.endIcon, slotProps.collapseIcon, slotProps.expandIcon, slotProps.endIcon]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewStyleContext.Provider, {
      value: styleContextValue,
      children
    })
  });
}
const _excluded$2 = ["apiRef", "slots", "slotProps", "disabledItemsFocusable", "onItemClick", "itemChildrenIndentation", "id", "expandedItems", "defaultExpandedItems", "onExpandedItemsChange", "onItemExpansionToggle", "expansionTrigger", "disableSelection", "selectedItems", "defaultSelectedItems", "multiSelect", "checkboxSelection", "selectionPropagation", "onSelectedItemsChange", "onItemSelectionToggle", "onItemFocus"];
function useExtractSimpleTreeViewParameters(props) {
  const {
    // Props for Provider
    apiRef,
    slots,
    slotProps,
    // Shared parameters
    disabledItemsFocusable,
    onItemClick,
    itemChildrenIndentation,
    id,
    expandedItems,
    defaultExpandedItems,
    onExpandedItemsChange,
    onItemExpansionToggle,
    expansionTrigger,
    disableSelection,
    selectedItems,
    defaultSelectedItems,
    multiSelect,
    checkboxSelection,
    selectionPropagation,
    onSelectedItemsChange,
    onItemSelectionToggle,
    onItemFocus
    // SimpleTreeViewStore parameters
    // Forwarded props
  } = props, forwardedProps = _objectWithoutPropertiesLoose(props, _excluded$2);
  const parameters = reactExports.useMemo(() => ({
    // Shared parameters
    disabledItemsFocusable,
    onItemClick,
    itemChildrenIndentation,
    id,
    expandedItems,
    defaultExpandedItems,
    onExpandedItemsChange,
    onItemExpansionToggle,
    expansionTrigger,
    disableSelection,
    selectedItems,
    defaultSelectedItems,
    multiSelect,
    checkboxSelection,
    selectionPropagation,
    onSelectedItemsChange,
    onItemSelectionToggle,
    onItemFocus
    // SimpleTreeViewStore parameters
  }), [
    // Shared parameters
    disabledItemsFocusable,
    onItemClick,
    itemChildrenIndentation,
    id,
    expandedItems,
    defaultExpandedItems,
    onExpandedItemsChange,
    onItemExpansionToggle,
    expansionTrigger,
    disableSelection,
    selectedItems,
    defaultSelectedItems,
    multiSelect,
    checkboxSelection,
    selectionPropagation,
    onSelectedItemsChange,
    onItemSelectionToggle,
    onItemFocus
    // SimpleTreeViewStore parameters
  ]);
  return {
    apiRef,
    slots,
    slotProps,
    parameters,
    forwardedProps
  };
}
var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object2, errorMessage = `expected an object, instead received ${typeof object2}`) {
  if (typeof object2 !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array2.every((item) => typeof item === "function")) {
    const itemTypes = array2.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length } = dependencies;
  for (let i = 0; i < length; i++) {
    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
function createSingletonCache(equals) {
  let entry;
  return {
    get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put(key, value) {
      entry = { key, value };
    },
    getEntries() {
      return entry ? [entry] : [];
    },
    clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  let entries = [];
  function get(key) {
    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
    if (cacheIndex > -1) {
      const entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({ key, value });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return { get, put, getEntries, clear };
}
var referenceEqualityCheck = (a, b) => a === b;
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    }
    const { length } = prev;
    for (let i = 0; i < length; i++) {
      if (!equalityCheck(prev[i], next[i])) {
        return false;
      }
    }
    return true;
  };
}
function lruMemoize(func, equalityCheckOrOptions) {
  const providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };
  const {
    equalityCheck = referenceEqualityCheck,
    maxSize = 1,
    resultEqualityCheck
  } = providedOptions;
  const comparator = createCacheKeyComparator(equalityCheck);
  let resultsCount = 0;
  const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    let value = cache.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const entries = cache.getEntries();
        const matchingEntry = entries.find(
          (entry) => resultEqualityCheck(entry.value, value)
        );
        if (matchingEntry) {
          value = matchingEntry.value;
          resultsCount !== 0 && resultsCount--;
        }
      }
      cache.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = () => {
    cache.clear();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    let cacheNode = fnNode;
    const { length } = arguments;
    for (let i = 0, l = length; i < l; i++) {
      const arg = arguments[i];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = lastResult?.deref?.() ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = []
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector$1 = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector$1) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);
const reselectCreateSelector = createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
});
const createSelector = (a, b, c, d, e, f, g, h, ...other) => {
  if (other.length > 0) {
    throw new Error("Unsupported number of selectors");
  }
  let selector;
  if (a && b && c && d && e && f && g && h) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      const ve = e(state, a1, a2, a3);
      const vf = f(state, a1, a2, a3);
      const vg = g(state, a1, a2, a3);
      return h(va, vb, vc, vd, ve, vf, vg, a1, a2, a3);
    };
  } else if (a && b && c && d && e && f && g) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      const ve = e(state, a1, a2, a3);
      const vf = f(state, a1, a2, a3);
      return g(va, vb, vc, vd, ve, vf, a1, a2, a3);
    };
  } else if (a && b && c && d && e && f) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      const ve = e(state, a1, a2, a3);
      return f(va, vb, vc, vd, ve, a1, a2, a3);
    };
  } else if (a && b && c && d && e) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      const vd = d(state, a1, a2, a3);
      return e(va, vb, vc, vd, a1, a2, a3);
    };
  } else if (a && b && c && d) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      const vc = c(state, a1, a2, a3);
      return d(va, vb, vc, a1, a2, a3);
    };
  } else if (a && b && c) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      const vb = b(state, a1, a2, a3);
      return c(va, vb, a1, a2, a3);
    };
  } else if (a && b) {
    selector = (state, a1, a2, a3) => {
      const va = a(state, a1, a2, a3);
      return b(va, a1, a2, a3);
    };
  } else if (a) {
    selector = a;
  } else {
    throw new Error("Missing arguments");
  }
  return selector;
};
const createSelectorMemoizedWithOptions = (options) => (...inputs) => {
  const cache = /* @__PURE__ */ new WeakMap();
  let nextCacheId = 1;
  const combiner = inputs[inputs.length - 1];
  const nSelectors = inputs.length - 1 || 1;
  const argsLength = Math.max(combiner.length - nSelectors, 0);
  if (argsLength > 3) {
    throw new Error("Unsupported number of arguments");
  }
  const selector = (state, a1, a2, a3) => {
    let cacheKey = state.__cacheKey__;
    if (!cacheKey) {
      cacheKey = {
        id: nextCacheId
      };
      state.__cacheKey__ = cacheKey;
      nextCacheId += 1;
    }
    let fn = cache.get(cacheKey);
    if (!fn) {
      const selectors = inputs.length === 1 ? [(x) => x, combiner] : inputs;
      let reselectArgs = inputs;
      const selectorArgs = [void 0, void 0, void 0];
      switch (argsLength) {
        case 0:
          break;
        case 1: {
          reselectArgs = [...selectors.slice(0, -1), () => selectorArgs[0], combiner];
          break;
        }
        case 2: {
          reselectArgs = [...selectors.slice(0, -1), () => selectorArgs[0], () => selectorArgs[1], combiner];
          break;
        }
        case 3: {
          reselectArgs = [...selectors.slice(0, -1), () => selectorArgs[0], () => selectorArgs[1], () => selectorArgs[2], combiner];
          break;
        }
        default:
          throw new Error("Unsupported number of arguments");
      }
      fn = reselectCreateSelector(...reselectArgs);
      fn.selectorArgs = selectorArgs;
      cache.set(cacheKey, fn);
    }
    switch (argsLength) {
      case 3:
        fn.selectorArgs[2] = a3;
      case 2:
        fn.selectorArgs[1] = a2;
      case 1:
        fn.selectorArgs[0] = a1;
    }
    switch (argsLength) {
      case 0:
        return fn(state);
      case 1:
        return fn(state, a1);
      case 2:
        return fn(state, a1, a2);
      case 3:
        return fn(state, a1, a2, a3);
      default:
        throw new Error("unreachable");
    }
  };
  return selector;
};
const createSelectorMemoized = createSelectorMemoizedWithOptions();
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React = requireReact();
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    );
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error2) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  {
    shim.exports = requireUseSyncExternalStoreShim_production();
  }
  return shim.exports;
}
var shimExports = requireShim();
var withSelector = { exports: {} };
var withSelector_production = {};
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React = requireReact(), shim2 = requireShim();
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim2.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
  withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireWithSelector_production();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const reactMajor = parseInt(reactExports.version, 10);
const canUseRawUseSyncExternalStore = reactMajor >= 19;
const useStoreImplementation = canUseRawUseSyncExternalStore ? useStoreR19 : useStoreLegacy;
function useStore(store, selector, a1, a2, a3) {
  return useStoreImplementation(store, selector, a1, a2, a3);
}
function useStoreR19(store, selector, a1, a2, a3) {
  const getSelection = reactExports.useCallback(() => selector(store.getSnapshot(), a1, a2, a3), [store, selector, a1, a2, a3]);
  return shimExports.useSyncExternalStore(store.subscribe, getSelection, getSelection);
}
function useStoreLegacy(store, selector, a1, a2, a3) {
  return withSelectorExports.useSyncExternalStoreWithSelector(store.subscribe, store.getSnapshot, store.getSnapshot, (state) => selector(state, a1, a2, a3));
}
class Store {
  // HACK: `any` fixes adding listeners that accept partial state.
  // Internal state to handle recursive `setState()` calls
  static create(state) {
    return new Store(state);
  }
  constructor(state) {
    this.state = state;
    this.listeners = /* @__PURE__ */ new Set();
    this.updateTick = 0;
  }
  subscribe = (fn) => {
    this.listeners.add(fn);
    return () => {
      this.listeners.delete(fn);
    };
  };
  /**
   * Returns the current state snapshot. Meant for usage with `useSyncExternalStore`.
   * If you want to access the state, use the `state` property instead.
   */
  getSnapshot = () => {
    return this.state;
  };
  setState(newState) {
    this.state = newState;
    this.updateTick += 1;
    const currentTick = this.updateTick;
    const it = this.listeners.values();
    let result;
    while (result = it.next(), !result.done) {
      if (currentTick !== this.updateTick) {
        return;
      }
      const listener = result.value;
      listener(newState);
    }
  }
  update(changes) {
    for (const key in changes) {
      if (!Object.is(this.state[key], changes[key])) {
        this.setState(_extends({}, this.state, changes));
        return;
      }
    }
  }
  set(key, value) {
    if (!Object.is(this.state[key], value)) {
      this.setState(_extends({}, this.state, {
        [key]: value
      }));
    }
  }
  use = /* @__PURE__ */ (() => (selector, a1, a2, a3) => {
    return useStore(this, selector, a1, a2, a3);
  })();
}
const treeIdSelector = createSelector((state) => state.providedTreeId ?? state.treeId);
const idSelectors = {
  /**
   * Get the id attribute of the tree view.
   */
  treeId: treeIdSelector,
  /**
   * Generate the id attribute (i.e.: the `id` attribute passed to the DOM element) of a Tree Item.
   * If the user explicitly defined an id attribute, it will be returned.
   * Otherwise, the method creates a unique id for the item based on the Tree View id attribute and the item `itemId`
   */
  treeItemIdAttribute: createSelector(treeIdSelector, (treeId, itemId, providedIdAttribute) => {
    if (providedIdAttribute != null) {
      return providedIdAttribute;
    }
    return `${treeId ?? ""}-${itemId}`;
  })
};
const TREE_VIEW_ROOT_PARENT_ID = "__TREE_VIEW_ROOT_PARENT_ID__";
const buildSiblingIndexes = (siblings) => {
  const siblingsIndexLookup = {};
  siblings.forEach((childId, index) => {
    siblingsIndexLookup[childId] = index;
  });
  return siblingsIndexLookup;
};
const isItemDisabled = (itemMetaLookup, itemId) => {
  if (itemId == null) {
    return false;
  }
  let itemMeta = itemMetaLookup[itemId];
  if (!itemMeta) {
    return false;
  }
  if (itemMeta.disabled) {
    return true;
  }
  while (itemMeta.parentId != null) {
    itemMeta = itemMetaLookup[itemMeta.parentId];
    if (!itemMeta) {
      return false;
    }
    if (itemMeta.disabled) {
      return true;
    }
  }
  return false;
};
function buildItemsLookups(parameters) {
  const {
    storeParameters,
    items,
    parentId,
    depth,
    isItemExpandable,
    otherItemsMetaLookup
  } = parameters;
  const metaLookup = {};
  const modelLookup = {};
  const orderedChildrenIds = [];
  const itemsChildren = [];
  const processItem = (item) => {
    const id = storeParameters.getItemId ? storeParameters.getItemId(item) : item.id;
    checkId({
      id,
      parentId,
      item,
      itemMetaLookup: otherItemsMetaLookup,
      siblingsMetaLookup: metaLookup
    });
    const label = storeParameters.getItemLabel ? storeParameters.getItemLabel(item) : item.label;
    if (label == null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "Alternatively, you can use the `getItemLabel` prop to specify a custom label for each item.", "An item was provided without label in the `items` prop:", JSON.stringify(item)].join("\n"));
    }
    const children = (storeParameters.getItemChildren ? storeParameters.getItemChildren(item) : item.children) || [];
    itemsChildren.push({
      id,
      children
    });
    modelLookup[id] = item;
    metaLookup[id] = {
      id,
      label,
      parentId,
      idAttribute: void 0,
      expandable: isItemExpandable(item, children),
      disabled: storeParameters.isItemDisabled ? storeParameters.isItemDisabled(item) : false,
      selectable: storeParameters.isItemSelectionDisabled ? !storeParameters.isItemSelectionDisabled(item) : true,
      depth
    };
    orderedChildrenIds.push(id);
  };
  for (const item of items) {
    processItem(item);
  }
  return {
    metaLookup,
    modelLookup,
    orderedChildrenIds,
    childrenIndexes: buildSiblingIndexes(orderedChildrenIds),
    itemsChildren
  };
}
function checkId({
  id,
  parentId,
  item,
  itemMetaLookup,
  siblingsMetaLookup
}) {
  if (id == null) {
    throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", "An item was provided without id in the `items` prop:", JSON.stringify(item)].join("\n"));
  }
  if (siblingsMetaLookup[id] != null || // Ignore items with the same parent id, because it's the same item from the previous generation.
  itemMetaLookup[id] != null && itemMetaLookup[id].parentId !== parentId) {
    throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${id}"`].join("\n"));
  }
}
const EMPTY_CHILDREN = [];
const itemsSelectors = {
  /**
   * Gets the DOM structure of the Tree View.
   */
  domStructure: createSelector((state) => state.domStructure),
  /**
   * Checks whether the disabled items are focusable.
   */
  disabledItemFocusable: createSelector((state) => state.disabledItemsFocusable),
  /**
   * Gets the meta-information of all items.
   */
  itemMetaLookup: createSelector((state) => state.itemMetaLookup),
  /**
   * Gets the ordered children ids of all items.
   */
  itemOrderedChildrenIdsLookup: createSelector((state) => state.itemOrderedChildrenIdsLookup),
  /**
   * Gets the meta-information of an item.
   */
  itemMeta: createSelector((state, itemId) => state.itemMetaLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? null),
  /**
   * Gets the ordered children ids of an item.
   */
  itemOrderedChildrenIds: createSelector((state, itemId) => state.itemOrderedChildrenIdsLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? EMPTY_CHILDREN),
  /**
   * Gets the model of an item.
   */
  itemModel: createSelector((state, itemId) => state.itemModelLookup[itemId]),
  /**
   * Checks whether an item is disabled.
   */
  isItemDisabled: createSelector((state, itemId) => isItemDisabled(state.itemMetaLookup, itemId)),
  /**
   * Gets the index of an item in its parent's children.
   */
  itemIndex: createSelector((state, itemId) => {
    const itemMeta = state.itemMetaLookup[itemId];
    if (itemMeta == null) {
      return -1;
    }
    const parentIndexes = state.itemChildrenIndexesLookup[itemMeta.parentId ?? TREE_VIEW_ROOT_PARENT_ID];
    return parentIndexes[itemMeta.id];
  }),
  /**
   * Gets the id of an item's parent.
   */
  itemParentId: createSelector((state, itemId) => state.itemMetaLookup[itemId]?.parentId ?? null),
  /**
   * Gets the depth of an item (items at the root level have a depth of 0).
   */
  itemDepth: createSelector((state, itemId) => state.itemMetaLookup[itemId]?.depth ?? 0),
  /**
   * Checks whether an item can be focused.
   */
  canItemBeFocused: createSelector((state, itemId) => state.disabledItemsFocusable || !isItemDisabled(state.itemMetaLookup, itemId)),
  /**
   * Gets the identation between an item and its children.
   */
  itemChildrenIndentation: createSelector((state) => state.itemChildrenIndentation)
};
class TreeViewItemsPlugin {
  // We can't type `store`, otherwise we get the following TS error:
  // 'items' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
  constructor(store) {
    this.store = store;
  }
  /**
   * Determines if the items state should be rebuilt based on the new and previous parameters.
   */
  static shouldRebuildItemsState = (newParameters, previousParameters) => {
    return ["items", "isItemDisabled", "isItemSelectionDisabled", "getItemId", "getItemLabel", "getItemChildren"].some((key) => {
      const typedKey = key;
      return newParameters[typedKey] !== previousParameters[typedKey];
    });
  };
  /**
   * Builds the state properties derived from the `items` prop.
   */
  static buildItemsStateIfNeeded = (parameters) => {
    const itemMetaLookup = {};
    const itemModelLookup = {};
    const itemOrderedChildrenIdsLookup = {};
    const itemChildrenIndexesLookup = {};
    function processSiblings(items, parentId, depth) {
      const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
      const {
        metaLookup,
        modelLookup,
        orderedChildrenIds,
        childrenIndexes,
        itemsChildren
      } = buildItemsLookups({
        storeParameters: parameters,
        items,
        parentId,
        depth,
        isItemExpandable: (item, children) => !!children && children.length > 0,
        otherItemsMetaLookup: itemMetaLookup
      });
      Object.assign(itemMetaLookup, metaLookup);
      Object.assign(itemModelLookup, modelLookup);
      itemOrderedChildrenIdsLookup[parentIdWithDefault] = orderedChildrenIds;
      itemChildrenIndexesLookup[parentIdWithDefault] = childrenIndexes;
      for (const item of itemsChildren) {
        processSiblings(item.children || [], item.id, depth + 1);
      }
    }
    processSiblings(parameters.items, null, 0);
    return {
      itemMetaLookup,
      itemModelLookup,
      itemOrderedChildrenIdsLookup,
      itemChildrenIndexesLookup
    };
  };
  /**
   * Get the item with the given id.
   * When used in the Simple Tree View, it returns an object with the `id` and `label` properties.
   * @param {TreeViewItemId} itemId The id of the item to retrieve.
   * @returns {R} The item with the given id.
   */
  getItem = (itemId) => itemsSelectors.itemModel(this.store.state, itemId);
  /**
   * Get all the items in the same format as provided by `props.items`.
   * @returns {R[]} The items in the tree.
   */
  getItemTree = () => {
    const getItemFromItemId = (itemId) => {
      const item = itemsSelectors.itemModel(this.store.state, itemId);
      const itemToMutate = _extends({}, item);
      const newChildren = itemsSelectors.itemOrderedChildrenIds(this.store.state, itemId);
      if (newChildren.length > 0) {
        itemToMutate.children = newChildren.map(getItemFromItemId);
      } else {
        delete itemToMutate.children;
      }
      return itemToMutate;
    };
    return itemsSelectors.itemOrderedChildrenIds(this.store.state, null).map(getItemFromItemId);
  };
  /**
   * Get the ids of a given item's children.
   * Those ids are returned in the order they should be rendered.
   * To get the root items, pass `null` as the `itemId`.
   * @param {TreeViewItemId | null} itemId The id of the item to get the children of.
   * @returns {TreeViewItemId[]} The ids of the item's children.
   */
  getItemOrderedChildrenIds = (itemId) => itemsSelectors.itemOrderedChildrenIds(this.store.state, itemId);
  /** * Get the id of the parent item.
   * @param {TreeViewItemId} itemId The id of the item to whose parentId we want to retrieve.
   * @returns {TreeViewItemId | null} The id of the parent item.
   */
  getParentId = (itemId) => {
    const itemMeta = itemsSelectors.itemMeta(this.store.state, itemId);
    return itemMeta?.parentId || null;
  };
  /**
   * Toggle the disabled state of the item with the given id.
   * @param {object} parameters The params of the method.
   * @param {TreeViewItemId } parameters.itemId The id of the item to get the children of.
   * @param {boolean } parameters.shouldBeDisabled true if the item should be disabled.
   */
  setIsItemDisabled = ({
    itemId,
    shouldBeDisabled
  }) => {
    if (!this.store.state.itemMetaLookup[itemId]) {
      return;
    }
    const itemMetaLookup = _extends({}, this.store.state.itemMetaLookup);
    itemMetaLookup[itemId] = _extends({}, itemMetaLookup[itemId], {
      disabled: shouldBeDisabled ?? !itemMetaLookup[itemId].disabled
    });
    this.store.set("itemMetaLookup", itemMetaLookup);
  };
  buildPublicAPI = () => {
    return {
      getItem: this.getItem,
      getItemDOMElement: this.getItemDOMElement,
      getItemOrderedChildrenIds: this.getItemOrderedChildrenIds,
      getItemTree: this.getItemTree,
      getParentId: this.getParentId,
      setIsItemDisabled: this.setIsItemDisabled
    };
  };
  /**
   * Get the DOM element of the item with the given id.
   * @param {TreeViewItemId} itemId The id of the item to get the DOM element of.
   * @returns {HTMLElement | null} The DOM element of the item with the given id.
   */
  getItemDOMElement = (itemId) => {
    const itemMeta = itemsSelectors.itemMeta(this.store.state, itemId);
    if (itemMeta == null) {
      return null;
    }
    const idAttribute = idSelectors.treeItemIdAttribute(this.store.state, itemId, itemMeta.idAttribute);
    return document.getElementById(idAttribute);
  };
  /**
   * Add an array of items to the tree.
   * @param {SetItemChildrenParameters<R>} args The items to add to the tree and information about their ancestors.
   */
  setItemChildren = ({
    items,
    parentId,
    getChildrenCount
  }) => {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    const parentDepth = parentId == null ? -1 : itemsSelectors.itemDepth(this.store.state, parentId);
    const {
      metaLookup,
      modelLookup,
      orderedChildrenIds,
      childrenIndexes
    } = buildItemsLookups({
      storeParameters: this.store.parameters,
      items,
      parentId,
      depth: parentDepth + 1,
      isItemExpandable: getChildrenCount ? (item) => getChildrenCount(item) !== 0 : () => false,
      otherItemsMetaLookup: itemsSelectors.itemMetaLookup(this.store.state)
    });
    this.store.update({
      itemModelLookup: _extends({}, this.store.state.itemModelLookup, modelLookup),
      itemMetaLookup: _extends({}, this.store.state.itemMetaLookup, metaLookup),
      itemOrderedChildrenIdsLookup: _extends({}, this.store.state.itemOrderedChildrenIdsLookup, {
        [parentIdWithDefault]: orderedChildrenIds
      }),
      itemChildrenIndexesLookup: _extends({}, this.store.state.itemChildrenIndexesLookup, {
        [parentIdWithDefault]: childrenIndexes
      })
    });
  };
  /**
   * Remove the children of an item.
   * @param {TreeViewItemId | null} parentId The id of the item to remove the children of.
   */
  removeChildren = (parentId) => {
    const itemMetaLookup = this.store.state.itemMetaLookup;
    const newMetaMap = Object.keys(itemMetaLookup).reduce((acc, key) => {
      const item = itemMetaLookup[key];
      if (item.parentId === parentId) {
        return acc;
      }
      return _extends({}, acc, {
        [item.id]: item
      });
    }, {});
    const newItemOrderedChildrenIdsLookup = _extends({}, this.store.state.itemOrderedChildrenIdsLookup);
    const newItemChildrenIndexesLookup = _extends({}, this.store.state.itemChildrenIndexesLookup);
    const cleanId = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    delete newItemChildrenIndexesLookup[cleanId];
    delete newItemOrderedChildrenIdsLookup[cleanId];
    this.store.update({
      itemMetaLookup: newMetaMap,
      itemOrderedChildrenIdsLookup: newItemOrderedChildrenIdsLookup,
      itemChildrenIndexesLookup: newItemChildrenIndexesLookup
    });
  };
  /**
   * Callback fired when the `content` slot of a given Tree Item is clicked.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the item being clicked.
   */
  handleItemClick = (event, itemId) => {
    this.store.parameters.onItemClick?.(event, itemId);
  };
}
const selectedItemsSelector = createSelectorMemoized((state) => state.selectedItems, (selectedItemsRaw) => {
  if (Array.isArray(selectedItemsRaw)) {
    return selectedItemsRaw;
  }
  if (selectedItemsRaw != null) {
    return [selectedItemsRaw];
  }
  return [];
});
const selectedItemsMapSelector = createSelectorMemoized(selectedItemsSelector, (selectedItems) => {
  const selectedItemsMap = /* @__PURE__ */ new Map();
  selectedItems.forEach((id) => {
    selectedItemsMap.set(id, true);
  });
  return selectedItemsMap;
});
const isItemSelectableSelector = createSelector((state, itemId) => state.itemMetaLookup[itemId]?.selectable ?? true);
const selectionSelectors = {
  /**
   * Gets the selected items as provided to the component.
   */
  selectedItemsRaw: createSelector((state) => state.selectedItems),
  /**
   * Gets the selected items as an array.
   */
  selectedItems: selectedItemsSelector,
  /**
   * Gets the selected items as a Map.
   */
  selectedItemsMap: selectedItemsMapSelector,
  /**
   * Checks whether selection is enabled.
   */
  enabled: createSelector((state) => !state.disableSelection),
  /**
   * Checks whether multi selection is enabled.
   */
  isMultiSelectEnabled: createSelector((state) => state.multiSelect),
  /**
   * Checks whether checkbox selection is enabled.
   */
  isCheckboxSelectionEnabled: createSelector((state) => state.checkboxSelection),
  /**
   * Gets the selection propagation rules.
   */
  propagationRules: createSelector((state) => state.selectionPropagation),
  /**
   * Checks whether an item is selected.
   */
  isItemSelected: createSelector(selectedItemsMapSelector, (selectedItemsMap, itemId) => selectedItemsMap.has(itemId)),
  /**
   * Checks whether the selection feature is enabled for an item.
   * Returns `true` when selection is enabled on the Tree View and the item is selectable (even if the item is disabled).
   */
  isFeatureEnabledForItem: createSelector(isItemSelectableSelector, (state) => !state.disableSelection, (isItemSelectable, isSelectionEnabled, _itemId) => isSelectionEnabled && isItemSelectable),
  /**
   * Checks whether an item can be selected (if selection is enabled, if the item is not disabled, and if the item is selectable).
   */
  canItemBeSelected: createSelector(itemsSelectors.isItemDisabled, isItemSelectableSelector, (state) => !state.disableSelection, (isItemDisabled2, isItemSelectable, isSelectionEnabled, _itemId) => isSelectionEnabled && !isItemDisabled2 && isItemSelectable),
  /**
   * Checks whether an item is selectable based on the `isItemSelectionDisabled` prop.
   */
  isItemSelectable: isItemSelectableSelector
};
const selectorCheckboxSelectionStatus = createSelector((state, itemId) => {
  if (selectionSelectors.isItemSelected(state, itemId)) {
    return "checked";
  }
  let hasSelectedDescendant = false;
  let hasUnSelectedDescendant = false;
  const traverseDescendants = (itemToTraverseId) => {
    if (itemToTraverseId !== itemId) {
      if (selectionSelectors.isItemSelected(state, itemToTraverseId)) {
        hasSelectedDescendant = true;
      } else {
        hasUnSelectedDescendant = true;
      }
    }
    itemsSelectors.itemOrderedChildrenIds(state, itemToTraverseId).forEach(traverseDescendants);
  };
  traverseDescendants(itemId);
  const shouldSelectBasedOnDescendants = selectionSelectors.propagationRules(state).parents;
  if (shouldSelectBasedOnDescendants) {
    if (hasSelectedDescendant && hasUnSelectedDescendant) {
      return "indeterminate";
    }
    if (hasSelectedDescendant && !hasUnSelectedDescendant) {
      return "checked";
    }
    return "empty";
  }
  if (hasSelectedDescendant) {
    return "indeterminate";
  }
  return "empty";
});
const useSelectionItemPlugin = ({
  props
}) => {
  const {
    itemId
  } = props;
  const {
    store
  } = useTreeViewContext();
  const isCheckboxSelectionEnabled = useStore(store, selectionSelectors.isCheckboxSelectionEnabled);
  const isFeatureEnabledForItem = useStore(store, selectionSelectors.isFeatureEnabledForItem, itemId);
  const canItemBeSelected = useStore(store, selectionSelectors.canItemBeSelected, itemId);
  const selectionStatus = useStore(store, selectorCheckboxSelectionStatus, itemId);
  return {
    propsEnhancers: {
      root: () => {
        let ariaChecked;
        if (selectionStatus === "checked") {
          ariaChecked = true;
        } else if (selectionStatus === "indeterminate") {
          ariaChecked = "mixed";
        } else if (!canItemBeSelected) {
          ariaChecked = void 0;
        } else {
          ariaChecked = false;
        }
        return {
          "aria-checked": ariaChecked
        };
      },
      checkbox: ({
        externalEventHandlers,
        interactions
      }) => {
        const handleChange = (event) => {
          externalEventHandlers.onChange?.(event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (!selectionSelectors.canItemBeSelected(store.state, itemId)) {
            return;
          }
          interactions.handleCheckboxSelection(event);
        };
        return {
          tabIndex: -1,
          onChange: handleChange,
          visible: isCheckboxSelectionEnabled && isFeatureEnabledForItem,
          disabled: !canItemBeSelected,
          checked: selectionStatus === "checked",
          indeterminate: selectionStatus === "indeterminate"
        };
      }
    }
  };
};
const expandedItemMapSelector = createSelectorMemoized((state) => state.expandedItems, (expandedItems) => {
  const expandedItemsMap = /* @__PURE__ */ new Map();
  expandedItems.forEach((id) => {
    expandedItemsMap.set(id, true);
  });
  return expandedItemsMap;
});
const expansionSelectors = {
  /**
   * Gets the expanded items as provided to the component.
   */
  expandedItemsRaw: createSelector((state) => state.expandedItems),
  /**
   * Gets the expanded items as a Map.
   */
  expandedItemsMap: expandedItemMapSelector,
  /**
   * Gets the items to render as a flat list (the descendants of an expanded item are listed as siblings of the item).
   */
  flatList: createSelectorMemoized(itemsSelectors.itemOrderedChildrenIdsLookup, expandedItemMapSelector, (itemOrderedChildrenIds, expandedItemsMap) => {
    function appendChildren(itemId) {
      if (!expandedItemsMap.has(itemId)) {
        return [itemId];
      }
      const itemsWithDescendants = [itemId];
      const children = itemOrderedChildrenIds[itemId] || [];
      for (const childId of children) {
        itemsWithDescendants.push(...appendChildren(childId));
      }
      return itemsWithDescendants;
    }
    return (itemOrderedChildrenIds[TREE_VIEW_ROOT_PARENT_ID] ?? []).flatMap(appendChildren);
  }),
  /**
   * Gets the slot that triggers the item's expansion when clicked.
   */
  triggerSlot: createSelector((state) => state.expansionTrigger),
  /**
   * Checks whether an item is expanded.
   */
  isItemExpanded: createSelector(expandedItemMapSelector, (expandedItemsMap, itemId) => expandedItemsMap.has(itemId)),
  /**
   * Checks whether an item is expandable.
   */
  isItemExpandable: createSelector(itemsSelectors.itemMeta, (itemMeta, _itemId) => itemMeta?.expandable ?? false)
};
const getLastNavigableItemInArray = (state, items) => {
  let itemIndex = items.length - 1;
  while (itemIndex >= 0 && !itemsSelectors.canItemBeFocused(state, items[itemIndex])) {
    itemIndex -= 1;
  }
  if (itemIndex === -1) {
    return void 0;
  }
  return items[itemIndex];
};
const getPreviousNavigableItem = (state, itemId) => {
  const itemMeta = itemsSelectors.itemMeta(state, itemId);
  if (!itemMeta) {
    return null;
  }
  const siblings = itemsSelectors.itemOrderedChildrenIds(state, itemMeta.parentId);
  const itemIndex = itemsSelectors.itemIndex(state, itemId);
  if (itemIndex === 0) {
    return itemMeta.parentId;
  }
  let previousNavigableSiblingIndex = itemIndex - 1;
  while (!itemsSelectors.canItemBeFocused(state, siblings[previousNavigableSiblingIndex]) && previousNavigableSiblingIndex >= 0) {
    previousNavigableSiblingIndex -= 1;
  }
  if (previousNavigableSiblingIndex === -1) {
    if (itemMeta.parentId == null) {
      return null;
    }
    return getPreviousNavigableItem(state, itemMeta.parentId);
  }
  let currentItemId = siblings[previousNavigableSiblingIndex];
  let lastNavigableChild = getLastNavigableItemInArray(state, itemsSelectors.itemOrderedChildrenIds(state, currentItemId));
  while (expansionSelectors.isItemExpanded(state, currentItemId) && lastNavigableChild != null) {
    currentItemId = lastNavigableChild;
    lastNavigableChild = getLastNavigableItemInArray(state, itemsSelectors.itemOrderedChildrenIds(state, currentItemId));
  }
  return currentItemId;
};
const getNextNavigableItem = (state, itemId) => {
  if (expansionSelectors.isItemExpanded(state, itemId)) {
    const firstNavigableChild = itemsSelectors.itemOrderedChildrenIds(state, itemId).find((childId) => itemsSelectors.canItemBeFocused(state, childId));
    if (firstNavigableChild != null) {
      return firstNavigableChild;
    }
  }
  let itemMeta = itemsSelectors.itemMeta(state, itemId);
  while (itemMeta != null) {
    const siblings = itemsSelectors.itemOrderedChildrenIds(state, itemMeta.parentId);
    const currentItemIndex = itemsSelectors.itemIndex(state, itemMeta.id);
    if (currentItemIndex < siblings.length - 1) {
      let nextItemIndex = currentItemIndex + 1;
      while (!itemsSelectors.canItemBeFocused(state, siblings[nextItemIndex]) && nextItemIndex < siblings.length - 1) {
        nextItemIndex += 1;
      }
      if (itemsSelectors.canItemBeFocused(state, siblings[nextItemIndex])) {
        return siblings[nextItemIndex];
      }
    }
    itemMeta = itemsSelectors.itemMeta(state, itemMeta.parentId);
  }
  return null;
};
const getLastNavigableItem = (state) => {
  let itemId = null;
  while (itemId == null || expansionSelectors.isItemExpanded(state, itemId)) {
    const children = itemsSelectors.itemOrderedChildrenIds(state, itemId);
    const lastNavigableChild = getLastNavigableItemInArray(state, children);
    if (lastNavigableChild == null) {
      return itemId;
    }
    itemId = lastNavigableChild;
  }
  return itemId;
};
const getFirstNavigableItem = (state) => itemsSelectors.itemOrderedChildrenIds(state, null).find((itemId) => itemsSelectors.canItemBeFocused(state, itemId));
const findOrderInTremauxTree = (state, itemAId, itemBId) => {
  if (itemAId === itemBId) {
    return [itemAId, itemBId];
  }
  const itemMetaA = itemsSelectors.itemMeta(state, itemAId);
  const itemMetaB = itemsSelectors.itemMeta(state, itemBId);
  if (!itemMetaA || !itemMetaB) {
    return [itemAId, itemBId];
  }
  if (itemMetaA.parentId === itemMetaB.id || itemMetaB.parentId === itemMetaA.id) {
    return itemMetaB.parentId === itemMetaA.id ? [itemMetaA.id, itemMetaB.id] : [itemMetaB.id, itemMetaA.id];
  }
  const aFamily = [itemMetaA.id];
  const bFamily = [itemMetaB.id];
  let aAncestor = itemMetaA.parentId;
  let bAncestor = itemMetaB.parentId;
  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
  let continueA = true;
  let continueB = true;
  while (!bAncestorIsCommon && !aAncestorIsCommon) {
    if (continueA) {
      aFamily.push(aAncestor);
      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
      continueA = aAncestor !== null;
      if (!aAncestorIsCommon && continueA) {
        aAncestor = itemsSelectors.itemParentId(state, aAncestor);
      }
    }
    if (continueB && !aAncestorIsCommon) {
      bFamily.push(bAncestor);
      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
      continueB = bAncestor !== null;
      if (!bAncestorIsCommon && continueB) {
        bAncestor = itemsSelectors.itemParentId(state, bAncestor);
      }
    }
  }
  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
  const ancestorFamily = itemsSelectors.itemOrderedChildrenIds(state, commonAncestor);
  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [itemAId, itemBId] : [itemBId, itemAId];
};
const getNonDisabledItemsInRange = (state, itemAId, itemBId) => {
  const getNextItem = (itemId) => {
    if (expansionSelectors.isItemExpandable(state, itemId) && expansionSelectors.isItemExpanded(state, itemId)) {
      return itemsSelectors.itemOrderedChildrenIds(state, itemId)[0];
    }
    let itemMeta = itemsSelectors.itemMeta(state, itemId);
    while (itemMeta != null) {
      const siblings = itemsSelectors.itemOrderedChildrenIds(state, itemMeta.parentId);
      const currentItemIndex = itemsSelectors.itemIndex(state, itemMeta.id);
      if (currentItemIndex < siblings.length - 1) {
        return siblings[currentItemIndex + 1];
      }
      itemMeta = itemMeta.parentId ? itemsSelectors.itemMeta(state, itemMeta.parentId) : null;
    }
    throw new Error("Invalid range");
  };
  const [first, last] = findOrderInTremauxTree(state, itemAId, itemBId);
  const items = [first];
  let current = first;
  while (current !== last) {
    current = getNextItem(current);
    if (!itemsSelectors.isItemDisabled(state, current)) {
      items.push(current);
    }
  }
  return items;
};
const getAllNavigableItems = (state) => {
  let item = getFirstNavigableItem(state);
  const navigableItems = [];
  while (item != null) {
    navigableItems.push(item);
    item = getNextNavigableItem(state, item);
  }
  return navigableItems;
};
const isTargetInDescendants = (target, itemRoot) => {
  return itemRoot !== target.closest('*[role="treeitem"]');
};
class TreeViewSelectionPlugin {
  lastSelectedItem = null;
  lastSelectedRange = {};
  // We can't type `store`, otherwise we get the following TS error:
  // 'selection' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
  constructor(store) {
    this.store = store;
    store.itemPluginManager.register(useSelectionItemPlugin, null);
  }
  setSelectedItems = (event, newModel, additionalItemsToPropagate) => {
    const {
      selectionPropagation = EMPTY_OBJECT,
      selectedItems,
      onItemSelectionToggle,
      onSelectedItemsChange
    } = this.store.parameters;
    const oldModel = selectionSelectors.selectedItemsRaw(this.store.state);
    let cleanModel;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(this.store.state);
    if (isMultiSelectEnabled && (selectionPropagation.descendants || selectionPropagation.parents)) {
      cleanModel = propagateSelection({
        store: this.store,
        selectionPropagation,
        newModel,
        oldModel,
        additionalItemsToPropagate
      });
    } else {
      cleanModel = newModel;
    }
    if (onItemSelectionToggle) {
      if (isMultiSelectEnabled) {
        const changes = getAddedAndRemovedItems({
          store: this.store,
          newModel: cleanModel,
          oldModel
        });
        if (onItemSelectionToggle) {
          changes.added.forEach((itemId) => {
            onItemSelectionToggle(event, itemId, true);
          });
          changes.removed.forEach((itemId) => {
            onItemSelectionToggle(event, itemId, false);
          });
        }
      } else if (cleanModel !== oldModel) {
        if (oldModel != null) {
          onItemSelectionToggle(event, oldModel, false);
        }
        if (cleanModel != null) {
          onItemSelectionToggle(event, cleanModel, true);
        }
      }
    }
    if (selectedItems === void 0) {
      this.store.set("selectedItems", cleanModel);
    }
    onSelectedItemsChange?.(event, cleanModel);
  };
  selectRange = (event, [start, end]) => {
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(this.store.state);
    if (!isMultiSelectEnabled) {
      return;
    }
    let newSelectedItems = selectionSelectors.selectedItems(this.store.state).slice();
    if (Object.keys(this.lastSelectedRange).length > 0) {
      newSelectedItems = newSelectedItems.filter((id) => !this.lastSelectedRange[id]);
    }
    const selectedItemsLookup = getLookupFromArray(newSelectedItems);
    const range = getNonDisabledItemsInRange(this.store.state, start, end).filter((id) => selectionSelectors.isItemSelectable(this.store.state, id));
    const itemsToAddToModel = range.filter((id) => !selectedItemsLookup[id]);
    newSelectedItems = newSelectedItems.concat(itemsToAddToModel);
    this.setSelectedItems(event, newSelectedItems);
    this.lastSelectedRange = getLookupFromArray(range);
  };
  buildPublicAPI = () => {
    return {
      setItemSelection: this.setItemSelection
    };
  };
  /**
   * Select or deselect an item.
   * @param {object} parameters The parameters of the method.
   * @param {TreeViewItemId} parameters.itemId The id of the item to select or deselect.
   * @param {React.SyntheticEvent} parameters.event The DOM event that triggered the change.
   * @param {boolean} parameters.keepExistingSelection If `true`, the other already selected items will remain selected, otherwise, they will be deselected. This parameter is only relevant when `multiSelect` is `true`
   * @param {boolean | undefined} parameters.shouldBeSelected If `true` the item will be selected. If `false` the item will be deselected. If not defined, the item's selection status will be toggled.
   */
  setItemSelection = ({
    itemId,
    event = null,
    keepExistingSelection = false,
    shouldBeSelected
  }) => {
    if (!selectionSelectors.enabled(this.store.state)) {
      return;
    }
    let newSelected;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(this.store.state);
    if (keepExistingSelection) {
      const oldSelected = selectionSelectors.selectedItems(this.store.state);
      const isSelectedBefore = selectionSelectors.isItemSelected(this.store.state, itemId);
      if (isSelectedBefore && (shouldBeSelected === false || shouldBeSelected == null)) {
        newSelected = oldSelected.filter((id) => id !== itemId);
      } else if (!isSelectedBefore && (shouldBeSelected === true || shouldBeSelected == null)) {
        newSelected = [itemId].concat(oldSelected);
      } else {
        newSelected = oldSelected;
      }
    } else {
      if (shouldBeSelected === false || shouldBeSelected == null && selectionSelectors.isItemSelected(this.store.state, itemId)) {
        newSelected = isMultiSelectEnabled ? [] : null;
      } else {
        newSelected = isMultiSelectEnabled ? [itemId] : itemId;
      }
    }
    this.setSelectedItems(
      event,
      newSelected,
      // If shouldBeSelected === selectionSelectors.isItemSelected(store, itemId), we still want to propagate the select.
      // This is useful when the element is in an indeterminate state.
      [itemId]
    );
    this.lastSelectedItem = itemId;
    this.lastSelectedRange = {};
  };
  /**
   * Select all the navigable items in the tree.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   */
  selectAllNavigableItems = (event) => {
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(this.store.state);
    if (!isMultiSelectEnabled) {
      return;
    }
    const navigableItems = getAllNavigableItems(this.store.state);
    this.setSelectedItems(event, navigableItems);
    this.lastSelectedRange = getLookupFromArray(navigableItems);
  };
  /**
   * Expand the current selection range up to the given item.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the item to expand the selection to.
   */
  expandSelectionRange = (event, itemId) => {
    if (this.lastSelectedItem != null) {
      const [start, end] = findOrderInTremauxTree(this.store.state, itemId, this.lastSelectedItem);
      this.selectRange(event, [start, end]);
    }
  };
  /**
   * Expand the current selection range from the first navigable item to the given item.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the item up to which the selection range should be expanded.
   */
  selectRangeFromStartToItem = (event, itemId) => {
    this.selectRange(event, [getFirstNavigableItem(this.store.state), itemId]);
  };
  /**
   * Expand the current selection range from the given item to the last navigable item.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the item from which the selection range should be expanded.
   */
  selectRangeFromItemToEnd = (event, itemId) => {
    this.selectRange(event, [itemId, getLastNavigableItem(this.store.state)]);
  };
  /**
   * Update the selection when navigating with ArrowUp / ArrowDown keys.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} currentItemId The id of the active item before the keyboard navigation.
   * @param {TreeViewItemId} nextItemId The id of the active item after the keyboard navigation.
   */
  selectItemFromArrowNavigation = (event, currentItem, nextItem) => {
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(this.store.state);
    if (!isMultiSelectEnabled) {
      return;
    }
    let newSelectedItems = selectionSelectors.selectedItems(this.store.state).slice();
    if (Object.keys(this.lastSelectedRange).length === 0) {
      newSelectedItems.push(nextItem);
      this.lastSelectedRange = {
        [currentItem]: true,
        [nextItem]: true
      };
    } else {
      if (!this.lastSelectedRange[currentItem]) {
        this.lastSelectedRange = {};
      }
      if (this.lastSelectedRange[nextItem]) {
        newSelectedItems = newSelectedItems.filter((id) => id !== currentItem);
        delete this.lastSelectedRange[currentItem];
      } else {
        newSelectedItems.push(nextItem);
        this.lastSelectedRange[nextItem] = true;
      }
    }
    this.setSelectedItems(event, newSelectedItems);
  };
}
function propagateSelection({
  store,
  selectionPropagation,
  newModel,
  oldModel,
  additionalItemsToPropagate
}) {
  if (!selectionPropagation.descendants && !selectionPropagation.parents) {
    return newModel;
  }
  let shouldRegenerateModel = false;
  const newModelLookup = getLookupFromArray(newModel);
  const changes = getAddedAndRemovedItems({
    store,
    newModel,
    oldModel
  });
  additionalItemsToPropagate?.forEach((itemId) => {
    if (newModelLookup[itemId]) {
      if (!changes.added.includes(itemId)) {
        changes.added.push(itemId);
      }
    } else if (!changes.removed.includes(itemId)) {
      changes.removed.push(itemId);
    }
  });
  changes.added.forEach((addedItemId) => {
    if (selectionPropagation.descendants) {
      const selectDescendants = (itemId) => {
        if (itemId !== addedItemId) {
          shouldRegenerateModel = true;
          newModelLookup[itemId] = true;
        }
        itemsSelectors.itemOrderedChildrenIds(store.state, itemId).forEach(selectDescendants);
      };
      selectDescendants(addedItemId);
    }
    if (selectionPropagation.parents) {
      const checkAllDescendantsSelected = (itemId) => {
        if (!newModelLookup[itemId]) {
          return false;
        }
        const children = itemsSelectors.itemOrderedChildrenIds(store.state, itemId);
        return children.every(checkAllDescendantsSelected);
      };
      const selectParents = (itemId) => {
        const parentId = itemsSelectors.itemParentId(store.state, itemId);
        if (parentId == null) {
          return;
        }
        const siblings = itemsSelectors.itemOrderedChildrenIds(store.state, parentId);
        if (siblings.every(checkAllDescendantsSelected)) {
          shouldRegenerateModel = true;
          newModelLookup[parentId] = true;
          selectParents(parentId);
        }
      };
      selectParents(addedItemId);
    }
  });
  changes.removed.forEach((removedItemId) => {
    if (selectionPropagation.parents) {
      let parentId = itemsSelectors.itemParentId(store.state, removedItemId);
      while (parentId != null) {
        if (newModelLookup[parentId]) {
          shouldRegenerateModel = true;
          delete newModelLookup[parentId];
        }
        parentId = itemsSelectors.itemParentId(store.state, parentId);
      }
    }
    if (selectionPropagation.descendants) {
      const deSelectDescendants = (itemId) => {
        if (itemId !== removedItemId) {
          shouldRegenerateModel = true;
          delete newModelLookup[itemId];
        }
        itemsSelectors.itemOrderedChildrenIds(store.state, itemId).forEach(deSelectDescendants);
      };
      deSelectDescendants(removedItemId);
    }
  });
  return shouldRegenerateModel ? Object.keys(newModelLookup) : newModel;
}
function getAddedAndRemovedItems({
  store,
  oldModel,
  newModel
}) {
  const newModelMap = /* @__PURE__ */ new Map();
  newModel.forEach((id) => {
    newModelMap.set(id, true);
  });
  return {
    added: newModel.filter((itemId) => !selectionSelectors.isItemSelected(store.state, itemId)),
    removed: oldModel.filter((itemId) => !newModelMap.has(itemId))
  };
}
function getLookupFromArray(array2) {
  const lookup = {};
  array2.forEach((itemId) => {
    lookup[itemId] = true;
  });
  return lookup;
}
function useTreeViewRootProps(store, forwardedProps, ref) {
  const treeId = useStore(store, idSelectors.treeId);
  const itemChildrenIndentation = useStore(store, itemsSelectors.itemChildrenIndentation);
  const isMultiSelectEnabled = useStore(store, selectionSelectors.isMultiSelectEnabled);
  return (otherHandlers) => _extends({
    ref,
    role: "tree",
    id: treeId,
    "aria-multiselectable": isMultiSelectEnabled
  }, forwardedProps, otherHandlers, {
    style: _extends({}, forwardedProps.style, {
      "--TreeView-itemChildrenIndentation": typeof itemChildrenIndentation === "number" ? `${itemChildrenIndentation}px` : itemChildrenIndentation
    }),
    onFocus: (event) => {
      otherHandlers.onFocus?.(event);
      store.focus.handleRootFocus(event);
    },
    onBlur: (event) => {
      otherHandlers.onBlur?.(event);
      store.focus.handleRootBlur(event);
    }
  });
}
function escapeOperandAttributeSelector(operand) {
  return operand.replace(/["\\]/g, "\\$&");
}
const TreeViewChildrenItemContext = /* @__PURE__ */ reactExports.createContext(null);
function TreeViewChildrenItemProvider(props) {
  const {
    children,
    itemId = null,
    idAttribute
  } = props;
  const {
    store,
    rootRef
  } = useTreeViewContext();
  const childrenIdAttrToIdRef = reactExports.useRef(/* @__PURE__ */ new Map());
  reactExports.useEffect(() => {
    if (!rootRef.current) {
      return;
    }
    const previousChildrenIds = itemsSelectors.itemOrderedChildrenIds(store.state, itemId ?? null) ?? [];
    const escapedIdAttr = escapeOperandAttributeSelector(idAttribute ?? rootRef.current.id);
    if (itemId != null) {
      const itemRoot = rootRef.current.querySelector(`*[id="${escapedIdAttr}"][role="treeitem"]`);
      if (itemRoot && itemRoot.getAttribute("aria-expanded") === "false") {
        return;
      }
    }
    const childrenElements = rootRef.current.querySelectorAll(`${itemId == null ? "" : `*[id="${escapedIdAttr}"] `}[role="treeitem"]:not(*[id="${escapedIdAttr}"] [role="treeitem"] [role="treeitem"])`);
    const childrenIds = Array.from(childrenElements).map((child) => childrenIdAttrToIdRef.current.get(child.id));
    const hasChanged = childrenIds.length !== previousChildrenIds.length || childrenIds.some((childId, index) => childId !== previousChildrenIds[index]);
    if (hasChanged) {
      store.jsxItems.setJSXItemsOrderedChildrenIds(itemId ?? null, childrenIds);
    }
  });
  const value = reactExports.useMemo(() => ({
    registerChild: (childIdAttribute, childItemId) => childrenIdAttrToIdRef.current.set(childIdAttribute, childItemId),
    unregisterChild: (childIdAttribute) => childrenIdAttrToIdRef.current.delete(childIdAttribute),
    parentId: itemId
  }), [itemId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewChildrenItemContext.Provider, {
    value,
    children
  });
}
const TreeViewItemDepthContext = /* @__PURE__ */ reactExports.createContext(() => -1);
function useTreeViewStore(StoreClass, parameters) {
  const isRtl = useRtl();
  const store = useRefWithInit(() => new StoreClass(_extends({}, parameters, {
    isRtl
  }))).current;
  useIsoLayoutEffect(() => store.updateStateFromParameters(_extends({}, parameters, {
    isRtl
  })), [store, isRtl, parameters]);
  useOnMount(store.disposeEffect);
  return store;
}
class EventManager {
  maxListeners = 20;
  warnOnce = false;
  events = {};
  on(eventName, listener, options = {}) {
    let collection = this.events[eventName];
    if (!collection) {
      collection = {
        highPriority: /* @__PURE__ */ new Map(),
        regular: /* @__PURE__ */ new Map()
      };
      this.events[eventName] = collection;
    }
    if (options.isFirst) {
      collection.highPriority.set(listener, true);
    } else {
      collection.regular.set(listener, true);
    }
  }
  removeListener(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName].regular.delete(listener);
      this.events[eventName].highPriority.delete(listener);
    }
  }
  removeAllListeners() {
    this.events = {};
  }
  emit(eventName, ...args) {
    const collection = this.events[eventName];
    if (!collection) {
      return;
    }
    const highPriorityListeners = Array.from(collection.highPriority.keys());
    const regularListeners = Array.from(collection.regular.keys());
    for (let i = highPriorityListeners.length - 1; i >= 0; i -= 1) {
      const listener = highPriorityListeners[i];
      if (collection.highPriority.has(listener)) {
        listener.apply(this, args);
      }
    }
    for (let i = 0; i < regularListeners.length; i += 1) {
      const listener = regularListeners[i];
      if (collection.regular.has(listener)) {
        listener.apply(this, args);
      }
    }
  }
  once(eventName, listener) {
    const that = this;
    this.on(eventName, function oneTimeListener(...args) {
      that.removeListener(eventName, oneTimeListener);
      listener.apply(that, args);
    });
  }
}
const getExpansionTrigger = ({
  isItemEditable,
  expansionTrigger
}) => {
  if (expansionTrigger) {
    return expansionTrigger;
  }
  if (isItemEditable) {
    return "iconContainer";
  }
  return "content";
};
function deriveStateFromParameters(parameters) {
  return {
    disabledItemsFocusable: parameters.disabledItemsFocusable ?? false,
    domStructure: "nested",
    itemChildrenIndentation: parameters.itemChildrenIndentation ?? "12px",
    providedTreeId: parameters.id,
    // TODO: Fix
    expansionTrigger: getExpansionTrigger({
      isItemEditable: parameters.isItemEditable,
      expansionTrigger: parameters.expansionTrigger
    }),
    disableSelection: parameters.disableSelection ?? false,
    multiSelect: parameters.multiSelect ?? false,
    checkboxSelection: parameters.checkboxSelection ?? false,
    selectionPropagation: parameters.selectionPropagation ?? EMPTY_OBJECT
  };
}
function applyModelInitialValue(controlledValue, defaultValue, fallback) {
  if (controlledValue !== void 0) {
    return controlledValue;
  }
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  return fallback;
}
function createMinimalInitialState(parameters) {
  return _extends({
    treeId: void 0,
    focusedItemId: null
  }, deriveStateFromParameters(parameters), TreeViewItemsPlugin.buildItemsStateIfNeeded(parameters), {
    expandedItems: applyModelInitialValue(parameters.expandedItems, parameters.defaultExpandedItems, []),
    selectedItems: applyModelInitialValue(parameters.selectedItems, parameters.defaultSelectedItems, parameters.multiSelect ? EMPTY_ARRAY : null)
  });
}
let globalTreeViewDefaultId = 0;
const createTreeViewDefaultId = () => {
  globalTreeViewDefaultId += 1;
  return `mui-tree-view-${globalTreeViewDefaultId}`;
};
class TimeoutManager {
  timeoutIds = /* @__PURE__ */ (() => /* @__PURE__ */ new Map())();
  intervalIds = /* @__PURE__ */ (() => /* @__PURE__ */ new Map())();
  startTimeout = (key, delay, fn) => {
    this.clearTimeout(key);
    const id = setTimeout(() => {
      this.timeoutIds.delete(key);
      fn();
    }, delay);
    this.timeoutIds.set(key, id);
  };
  startInterval = (key, delay, fn) => {
    this.clearTimeout(key);
    const id = setInterval(fn, delay);
    this.intervalIds.set(key, id);
  };
  clearTimeout = (key) => {
    const id = this.timeoutIds.get(key);
    if (id != null) {
      clearTimeout(id);
      this.timeoutIds.delete(key);
    }
  };
  clearInterval = (key) => {
    const id = this.intervalIds.get(key);
    if (id != null) {
      clearInterval(id);
      this.intervalIds.delete(key);
    }
  };
  clearAll = () => {
    this.timeoutIds.forEach(clearTimeout);
    this.timeoutIds.clear();
    this.intervalIds.forEach(clearInterval);
    this.intervalIds.clear();
  };
}
class TreeViewExpansionPlugin {
  // We can't type `store`, otherwise we get the following TS error:
  // 'expansion' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
  constructor(store) {
    this.store = store;
  }
  setExpandedItems = (event, value) => {
    if (this.store.parameters.expandedItems === void 0) {
      this.store.set("expandedItems", value);
    }
    this.store.parameters.onExpandedItemsChange?.(event, value);
  };
  /**
   * Check if an item is expanded.
   * @param {TreeViewItemId} itemId The id of the item to check.
   * @returns {boolean} `true` if the item is expanded, `false` otherwise.
   */
  isItemExpanded = (itemId) => expansionSelectors.isItemExpanded(this.store.state, itemId);
  buildPublicAPI = () => {
    return {
      isItemExpanded: this.isItemExpanded,
      setItemExpansion: this.setItemExpansion
    };
  };
  /**
   * Change the expansion status of a given item.
   * @param {object} parameters The parameters of the method.
   * @param {TreeViewItemId} parameters.itemId The id of the item to expand of collapse.
   * @param {React.SyntheticEvent} parameters.event The DOM event that triggered the change.
   * @param {boolean} parameters.shouldBeExpanded If `true` the item will be expanded. If `false` the item will be collapsed. If not defined, the item's expansion status will be the toggled.
   */
  setItemExpansion = ({
    itemId,
    event = null,
    shouldBeExpanded
  }) => {
    const isExpandedBefore = expansionSelectors.isItemExpanded(this.store.state, itemId);
    const cleanShouldBeExpanded = shouldBeExpanded ?? !isExpandedBefore;
    if (isExpandedBefore === cleanShouldBeExpanded) {
      return;
    }
    const eventParameters = {
      isExpansionPrevented: false,
      shouldBeExpanded: cleanShouldBeExpanded,
      itemId
    };
    this.store.publishEvent("beforeItemToggleExpansion", eventParameters, event);
    if (eventParameters.isExpansionPrevented) {
      return;
    }
    this.applyItemExpansion({
      itemId,
      event,
      shouldBeExpanded: cleanShouldBeExpanded
    });
  };
  /**
   * Apply the new expansion status of a given item.
   * Is used by the `setItemExpansion` method and by the `useTreeViewLazyLoading` plugin.
   * Unlike `setItemExpansion`, this method does not trigger the lazy loading.
   * @param {object} parameters The parameters of the method.
   * @param {TreeViewItemId} parameters.itemId The id of the item to expand of collapse.
   * @param {React.SyntheticEvent | null} parameters.event The DOM event that triggered the change.
   * @param {boolean} parameters.shouldBeExpanded If `true` the item will be expanded. If `false` the item will be collapsed.
   */
  applyItemExpansion = ({
    itemId,
    event,
    shouldBeExpanded
  }) => {
    const oldExpanded = expansionSelectors.expandedItemsRaw(this.store.state);
    let newExpanded;
    if (shouldBeExpanded) {
      newExpanded = [itemId].concat(oldExpanded);
    } else {
      newExpanded = oldExpanded.filter((id) => id !== itemId);
    }
    this.store.parameters.onItemExpansionToggle?.(event, itemId, shouldBeExpanded);
    this.setExpandedItems(event, newExpanded);
  };
  /**
   * Expand all the siblings (i.e.: the items that have the same parent) of a given item.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the item whose siblings will be expanded.
   */
  expandAllSiblings = (event, itemId) => {
    const itemMeta = itemsSelectors.itemMeta(this.store.state, itemId);
    if (itemMeta == null) {
      return;
    }
    const siblings = itemsSelectors.itemOrderedChildrenIds(this.store.state, itemMeta.parentId);
    const diff = siblings.filter((child) => expansionSelectors.isItemExpandable(this.store.state, child) && !expansionSelectors.isItemExpanded(this.store.state, child));
    const newExpanded = expansionSelectors.expandedItemsRaw(this.store.state).concat(diff);
    if (diff.length > 0) {
      if (this.store.parameters.onItemExpansionToggle) {
        diff.forEach((newlyExpandedItemId) => {
          this.store.parameters.onItemExpansionToggle(event, newlyExpandedItemId, true);
        });
      }
      this.setExpandedItems(event, newExpanded);
    }
  };
  /**
   * Mark a list of items as expandable.
   * @param {TreeViewItemId[]} items The ids of the items to mark as expandable.
   */
  addExpandableItems = (items) => {
    const newItemMetaLookup = _extends({}, this.store.state.itemMetaLookup);
    for (const itemId of items) {
      newItemMetaLookup[itemId] = _extends({}, newItemMetaLookup[itemId], {
        expandable: true
      });
    }
    this.store.set("itemMetaLookup", newItemMetaLookup);
  };
}
const labelSelectors = {
  /**
   * Checks whether an item is editable.
   */
  isItemEditable: createSelector((state) => state.isItemEditable, itemsSelectors.itemModel, (isItemEditable, itemModel, _itemId) => {
    if (!itemModel || isItemEditable == null) {
      return false;
    }
    if (typeof isItemEditable === "boolean") {
      return isItemEditable;
    }
    return isItemEditable(itemModel);
  }),
  /**
   * Checks whether an item is being edited.
   */
  isItemBeingEdited: createSelector((state, itemId) => itemId == null ? false : state.editedItemId === itemId),
  /**
   * Checks whether any item is being edited.
   */
  isAnyItemBeingEdited: createSelector((state) => !!state.editedItemId)
};
const TYPEAHEAD_TIMEOUT = 500;
class TreeViewKeyboardNavigationPlugin {
  typeaheadQuery = "";
  // We can't type `store`, otherwise we get the following TS error:
  // 'keyboardNavigation' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
  constructor(store) {
    this.store = store;
    this.labelMap = createLabelMapFromItemMetaLookup(itemsSelectors.itemMetaLookup(this.store.state));
    this.store.registerStoreEffect(itemsSelectors.itemMetaLookup, (_, itemMetaLookup) => {
      if (this.store.shouldIgnoreItemsStateUpdate()) {
        return;
      }
      this.labelMap = createLabelMapFromItemMetaLookup(itemMetaLookup);
    });
  }
  canToggleItemSelection = (itemId) => selectionSelectors.canItemBeSelected(this.store.state, itemId);
  canToggleItemExpansion = (itemId) => {
    return !itemsSelectors.isItemDisabled(this.store.state, itemId) && expansionSelectors.isItemExpandable(this.store.state, itemId);
  };
  getFirstItemMatchingTypeaheadQuery = (itemId, newKey) => {
    const getNextItem = (itemIdToCheck) => {
      const nextItemId = getNextNavigableItem(this.store.state, itemIdToCheck);
      if (nextItemId === null) {
        return getFirstNavigableItem(this.store.state);
      }
      return nextItemId;
    };
    const getNextMatchingItemId = (query) => {
      let matchingItemId = null;
      const checkedItems = {};
      let currentItemId = query.length > 1 ? itemId : getNextItem(itemId);
      while (matchingItemId == null && !checkedItems[currentItemId]) {
        const itemLabel = this.labelMap[currentItemId];
        if (itemLabel?.startsWith(query)) {
          matchingItemId = currentItemId;
        } else {
          checkedItems[currentItemId] = true;
          currentItemId = getNextItem(currentItemId);
        }
      }
      return matchingItemId;
    };
    const cleanNewKey = newKey.toLowerCase();
    const concatenatedQuery = `${this.typeaheadQuery}${cleanNewKey}`;
    const concatenatedQueryMatchingItemId = getNextMatchingItemId(concatenatedQuery);
    if (concatenatedQueryMatchingItemId != null) {
      this.typeaheadQuery = concatenatedQuery;
      return concatenatedQueryMatchingItemId;
    }
    const newKeyMatchingItemId = getNextMatchingItemId(cleanNewKey);
    if (newKeyMatchingItemId != null) {
      this.typeaheadQuery = cleanNewKey;
      return newKeyMatchingItemId;
    }
    this.typeaheadQuery = "";
    return null;
  };
  /**
   * Updates the `labelMap` to add/remove the first character of some item's labels.
   * This map is used to navigate the tree using type-ahead search.
   * This method is only used by the `useTreeViewJSXItems` plugin, otherwise the updates are handled internally.
   * @param {(map: TreeViewLabelMap) => TreeViewLabelMap} updater The function to update the map.
   */
  updateLabelMap = (callback) => {
    this.labelMap = callback(this.labelMap);
  };
  // ARIA specification: https://www.w3.org/WAI/ARIA/apg/patterns/treeview/#keyboardinteraction
  /**
   * Callback fired when a key is pressed on an item.
   * Handles all the keyboard navigation logic.
   * @param {React.KeyboardEvent<HTMLElement> & TreeViewCancellableEvent} event The keyboard event that triggered the callback.
   * @param {TreeViewItemId} itemId The id of the item that the event was triggered on.
   */
  handleItemKeyDown = async (event, itemId) => {
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.altKey || isTargetInDescendants(event.target, event.currentTarget)) {
      return;
    }
    const ctrlPressed = event.ctrlKey || event.metaKey;
    const key = event.key;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(this.store.state);
    switch (true) {
      // Select the item when pressing "Space"
      case (key === " " && this.canToggleItemSelection(itemId)): {
        event.preventDefault();
        if (isMultiSelectEnabled && event.shiftKey) {
          this.store.selection.expandSelectionRange(event, itemId);
        } else {
          this.store.selection.setItemSelection({
            event,
            itemId,
            keepExistingSelection: isMultiSelectEnabled,
            shouldBeSelected: void 0
          });
        }
        break;
      }
      // If the focused item has children, we expand it.
      // If the focused item has no children, we select it.
      case key === "Enter": {
        if (this.store.labelEditing?.setEditedItem && labelSelectors.isItemEditable(this.store.state, itemId) && !labelSelectors.isItemBeingEdited(this.store.state, itemId)) {
          this.store.labelEditing.setEditedItem(itemId);
        } else if (this.canToggleItemExpansion(itemId)) {
          this.store.expansion.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        } else if (this.canToggleItemSelection(itemId)) {
          if (isMultiSelectEnabled) {
            event.preventDefault();
            this.store.selection.setItemSelection({
              event,
              itemId,
              keepExistingSelection: true
            });
          } else if (!selectionSelectors.isItemSelected(this.store.state, itemId)) {
            this.store.selection.setItemSelection({
              event,
              itemId
            });
            event.preventDefault();
          }
        }
        break;
      }
      // Focus the next focusable item
      case key === "ArrowDown": {
        const nextItem = getNextNavigableItem(this.store.state, itemId);
        if (nextItem) {
          event.preventDefault();
          this.store.focus.focusItem(event, nextItem);
          if (isMultiSelectEnabled && event.shiftKey && this.canToggleItemSelection(nextItem)) {
            this.store.selection.selectItemFromArrowNavigation(event, itemId, nextItem);
          }
        }
        break;
      }
      // Focuses the previous focusable item
      case key === "ArrowUp": {
        const previousItem = getPreviousNavigableItem(this.store.state, itemId);
        if (previousItem) {
          event.preventDefault();
          this.store.focus.focusItem(event, previousItem);
          if (isMultiSelectEnabled && event.shiftKey && this.canToggleItemSelection(previousItem)) {
            this.store.selection.selectItemFromArrowNavigation(event, itemId, previousItem);
          }
        }
        break;
      }
      // If the focused item is expanded, we move the focus to its first child
      // If the focused item is collapsed and has children, we expand it
      case (key === "ArrowRight" && !this.store.parameters.isRtl || key === "ArrowLeft" && this.store.parameters.isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (expansionSelectors.isItemExpanded(this.store.state, itemId)) {
          const nextItemId = getNextNavigableItem(this.store.state, itemId);
          if (nextItemId) {
            this.store.focus.focusItem(event, nextItemId);
            event.preventDefault();
          }
        } else if (this.canToggleItemExpansion(itemId)) {
          this.store.expansion.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        }
        break;
      }
      // If the focused item is expanded, we collapse it
      // If the focused item is collapsed and has a parent, we move the focus to this parent
      case (key === "ArrowLeft" && !this.store.parameters.isRtl || key === "ArrowRight" && this.store.parameters.isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (this.canToggleItemExpansion(itemId) && expansionSelectors.isItemExpanded(this.store.state, itemId)) {
          this.store.expansion.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        } else {
          const parent = itemsSelectors.itemParentId(this.store.state, itemId);
          if (parent) {
            this.store.focus.focusItem(event, parent);
            event.preventDefault();
          }
        }
        break;
      }
      // Focuses the first item in the tree
      case key === "Home": {
        if (this.canToggleItemSelection(itemId) && isMultiSelectEnabled && ctrlPressed && event.shiftKey) {
          this.store.selection.selectRangeFromStartToItem(event, itemId);
        } else {
          this.store.focus.focusItem(event, getFirstNavigableItem(this.store.state));
        }
        event.preventDefault();
        break;
      }
      // Focuses the last item in the tree
      case key === "End": {
        if (this.canToggleItemSelection(itemId) && isMultiSelectEnabled && ctrlPressed && event.shiftKey) {
          this.store.selection.selectRangeFromItemToEnd(event, itemId);
        } else {
          this.store.focus.focusItem(event, getLastNavigableItem(this.store.state));
        }
        event.preventDefault();
        break;
      }
      // Expand all siblings that are at the same level as the focused item
      case key === "*": {
        this.store.expansion.expandAllSiblings(event, itemId);
        event.preventDefault();
        break;
      }
      // Multi select behavior when pressing Ctrl + a
      // Selects all the items
      case (String.fromCharCode(event.keyCode) === "A" && ctrlPressed && isMultiSelectEnabled && selectionSelectors.enabled(this.store.state)): {
        this.store.selection.selectAllNavigableItems(event);
        event.preventDefault();
        break;
      }
      // Type-ahead
      case (!ctrlPressed && !event.shiftKey && isPrintableKey(key)): {
        this.store.timeoutManager.clearTimeout("typeahead");
        const matchingItem = this.getFirstItemMatchingTypeaheadQuery(itemId, key);
        if (matchingItem != null) {
          this.store.focus.focusItem(event, matchingItem);
          event.preventDefault();
        } else {
          this.typeaheadQuery = "";
        }
        this.store.timeoutManager.startTimeout("typeahead", TYPEAHEAD_TIMEOUT, () => {
          this.typeaheadQuery = "";
        });
        break;
      }
    }
  };
}
function isPrintableKey(string2) {
  return !!string2 && string2.length === 1 && !!string2.match(/\S/);
}
function createLabelMapFromItemMetaLookup(itemMetaLookup) {
  const labelMap = {};
  const processItem = (item) => {
    labelMap[item.id] = item.label.toLowerCase();
  };
  Object.values(itemMetaLookup).forEach(processItem);
  return labelMap;
}
const defaultFocusableItemIdSelector = createSelectorMemoized(selectionSelectors.selectedItems, expansionSelectors.expandedItemsMap, itemsSelectors.itemMetaLookup, itemsSelectors.disabledItemFocusable, (state) => itemsSelectors.itemOrderedChildrenIds(state, null), (selectedItems, expandedItemsMap, itemMetaLookup, disabledItemsFocusable, orderedRootItemIds) => {
  const firstSelectedItem = selectedItems.find((itemId) => {
    if (!disabledItemsFocusable && isItemDisabled(itemMetaLookup, itemId)) {
      return false;
    }
    const itemMeta = itemMetaLookup[itemId];
    return itemMeta && (itemMeta.parentId == null || expandedItemsMap.has(itemMeta.parentId));
  });
  if (firstSelectedItem != null) {
    return firstSelectedItem;
  }
  const firstNavigableItem = orderedRootItemIds.find((itemId) => disabledItemsFocusable || !isItemDisabled(itemMetaLookup, itemId));
  if (firstNavigableItem != null) {
    return firstNavigableItem;
  }
  return null;
});
const focusSelectors = {
  /**
   * Gets the item that should be sequentially focusable (usually with the Tab key).
   * At any point in time, there is a single item that can be sequentially focused in the Tree View.
   * This item is the first selected item (that is both visible and navigable), if any, or the first navigable item if no item is selected.
   */
  defaultFocusableItemId: defaultFocusableItemIdSelector,
  /**
   * Checks whether an item is the default focusable item.
   */
  isItemTheDefaultFocusableItem: createSelector(defaultFocusableItemIdSelector, (defaultFocusableItemId, itemId) => defaultFocusableItemId === itemId),
  /**
   * Gets the id of the item that is currently focused.
   */
  focusedItemId: createSelector((state) => state.focusedItemId),
  /**
   * Checks whether an item is focused.
   */
  isItemFocused: createSelector((state, itemId) => state.focusedItemId === itemId)
};
class TreeViewFocusPlugin {
  // We can't type `store`, otherwise we get the following TS error:
  // 'focus' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
  constructor(store) {
    this.store = store;
    this.store.registerStoreEffect(itemsSelectors.itemMetaLookup, () => {
      const focusedItemId = focusSelectors.focusedItemId(store.state);
      if (focusedItemId == null) {
        return;
      }
      const hasItemBeenRemoved = !itemsSelectors.itemMeta(store.state, focusedItemId);
      if (!hasItemBeenRemoved) {
        return;
      }
      const defaultFocusableItemId = focusSelectors.defaultFocusableItemId(store.state);
      if (defaultFocusableItemId == null) {
        this.setFocusedItemId(null);
        return;
      }
      this.applyItemFocus(null, defaultFocusableItemId);
    });
  }
  setFocusedItemId = (itemId) => {
    const focusedItemId = focusSelectors.focusedItemId(this.store.state);
    if (focusedItemId === itemId) {
      return;
    }
    this.store.set("focusedItemId", itemId);
  };
  applyItemFocus = (event, itemId) => {
    this.store.items.getItemDOMElement(itemId)?.focus();
    this.setFocusedItemId(itemId);
    this.store.parameters.onItemFocus?.(event, itemId);
  };
  buildPublicAPI = () => {
    return {
      focusItem: this.focusItem
    };
  };
  /**
   * Focus the item with the given id.
   *
   * If the item is the child of a collapsed item, then this method will do nothing.
   * Make sure to expand the ancestors of the item before calling this method if needed.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change.
   * @param {TreeViewItemId} itemId The id of the item to focus.
   */
  focusItem = (event, itemId) => {
    const itemMeta = itemsSelectors.itemMeta(this.store.state, itemId);
    const isItemVisible = itemMeta && (itemMeta.parentId == null || expansionSelectors.isItemExpanded(this.store.state, itemMeta.parentId));
    if (isItemVisible) {
      this.applyItemFocus(event, itemId);
    }
  };
  /**
   * Remove the focus from the currently focused item (both from the internal state and the DOM).
   */
  removeFocusedItem = () => {
    const focusedItemId = focusSelectors.focusedItemId(this.store.state);
    if (focusedItemId == null) {
      return;
    }
    const itemMeta = itemsSelectors.itemMeta(this.store.state, focusedItemId);
    if (itemMeta) {
      const itemElement = this.store.items.getItemDOMElement(focusedItemId);
      if (itemElement) {
        itemElement.blur();
      }
    }
    this.setFocusedItemId(null);
  };
  /**
   * Event handler to fire when the `root` slot of the Tree View is focused.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   */
  handleRootFocus = (event) => {
    if (event.defaultMuiPrevented) {
      return;
    }
    const defaultFocusableItemId = focusSelectors.defaultFocusableItemId(this.store.state);
    if (event.target === event.currentTarget && defaultFocusableItemId != null) {
      this.applyItemFocus(event, defaultFocusableItemId);
    }
  };
  /**
   * Event handler to fire when the `root` slot of the Tree View is blurred.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   */
  handleRootBlur = (event) => {
    if (event.defaultMuiPrevented) {
      return;
    }
    this.setFocusedItemId(null);
  };
}
class TreeViewItemPluginManager {
  itemPlugins = [];
  itemWrappers = [];
  register = (plugin, wrapItem) => {
    this.itemPlugins.push(plugin);
    if (wrapItem) {
      this.itemWrappers.push(wrapItem);
    }
  };
  listPlugins = () => this.itemPlugins;
  listWrappers = () => this.itemWrappers;
}
class MinimalTreeViewStore extends Store {
  initialParameters = null;
  eventManager = (() => new EventManager())();
  timeoutManager = (() => new TimeoutManager())();
  itemPluginManager = (() => new TreeViewItemPluginManager())();
  constructor(parameters, instanceName, mapper) {
    const minimalInitialState = createMinimalInitialState(parameters);
    const initialState = mapper.getInitialState(minimalInitialState, parameters);
    super(initialState);
    this.parameters = parameters;
    this.instanceName = instanceName;
    this.mapper = mapper;
    this.items = new TreeViewItemsPlugin(this);
    this.focus = new TreeViewFocusPlugin(this);
    this.expansion = new TreeViewExpansionPlugin(this);
    this.selection = new TreeViewSelectionPlugin(this);
    this.keyboardNavigation = new TreeViewKeyboardNavigationPlugin(this);
  }
  /**
   * Builds an object containing the method that should be exposed publicly by the Tree View components.
   */
  buildPublicAPI() {
    return _extends({}, this.items.buildPublicAPI(), this.focus.buildPublicAPI(), this.expansion.buildPublicAPI(), this.selection.buildPublicAPI());
  }
  /**
   * Updates the state of the Tree View based on the new parameters provided to the root component.
   */
  updateStateFromParameters(parameters) {
    const updateModel = (mutableNewState, controlledProp, defaultProp) => {
      if (parameters[controlledProp] !== void 0) {
        mutableNewState[controlledProp] = parameters[controlledProp];
      }
    };
    const newMinimalState = deriveStateFromParameters(parameters);
    updateModel(newMinimalState, "expandedItems");
    updateModel(newMinimalState, "selectedItems");
    if (this.state.providedTreeId !== parameters.id || this.state.treeId === void 0) {
      newMinimalState.treeId = createTreeViewDefaultId();
    }
    if (!this.mapper.shouldIgnoreItemsStateUpdate(parameters) && TreeViewItemsPlugin.shouldRebuildItemsState(parameters, this.parameters)) {
      Object.assign(newMinimalState, TreeViewItemsPlugin.buildItemsStateIfNeeded(parameters));
    }
    const newState = this.mapper.updateStateFromParameters(newMinimalState, parameters, updateModel);
    this.update(newState);
    this.parameters = parameters;
  }
  /**
   * Returns a cleanup function that need to be called when the store is destroyed.
   */
  disposeEffect = () => {
    return this.timeoutManager.clearAll;
  };
  /**
   * Whether updates based on `props.items` change should be ignored.
   */
  shouldIgnoreItemsStateUpdate = () => {
    return this.mapper.shouldIgnoreItemsStateUpdate(this.parameters);
  };
  /**
   * Registers an effect to be run when the value returned by the selector changes.
   */
  registerStoreEffect = (selector, effect) => {
    let previousValue = selector(this.state);
    this.subscribe((state) => {
      const nextValue = selector(state);
      if (nextValue !== previousValue) {
        effect(previousValue, nextValue);
        previousValue = nextValue;
      }
    });
  };
  /**
   * Publishes an event to all its subscribers.
   */
  publishEvent = (name, params, event) => {
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    this.eventManager.emit(name, params, event);
  };
  /**
   * Subscribe to an event emitted by the store.
   * For now, the subscription is only removed when the store is destroyed.
   */
  subscribeEvent = (eventName, handler) => {
    this.eventManager.on(eventName, handler);
  };
}
function isSyntheticEvent(event) {
  return event.isPropagationStopped !== void 0;
}
const lazyLoadingSelectors = {
  /**
   * Checks if the lazy loaded state is empty.
   */
  isEmpty: createSelector((state) => {
    if (state.lazyLoadedItems == null) {
      return true;
    }
    return Object.keys(state.lazyLoadedItems.loading).length === 0 && Object.keys(state.lazyLoadedItems.errors).length === 0;
  }),
  /**
   * Checks whether an item is loading.
   */
  isItemLoading: createSelector((state, itemId) => state.lazyLoadedItems?.loading[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? false),
  /**
   * Checks whether an item has errors.
   */
  itemHasError: createSelector((state, itemId) => !!state.lazyLoadedItems?.errors[itemId ?? TREE_VIEW_ROOT_PARENT_ID]),
  /**
   * Get an item error.
   */
  itemError: createSelector((state, itemId) => state.lazyLoadedItems?.errors[itemId ?? TREE_VIEW_ROOT_PARENT_ID])
};
const itemHasChildren = (reactChildren) => {
  if (Array.isArray(reactChildren)) {
    return reactChildren.length > 0 && reactChildren.some(itemHasChildren);
  }
  return Boolean(reactChildren);
};
const useTreeItemUtils = ({
  itemId,
  children
}) => {
  const {
    store,
    publicAPI
  } = useTreeViewContext();
  const isItemExpandable = useStore(store, expansionSelectors.isItemExpandable, itemId);
  const isLoading = useStore(store, lazyLoadingSelectors.isItemLoading, itemId);
  const hasError = useStore(store, lazyLoadingSelectors.itemHasError, itemId);
  const isExpandable = itemHasChildren(children) || isItemExpandable;
  const isExpanded = useStore(store, expansionSelectors.isItemExpanded, itemId);
  const isFocused = useStore(store, focusSelectors.isItemFocused, itemId);
  const isSelected = useStore(store, selectionSelectors.isItemSelected, itemId);
  const isDisabled = useStore(store, itemsSelectors.isItemDisabled, itemId);
  const isEditing = useStore(store, labelSelectors.isItemBeingEdited, itemId);
  const isEditable = useStore(store, labelSelectors.isItemEditable, itemId);
  const status = {
    expandable: isExpandable,
    expanded: isExpanded,
    focused: isFocused,
    selected: isSelected,
    disabled: isDisabled,
    editing: isEditing,
    editable: isEditable,
    loading: isLoading,
    error: hasError
  };
  const handleExpansion = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused) {
      store.focus.focusItem(event, itemId);
    }
    const multiple = selectionSelectors.isMultiSelectEnabled(store.state) && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (status.expandable && !(multiple && expansionSelectors.isItemExpanded(store.state, itemId))) {
      store.expansion.setItemExpansion({
        event,
        itemId
      });
    }
  };
  const handleSelection = (event) => {
    if (!selectionSelectors.canItemBeSelected(store.state, itemId)) {
      return;
    }
    if (!status.focused && !status.editing) {
      store.focus.focusItem(event, itemId);
    }
    const multiple = selectionSelectors.isMultiSelectEnabled(store.state) && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (multiple) {
      if (event.shiftKey) {
        store.selection.expandSelectionRange(event, itemId);
      } else {
        store.selection.setItemSelection({
          event,
          itemId,
          keepExistingSelection: true
        });
      }
    } else {
      store.selection.setItemSelection({
        event,
        itemId,
        shouldBeSelected: true
      });
    }
  };
  const handleCheckboxSelection = (event) => {
    const hasShift = event.nativeEvent.shiftKey;
    const isMultiSelectEnabled = selectionSelectors.isMultiSelectEnabled(store.state);
    if (isMultiSelectEnabled && hasShift) {
      store.selection.expandSelectionRange(event, itemId);
    } else {
      store.selection.setItemSelection({
        event,
        itemId,
        keepExistingSelection: isMultiSelectEnabled,
        shouldBeSelected: event.target.checked
      });
    }
  };
  const toggleItemEditing = () => {
    if (!store.labelEditing) {
      return;
    }
    if (isEditing) {
      store.labelEditing.setEditedItem(null);
    } else {
      store.labelEditing.setEditedItem(itemId);
    }
  };
  const handleSaveItemLabel = (event, newLabel) => {
    if (!store.labelEditing) {
      return;
    }
    if (labelSelectors.isItemBeingEdited(store.state, itemId)) {
      store.labelEditing.updateItemLabel(itemId, newLabel);
      toggleItemEditing();
      store.focus.focusItem(event, itemId);
    }
  };
  const handleCancelItemLabelEditing = (event) => {
    if (!store.labelEditing) {
      return;
    }
    if (labelSelectors.isItemBeingEdited(store.state, itemId)) {
      toggleItemEditing();
      store.focus.focusItem(event, itemId);
    }
  };
  const interactions = {
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    toggleItemEditing,
    handleSaveItemLabel,
    handleCancelItemLabelEditing
  };
  return {
    interactions,
    status,
    publicAPI
  };
};
const useJSXItemsItemPlugin = ({
  props,
  rootRef,
  contentRef
}) => {
  const {
    store
  } = useTreeViewContext();
  const {
    children,
    disabled = false,
    disableSelection = false,
    label,
    itemId,
    id
  } = props;
  const parentContext = reactExports.useContext(TreeViewChildrenItemContext);
  if (parentContext == null) {
    throw new Error(["MUI X: Could not find the Tree View Children Item context.", "It looks like you rendered your component outside of a SimpleTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  const {
    registerChild,
    unregisterChild,
    parentId
  } = parentContext;
  const expandable = itemHasChildren(children);
  const pluginContentRef = reactExports.useRef(null);
  const handleContentRef = useMergedRefs(pluginContentRef, contentRef);
  const idAttribute = useStore(store, idSelectors.treeItemIdAttribute, itemId, id);
  useIsoLayoutEffect(() => {
    registerChild(idAttribute, itemId);
    return () => {
      unregisterChild(idAttribute);
      unregisterChild(idAttribute);
    };
  }, [store, registerChild, unregisterChild, idAttribute, itemId]);
  useIsoLayoutEffect(() => {
    return store.jsxItems.insertJSXItem({
      id: itemId,
      idAttribute: id,
      parentId,
      expandable,
      disabled,
      selectable: !disableSelection
    });
  }, [store, parentId, itemId, expandable, disabled, disableSelection, id]);
  reactExports.useEffect(() => {
    if (label) {
      return store.jsxItems.mapLabelFromJSX(itemId, (pluginContentRef.current?.textContent ?? "").toLowerCase());
    }
    return void 0;
  }, [store, itemId, label]);
  return {
    contentRef: handleContentRef,
    rootRef
  };
};
const jsxItemsitemWrapper = ({
  children,
  itemId,
  idAttribute
}) => {
  const depthContext = reactExports.useContext(TreeViewItemDepthContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewChildrenItemProvider, {
    itemId,
    idAttribute,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewItemDepthContext.Provider, {
      value: depthContext + 1,
      children
    })
  });
};
class TreeViewJSXItemsPlugin {
  constructor(store) {
    this.store = store;
    store.itemPluginManager.register(useJSXItemsItemPlugin, jsxItemsitemWrapper);
  }
  /**
   * Insert a new item in the state from a Tree Item component.
   * @param {TreeViewItemMeta} item The meta-information of the item to insert.
   * @returns {() => void} A function to remove the item from the state.
   */
  insertJSXItem = (item) => {
    if (this.store.state.itemMetaLookup[item.id] != null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${item.id}"`].join("\n"));
    }
    this.store.update({
      itemMetaLookup: _extends({}, this.store.state.itemMetaLookup, {
        [item.id]: item
      }),
      // For Simple Tree View, we don't have a proper `item` object, so we create a very basic one.
      itemModelLookup: _extends({}, this.store.state.itemModelLookup, {
        [item.id]: {
          id: item.id,
          label: item.label ?? ""
        }
      })
    });
    return () => {
      const newItemMetaLookup = _extends({}, this.store.state.itemMetaLookup);
      const newItemModelLookup = _extends({}, this.store.state.itemModelLookup);
      delete newItemMetaLookup[item.id];
      delete newItemModelLookup[item.id];
      this.store.update({
        itemMetaLookup: newItemMetaLookup,
        itemModelLookup: newItemModelLookup
      });
    };
  };
  /**
   * Updates the `labelMap` to register the first character of the given item's label.
   * This map is used to navigate the tree using type-ahead search.
   * @param {TreeViewItemId} itemId The id of the item to map the label of.
   * @param {string} label The item's label.
   * @returns {() => void} A function to remove the item from the `labelMap`.
   */
  mapLabelFromJSX = (itemId, label) => {
    this.store.keyboardNavigation.updateLabelMap((labelMap) => {
      labelMap[itemId] = label;
      return labelMap;
    });
    return () => {
      this.store.keyboardNavigation.updateLabelMap((labelMap) => {
        const newMap = _extends({}, labelMap);
        delete newMap[itemId];
        return newMap;
      });
    };
  };
  /**
   * Store the ids of a given item's children in the state.
   * Those ids must be passed in the order they should be rendered.
   * @param {TreeViewItemId | null} parentId The id of the item to store the children of.
   * @param {TreeViewItemId[]} orderedChildrenIds The ids of the item's children.
   */
  setJSXItemsOrderedChildrenIds = (parentId, orderedChildrenIds) => {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    this.store.update({
      itemOrderedChildrenIdsLookup: _extends({}, this.store.state.itemOrderedChildrenIdsLookup, {
        [parentIdWithDefault]: orderedChildrenIds
      }),
      itemChildrenIndexesLookup: _extends({}, this.store.state.itemChildrenIndexesLookup, {
        [parentIdWithDefault]: buildSiblingIndexes(orderedChildrenIds)
      })
    });
  };
}
const parametersToStateMapper = {
  getInitialState: (minimalInitialState) => minimalInitialState,
  updateStateFromParameters: (newMinimalState) => newMinimalState,
  shouldIgnoreItemsStateUpdate: () => true
};
class SimpleTreeViewStore extends MinimalTreeViewStore {
  jsxItems = (() => new TreeViewJSXItemsPlugin(this))();
  constructor(parameters) {
    super(_extends({}, parameters, {
      items: EMPTY_ARRAY
    }), "SimpleTreeView", parametersToStateMapper);
  }
  updateStateFromParameters(parameters) {
    super.updateStateFromParameters(_extends({}, parameters, {
      items: EMPTY_ARRAY
    }));
  }
}
const useThemeProps$1 = createUseThemeProps();
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes
  } = ownerState;
  return reactExports.useMemo(() => {
    const slots = {
      root: ["root"],
      item: ["item"],
      itemContent: ["itemContent"],
      itemGroupTransition: ["itemGroupTransition"],
      itemIconContainer: ["itemIconContainer"],
      itemLabel: ["itemLabel"],
      // itemLabelInput: ['itemLabelInput'], => feature not available on this component
      itemCheckbox: ["itemCheckbox"]
      // itemDragAndDropOverlay: ['itemDragAndDropOverlay'], => feature not available on this component
      // itemErrorIcon: ['itemErrorIcon'], => feature not available on this component
    };
    return composeClasses(slots, getSimpleTreeViewUtilityClass, classes);
  }, [classes]);
};
const SimpleTreeViewRoot = styled("ul", {
  name: "MuiSimpleTreeView",
  slot: "Root"
})({
  padding: 0,
  margin: 0,
  listStyle: "none",
  outline: 0,
  position: "relative"
});
const SimpleTreeView = /* @__PURE__ */ reactExports.forwardRef(function SimpleTreeView2(inProps, forwardedRef) {
  const props = useThemeProps$1({
    props: inProps,
    name: "MuiSimpleTreeView"
  });
  const {
    slots,
    slotProps,
    apiRef,
    parameters,
    forwardedProps
  } = useExtractSimpleTreeViewParameters(props);
  const store = useTreeViewStore(SimpleTreeViewStore, parameters);
  const ref = reactExports.useRef(null);
  const handleRef = useMergedRefs(forwardedRef, ref);
  const getRootProps = useTreeViewRootProps(store, forwardedProps, handleRef);
  const classes = useUtilityClasses$1(props);
  const Root = slots?.root ?? SimpleTreeViewRoot;
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps?.root,
    className: classes.root,
    getSlotProps: getRootProps,
    ownerState: props
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewProvider, {
    store,
    classes,
    slots,
    slotProps,
    apiRef,
    rootRef: ref,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewChildrenItemProvider, {
      itemId: null,
      idAttribute: null,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewItemDepthContext.Provider, {
        value: 0,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends({}, rootProps))
      })
    })
  });
});
const depthSelector = (state, itemId, depthContext) => {
  if (typeof depthContext === "function") {
    return depthContext(state, itemId);
  }
  return depthContext;
};
const useTreeItem = (parameters) => {
  const {
    runItemPlugins,
    publicAPI,
    store
  } = useTreeViewContext();
  const depthContext = reactExports.useContext(TreeViewItemDepthContext);
  const depth = useStore(store, depthSelector, parameters.itemId, depthContext);
  const {
    id,
    itemId,
    label,
    children,
    rootRef
  } = parameters;
  const {
    rootRef: pluginRootRef,
    contentRef,
    propsEnhancers
  } = runItemPlugins(parameters);
  const {
    interactions,
    status
  } = useTreeItemUtils({
    itemId,
    children
  });
  const rootRefObject = reactExports.useRef(null);
  const contentRefObject = reactExports.useRef(null);
  const handleRootRef = useMergedRefs(rootRef, pluginRootRef, rootRefObject);
  const handleContentRef = useMergedRefs(contentRef, contentRefObject);
  const checkboxRef = reactExports.useRef(null);
  const isCheckboxSelectionEnabled = useStore(store, selectionSelectors.isCheckboxSelectionEnabled);
  const idAttribute = useStore(store, idSelectors.treeItemIdAttribute, itemId, id);
  const shouldBeAccessibleWithTab = useStore(store, focusSelectors.isItemTheDefaultFocusableItem, itemId);
  const sharedPropsEnhancerParams = {
    rootRefObject,
    contentRefObject,
    interactions
  };
  const createRootHandleFocus = (otherHandlers) => (event) => {
    otherHandlers.onFocus?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (!status.focused && itemsSelectors.canItemBeFocused(store.state, itemId) && event.currentTarget === event.target) {
      store.focus.focusItem(event, itemId);
    }
  };
  const createRootHandleBlur = (otherHandlers) => (event) => {
    otherHandlers.onBlur?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const rootElement = store.items.getItemDOMElement(itemId);
    if (status.editing || // we can exit the editing state by clicking outside the input (within the Tree Item) or by pressing Enter or Escape -> we don't want to remove the focused item from the state in these cases
    // we can also exit the editing state by clicking on the root itself -> want to remove the focused item from the state in this case
    event.relatedTarget && isTargetInDescendants(event.relatedTarget, rootElement) && (event.target && event.target?.dataset?.element === "labelInput" && isTargetInDescendants(event.target, rootElement) || event.relatedTarget?.dataset?.element === "labelInput")) {
      return;
    }
    store.focus.removeFocusedItem();
  };
  const createRootHandleKeyDown = (otherHandlers) => (event) => {
    otherHandlers.onKeyDown?.(event);
    if (event.defaultMuiPrevented || event.target?.dataset?.element === "labelInput") {
      return;
    }
    store.keyboardNavigation.handleItemKeyDown(event, itemId);
  };
  const createLabelHandleDoubleClick = (otherHandlers) => (event) => {
    otherHandlers.onDoubleClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    interactions.toggleItemEditing();
  };
  const createContentHandleClick = (otherHandlers) => (event) => {
    otherHandlers.onClick?.(event);
    store.items.handleItemClick(event, itemId);
    if (event.defaultMuiPrevented || checkboxRef.current?.contains(event.target)) {
      return;
    }
    if (expansionSelectors.triggerSlot(store.state) === "content") {
      interactions.handleExpansion(event);
    }
    if (!isCheckboxSelectionEnabled) {
      interactions.handleSelection(event);
    }
  };
  const createContentHandleMouseDown = (otherHandlers) => (event) => {
    otherHandlers.onMouseDown?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.shiftKey || event.ctrlKey || event.metaKey || status.disabled) {
      event.preventDefault();
    }
  };
  const createIconContainerHandleClick = (otherHandlers) => (event) => {
    otherHandlers.onClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (expansionSelectors.triggerSlot(store.state) === "iconContainer") {
      interactions.handleExpansion(event);
    }
  };
  const getContextProviderProps = () => ({
    itemId,
    id
  });
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = _extends({}, extractEventHandlers(parameters), extractEventHandlers(externalProps));
    const props = _extends({}, externalEventHandlers, {
      ref: handleRootRef,
      role: "treeitem",
      tabIndex: shouldBeAccessibleWithTab ? 0 : -1,
      id: idAttribute,
      "aria-expanded": status.expandable ? status.expanded : void 0,
      "aria-disabled": status.disabled || void 0
    }, externalProps, {
      style: _extends({}, externalProps.style ?? {}, {
        "--TreeView-itemDepth": depth
      }),
      onFocus: createRootHandleFocus(externalEventHandlers),
      onBlur: createRootHandleBlur(externalEventHandlers),
      onKeyDown: createRootHandleKeyDown(externalEventHandlers)
    });
    const enhancedRootProps = propsEnhancers.root?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedRootProps);
  };
  const getContentProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    const props = _extends({}, externalEventHandlers, externalProps, {
      ref: handleContentRef,
      onClick: createContentHandleClick(externalEventHandlers),
      onMouseDown: createContentHandleMouseDown(externalEventHandlers),
      status
    });
    ["expanded", "selected", "focused", "disabled", "editing", "editable"].forEach((key) => {
      if (status[key]) {
        props[`data-${key}`] = "";
      }
    });
    const enhancedContentProps = propsEnhancers.content?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedContentProps);
  };
  const getCheckboxProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    const props = _extends({}, externalEventHandlers, {
      ref: checkboxRef,
      "aria-hidden": true
    }, externalProps);
    const enhancedCheckboxProps = propsEnhancers.checkbox?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedCheckboxProps);
  };
  const getLabelProps = (externalProps = {}) => {
    const externalEventHandlers = _extends({}, extractEventHandlers(externalProps));
    const props = _extends({}, externalEventHandlers, {
      children: label
    }, externalProps, {
      onDoubleClick: createLabelHandleDoubleClick(externalEventHandlers)
    });
    const enhancedLabelProps = propsEnhancers.label?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, enhancedLabelProps, props);
  };
  const getLabelInputProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    const enhancedLabelInputProps = propsEnhancers.labelInput?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, externalProps, enhancedLabelInputProps);
  };
  const getIconContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    return _extends({}, externalEventHandlers, externalProps, {
      onClick: createIconContainerHandleClick(externalEventHandlers)
    });
  };
  const getErrorContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    return _extends({}, externalEventHandlers, externalProps);
  };
  const getLoadingContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    return _extends({
      size: "12px",
      thickness: 6
    }, externalEventHandlers, externalProps);
  };
  const getGroupTransitionProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    const response = _extends({}, externalEventHandlers, {
      unmountOnExit: true,
      component: "ul",
      role: "group",
      in: status.expanded,
      children
    }, externalProps);
    return response;
  };
  const getDragAndDropOverlayProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers(externalProps);
    const enhancedDragAndDropOverlayProps = propsEnhancers.dragAndDropOverlay?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, externalProps, enhancedDragAndDropOverlayProps);
  };
  return {
    getContextProviderProps,
    getRootProps,
    getContentProps,
    getGroupTransitionProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    getErrorContainerProps,
    getLoadingContainerProps,
    rootRef: handleRootRef,
    status,
    publicAPI
  };
};
function getTreeItemUtilityClass(slot) {
  return generateUtilityClass("MuiTreeItem", slot);
}
generateUtilityClasses("MuiTreeItem", [
  "root",
  "content",
  "groupTransition",
  "iconContainer",
  "label",
  "checkbox",
  "labelInput",
  "dragAndDropOverlay",
  "errorIcon",
  "loadingIcon",
  // State classes, will be replaced by data-attrs in the next major
  "expanded",
  "selected",
  "focused",
  "disabled",
  "editable",
  "editing"
]);
const TreeViewExpandIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}));
const TreeViewCollapseIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}));
const _excluded$1 = ["ownerState"];
function pickIcon(treeItemIcon, treeViewIcon, fallback) {
  if (treeItemIcon !== void 0) {
    return treeItemIcon;
  }
  if (treeViewIcon !== void 0) {
    return treeViewIcon;
  }
  return fallback;
}
function TreeItemIcon(props) {
  const {
    slots: slotsFromTreeItem,
    slotProps: slotPropsFromTreeItem,
    status
  } = props;
  const {
    slots: slotsFromTreeView,
    slotProps: slotPropsFromTreeView
  } = useTreeViewStyleContext();
  const slots = {
    collapseIcon: pickIcon(slotsFromTreeItem?.collapseIcon, slotsFromTreeView.collapseIcon, TreeViewCollapseIcon),
    expandIcon: pickIcon(slotsFromTreeItem?.expandIcon, slotsFromTreeView.expandIcon, TreeViewExpandIcon),
    endIcon: pickIcon(slotsFromTreeItem?.endIcon, slotsFromTreeView.endIcon),
    icon: slotsFromTreeItem?.icon
  };
  let iconName;
  if (slots?.icon) {
    iconName = "icon";
  } else if (status.expandable) {
    if (status.expanded) {
      iconName = "collapseIcon";
    } else {
      iconName = "expandIcon";
    }
  } else {
    iconName = "endIcon";
  }
  const Icon = slots[iconName];
  const _useSlotProps = useSlotProps({
    elementType: Icon,
    externalSlotProps: (tempOwnerState) => _extends({}, resolveComponentProps(slotPropsFromTreeView[iconName], tempOwnerState), resolveComponentProps(slotPropsFromTreeItem?.[iconName], tempOwnerState)),
    // TODO: Add proper ownerState
    ownerState: {}
  }), iconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded$1);
  if (!Icon) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends({}, iconProps));
}
const TreeItemDragAndDropOverlayRoot = styled("div", {
  name: "MuiTreeItemDragAndDropOverlay",
  slot: "Root",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "action"
})(({
  theme
}) => ({
  position: "absolute",
  left: 0,
  display: "flex",
  top: 0,
  bottom: 0,
  right: 0,
  pointerEvents: "none",
  variants: [{
    props: {
      action: "make-child"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderRadius: theme.shape.borderRadius,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.darkChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.dark, theme.palette.action.focusOpacity)
    }
  }, {
    props: {
      action: "reorder-above"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderTop: `1px solid ${(theme.vars || theme).palette.action.active}`
    }
  }, {
    props: {
      action: "reorder-below"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderBottom: `1px solid ${(theme.vars || theme).palette.action.active}`
    }
  }, {
    props: {
      action: "move-to-parent"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * calc(var(--TreeView-itemDepth) - 1))",
      borderBottom: `1px solid ${(theme.vars || theme).palette.action.active}`
    }
  }]
}));
function TreeItemDragAndDropOverlay(props) {
  if (props.action == null) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeItemDragAndDropOverlayRoot, _extends({}, props));
}
function TreeItemProvider(props) {
  const {
    children,
    itemId,
    id
  } = props;
  const {
    wrapItem,
    store
  } = useTreeViewContext();
  const idAttribute = useStore(store, idSelectors.treeItemIdAttribute, itemId, id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: wrapItem({
      children,
      itemId,
      store,
      idAttribute
    })
  });
}
const TreeItemLabelInput = styled("input", {
  name: "MuiTreeItem",
  slot: "LabelInput"
})(({
  theme
}) => _extends({}, theme.typography.body1, {
  width: "100%",
  backgroundColor: (theme.vars || theme).palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  border: "none",
  padding: "0 2px",
  boxSizing: "border-box",
  "&:focus": {
    outline: `1px solid ${(theme.vars || theme).palette.primary.main}`
  }
}));
const _excluded = ["visible"], _excluded2 = ["id", "itemId", "label", "disabled", "disableSelection", "children", "slots", "slotProps", "classes"];
const useThemeProps = createUseThemeProps();
const TreeItemRoot = styled("li", {
  name: "MuiTreeItem",
  slot: "Root"
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  outline: 0
});
const TreeItemContent$1 = styled("div", {
  name: "MuiTreeItem",
  slot: "Content",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "status"
})(({
  theme
}) => ({
  padding: theme.spacing(0.5, 1),
  paddingLeft: `calc(${theme.spacing(1)} + var(--TreeView-itemChildrenIndentation) * var(--TreeView-itemDepth))`,
  borderRadius: theme.shape.borderRadius,
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  position: "relative",
  display: "flex",
  alignItems: "center",
  gap: theme.spacing(1),
  cursor: "pointer",
  WebkitTapHighlightColor: "transparent",
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  "&[data-disabled]": {
    opacity: (theme.vars || theme).palette.action.disabledOpacity,
    backgroundColor: "transparent",
    cursor: "auto"
  },
  "&[data-focused]": {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  "&[data-selected]": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      }
    }
  },
  "&[data-selected][data-focused]": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
  }
}));
const TreeItemLabel = styled("div", {
  name: "MuiTreeItem",
  slot: "Label",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "editable"
})(({
  theme
}) => _extends({
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  // fixes overflow - see https://github.com/mui/material-ui/issues/27372
  minWidth: 0,
  position: "relative",
  overflow: "hidden"
}, theme.typography.body1, {
  variants: [{
    props: ({
      editable
    }) => editable,
    style: {
      paddingLeft: "2px"
    }
  }]
}));
const TreeItemIconContainer = styled("div", {
  name: "MuiTreeItem",
  slot: "IconContainer"
})({
  width: 16,
  display: "flex",
  flexShrink: 0,
  justifyContent: "center",
  position: "relative",
  cursor: "inherit",
  "& svg": {
    fontSize: 18
  }
});
const TreeItemGroupTransition = styled(Collapse, {
  name: "MuiTreeItem",
  slot: "GroupTransition",
  overridesResolver: (props, styles2) => styles2.groupTransition
})({
  margin: 0,
  padding: 0
});
const TreeItemErrorContainer = styled("div", {
  name: "MuiTreeItem",
  slot: "ErrorIcon"
})({
  position: "absolute",
  right: -3,
  width: 7,
  height: 7,
  borderRadius: "50%",
  backgroundColor: "red"
});
const TreeItemLoadingContainer = styled(CircularProgress, {
  name: "MuiTreeItem",
  slot: "LoadingIcon"
})({
  color: "text.primary"
});
const TreeItemCheckbox = styled(/* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const {
    visible
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  if (!visible) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, _extends({}, other, {
    ref
  }));
}), {
  name: "MuiTreeItem",
  slot: "Checkbox"
})({
  padding: 0
});
const useUtilityClasses = (classesProp) => {
  const {
    classes: classesFromTreeView
  } = useTreeViewStyleContext();
  const classes = _extends({}, classesProp, {
    root: clsx(classesProp?.root, classesFromTreeView.root),
    content: clsx(classesProp?.content, classesFromTreeView.itemContent),
    iconContainer: clsx(classesProp?.iconContainer, classesFromTreeView.itemIconContainer),
    checkbox: clsx(classesProp?.checkbox, classesFromTreeView.itemCheckbox),
    label: clsx(classesProp?.label, classesFromTreeView.itemLabel),
    groupTransition: clsx(classesProp?.groupTransition, classesFromTreeView.itemGroupTransition),
    labelInput: clsx(classesProp?.labelInput, classesFromTreeView.itemLabelInput),
    dragAndDropOverlay: clsx(classesProp?.dragAndDropOverlay, classesFromTreeView.itemDragAndDropOverlay),
    errorIcon: clsx(classesProp?.errorIcon, classesFromTreeView.itemErrorIcon),
    loadingIcon: clsx(classesProp?.loadingIcon, classesFromTreeView.itemLoadingIcon)
  });
  const slots = {
    root: ["root"],
    content: ["content"],
    iconContainer: ["iconContainer"],
    checkbox: ["checkbox"],
    label: ["label"],
    groupTransition: ["groupTransition"],
    labelInput: ["labelInput"],
    dragAndDropOverlay: ["dragAndDropOverlay"],
    errorIcon: ["errorIcon"],
    loadingIcon: ["loadingIcon"],
    expanded: ["expanded"],
    editing: ["editing"],
    editable: ["editable"],
    selected: ["selected"],
    focused: ["focused"],
    disabled: ["disabled"]
  };
  return composeClasses(slots, getTreeItemUtilityClass, classes);
};
const TreeItem = /* @__PURE__ */ reactExports.forwardRef(function TreeItem2(inProps, forwardedRef) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTreeItem"
  });
  const {
    id,
    itemId,
    label,
    disabled,
    disableSelection,
    children,
    slots = {},
    slotProps = {},
    classes: classesProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const {
    getContextProviderProps,
    getRootProps,
    getContentProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getGroupTransitionProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    getErrorContainerProps,
    getLoadingContainerProps,
    status
  } = useTreeItem({
    id,
    itemId,
    children,
    label,
    disabled,
    disableSelection
  });
  const classes = useUtilityClasses(classesProp);
  const Root = slots.root ?? TreeItemRoot;
  const rootProps = useSlotProps({
    elementType: Root,
    getSlotProps: getRootProps,
    externalForwardedProps: other,
    externalSlotProps: slotProps.root,
    additionalProps: {
      ref: forwardedRef
    },
    ownerState: {},
    className: classes.root
  });
  const Content = slots.content ?? TreeItemContent$1;
  const contentProps = useSlotProps({
    elementType: Content,
    getSlotProps: getContentProps,
    externalSlotProps: slotProps.content,
    ownerState: {},
    className: clsx(classes.content, status.expanded && classes.expanded, status.selected && classes.selected, status.focused && classes.focused, status.disabled && classes.disabled, status.editing && classes.editing, status.editable && classes.editable)
  });
  const IconContainer = slots.iconContainer ?? TreeItemIconContainer;
  const iconContainerProps = useSlotProps({
    elementType: IconContainer,
    getSlotProps: getIconContainerProps,
    externalSlotProps: slotProps.iconContainer,
    ownerState: {},
    className: classes.iconContainer
  });
  const Label = slots.label ?? TreeItemLabel;
  const labelProps = useSlotProps({
    elementType: Label,
    getSlotProps: getLabelProps,
    externalSlotProps: slotProps.label,
    ownerState: {},
    className: classes.label
  });
  const Checkbox3 = slots.checkbox ?? TreeItemCheckbox;
  const checkboxProps = useSlotProps({
    elementType: Checkbox3,
    getSlotProps: getCheckboxProps,
    externalSlotProps: slotProps.checkbox,
    ownerState: {},
    className: classes.checkbox
  });
  const GroupTransition = slots.groupTransition ?? void 0;
  const groupTransitionProps = useSlotProps({
    elementType: GroupTransition,
    getSlotProps: getGroupTransitionProps,
    externalSlotProps: slotProps.groupTransition,
    ownerState: {},
    className: classes.groupTransition
  });
  const LabelInput = slots.labelInput ?? TreeItemLabelInput;
  const labelInputProps = useSlotProps({
    elementType: LabelInput,
    getSlotProps: getLabelInputProps,
    externalSlotProps: slotProps.labelInput,
    ownerState: {},
    className: classes.labelInput
  });
  const DragAndDropOverlay = slots.dragAndDropOverlay ?? TreeItemDragAndDropOverlay;
  const dragAndDropOverlayProps = useSlotProps({
    elementType: DragAndDropOverlay,
    getSlotProps: getDragAndDropOverlayProps,
    externalSlotProps: slotProps.dragAndDropOverlay,
    ownerState: {},
    className: classes.dragAndDropOverlay
  });
  const ErrorIcon = slots.errorIcon ?? TreeItemErrorContainer;
  const errorContainerProps = useSlotProps({
    elementType: ErrorIcon,
    getSlotProps: getErrorContainerProps,
    externalSlotProps: slotProps.errorIcon,
    ownerState: {},
    className: classes.errorIcon
  });
  const LoadingIcon = slots.loadingIcon ?? TreeItemLoadingContainer;
  const loadingContainerProps = useSlotProps({
    elementType: LoadingIcon,
    getSlotProps: getLoadingContainerProps,
    externalSlotProps: slotProps.loadingIcon,
    ownerState: {},
    className: classes.loadingIcon
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeItemProvider, _extends({}, getContextProviderProps(), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends({}, rootProps, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(Content, _extends({}, contentProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(IconContainer, _extends({}, iconContainerProps, {
          children: [status.error && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, _extends({}, errorContainerProps)), status.loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, _extends({}, loadingContainerProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(TreeItemIcon, {
            status,
            slots,
            slotProps
          })]
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox3, _extends({}, checkboxProps)), status.editing ? /* @__PURE__ */ jsxRuntimeExports.jsx(LabelInput, _extends({}, labelInputProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(Label, _extends({}, labelProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(DragAndDropOverlay, _extends({}, dragAndDropOverlayProps))]
      })), children && /* @__PURE__ */ jsxRuntimeExports.jsx(TreeItemGroupTransition, _extends({
        as: GroupTransition
      }, groupTransitionProps))]
    }))
  }));
});
function TreeItemContent(props) {
  const { content, childContents, owner, repo, filterType, onClick } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TreeItem,
    {
      itemId: content.sha,
      label: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading..." }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentLabel$1, { content, owner, repo, onFileClick: onClick }) }),
      sx: {
        padding: 0,
        "& .MuiTreeItem-content": {
          padding: 0
        }
      },
      children: childContents && renderTreeItems(childContents, owner, repo, filterType, onClick)
    },
    content.sha
  );
}
function renderTreeItems(treeItems, owner, repo, filterType, onClick) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: treeItems.map(({ content, children }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TreeItemContent,
    {
      content,
      childContents: children,
      owner,
      repo,
      filterType,
      onClick
    },
    content.sha
  )) });
}
function filterTreeBySearch(treeItems, searchQuery) {
  if (!searchQuery) return treeItems;
  const filtered = [];
  for (const item of treeItems) {
    const nameMatches = item.content.name.toLowerCase().includes(searchQuery.toLowerCase());
    const filteredChildren = item.children ? filterTreeBySearch(item.children, searchQuery) : [];
    if (nameMatches || filteredChildren.length > 0) {
      filtered.push({
        content: item.content,
        children: filteredChildren.length > 0 ? filteredChildren : item.children
      });
    }
  }
  return filtered;
}
function ContentTree(props) {
  const { owner, repo, path: path2, searchQuery = "", filterType = "all" } = props;
  const { contentTree, shaList } = useContentTree({ owner, repo, path: path2 });
  const { setActiveContent } = useActiveContent({ owner, repo });
  const filteredTree = reactExports.useMemo(
    () => filterTreeBySearch(contentTree, searchQuery),
    [contentTree, searchQuery]
  );
  const expandedNodes = reactExports.useMemo(() => {
    if (searchQuery) {
      const allShas = [];
      const collectShas = (items) => {
        items.forEach((item) => {
          allShas.push(item.content.sha);
          if (item.children) collectShas(item.children);
        });
      };
      collectShas(filteredTree);
      return allShas;
    }
    return shaList || [];
  }, [searchQuery, filteredTree, shaList]);
  if (filteredTree.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { padding: 4, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: searchQuery ? "  ." : " ." }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SimpleTreeView,
    {
      slots: {
        collapseIcon: ExpandMoreIcon,
        expandIcon: ChevronRightIcon
      },
      sx: {
        margin: "1rem",
        flexGrow: 1
      },
      defaultExpandedItems: expandedNodes,
      children: renderTreeItems(filteredTree, owner, repo, filterType, setActiveContent)
    }
  );
}
const ContentTree$1 = reactExports.memo(ContentTree);
const LAST_REPO_KEY = "flash-man:last-repo";
function ContentView(props) {
  const { className } = props;
  const {
    queryParams: { owner, repo, path: path2 },
    mergeQueryParams
  } = useTypedSearchParams(routes.flashMan.contents.$config);
  const config2 = useAtomValue(flashManConfigAtom);
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [filterType, setFilterType] = reactExports.useState("all");
  const repos = useRepositoryList(config2.repos, searchQuery);
  const handleClearSearch = () => {
    setSearchQuery("");
  };
  const currentRepoValue = `${owner || DEFAULT_REPO_ID.owner}/${repo || DEFAULT_REPO_ID.repo}`;
  reactExports.useEffect(() => {
    if (!owner && !repo && repos.length > 0) {
      const lastRepo = localStorage.getItem(LAST_REPO_KEY);
      if (lastRepo) {
        const [savedOwner, savedRepo] = lastRepo.split("/");
        const exists = repos.some((r) => r.owner === savedOwner && r.repo === savedRepo);
        if (exists) {
          mergeQueryParams({ owner: savedOwner, repo: savedRepo });
          return;
        }
      }
      mergeQueryParams(DEFAULT_REPO_ID);
    }
  }, [owner, repo, path2, repos, mergeQueryParams]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { margin: "1rem 1rem .4rem", display: "flex", flexDirection: "column", gap: 2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Autocomplete,
        {
          fullWidth: true,
          options: repos,
          getOptionLabel: (option) => option.label,
          value: repos.find((r) => r.label === currentRepoValue) || null,
          onChange: (_, newValue) => {
            if (newValue) {
              const { owner: newOwner, repo: newRepo } = newValue;
              localStorage.setItem(LAST_REPO_KEY, `${newOwner}/${newRepo}`);
              mergeQueryParams({ owner: newOwner, repo: newRepo });
            }
          },
          renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { ...params, label: "" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          fullWidth: true,
          size: "small",
          placeholder: " ...",
          value: searchQuery,
          onChange: (e) => setSearchQuery(e.target.value),
          slotProps: {
            input: {
              startAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, { position: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon, {}) }),
              endAdornment: searchQuery && /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, { position: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { size: "small", onClick: handleClearSearch, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClearIcon, {}) }) })
            }
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1, flexWrap: "wrap", alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          ToggleButtonGroup,
          {
            size: "small",
            value: filterType,
            exclusive: true,
            onChange: (_, value) => value && setFilterType(value),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { value: "all", children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { value: "not-started", children: "  " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { value: "in-progress", children: " " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { value: "completed", children: "" })
            ]
          }
        ),
        filterType !== "all" && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: " ", size: "small", onDelete: () => setFilterType("all") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      reactExports.Suspense,
      {
        fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: { display: "flex", alignItems: "center", justifyContent: "center", height: "70vh" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
          }
        ),
        children: owner && repo && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: config2.viewType === "tree" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentTree$1,
          {
            owner,
            repo,
            path: path2,
            searchQuery,
            filterType
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentList$1,
          {
            owner,
            repo,
            path: path2,
            searchQuery,
            filterType
          }
        ) })
      }
    )
  ] });
}
const ContentView$1 = reactExports.memo(ContentView);
function useFlashCardContent({ owner, repo, path: path2 }) {
  const octokit = useOctokit();
  const token = useGithubToken();
  const { data: content } = useSuspenseQuery({
    queryKey: ["useFlashCardContent", owner, repo, path2, token],
    queryFn: async () => {
      if (!owner || !repo || !path2) return null;
      return getFlashCardContent(octokit, { owner, repo }, path2);
    },
    staleTime: 1e3 * 60 * 5
  });
  return { content };
}
function useGithubCardContextNext(contentIdentifier) {
  const { content } = useFlashCardContent(contentIdentifier);
  const contentIdentifierForParent = reactExports.useMemo(() => {
    const { owner, repo, path: path2 } = contentIdentifier;
    const parts = path2?.split("/");
    parts?.pop();
    return {
      owner,
      repo,
      path: parts?.join("/")
    };
  }, [contentIdentifier]);
  const contents = useContentsEx(contentIdentifierForParent);
  return reactExports.useMemo(() => {
    if (content && contents instanceof Array) {
      const findIndex = contents.findIndex(({ name }) => name === content.name);
      const contentPrev = contents[findIndex - 1];
      const contentNext = contents[findIndex + 1];
      return {
        contentPrev,
        content,
        contentNext
      };
    }
    return {};
  }, [content, contents]);
}
function useFlashCardItemSummaries(content, sort) {
  const summary = useLearningHistorySummary(content?.sha);
  return reactExports.useMemo(() => {
    if (!content) return [];
    const lineHistories = /* @__PURE__ */ new Map();
    for (const h of summary.histories) {
      if (h.type === "fin") continue;
      const entry = lineHistories.get(h.line_no) ?? { pass: 0, total: 0 };
      entry.total++;
      if (h.type === "pass") entry.pass++;
      lineHistories.set(h.line_no, entry);
    }
    const items = content.flashCardItems.map((item) => {
      const entry = lineHistories.get(item.lineNo);
      const passRatio = entry && entry.total > 0 ? entry.pass / entry.total * 100 : 0;
      return { ...item, passRatio };
    });
    if (sort) {
      items.sort((a, b) => a.passRatio - b.passRatio);
    }
    return items;
  }, [content, summary.histories, sort]);
}
class SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second2) {
    if (!second2) {
      return first && first.loc;
    } else if (!first || !first.loc || !second2.loc || first.loc.lexer !== second2.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second2.loc.end);
    }
  }
}
let Token$1 = class Token {
  // don't expand the token
  // used in \noexpand
  constructor(text2, loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text2;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(endToken, text2) {
    return new Token(text2, SourceLocation.range(this, endToken));
  }
};
class ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(message, token) {
    this.name = void 0;
    this.position = void 0;
    this.length = void 0;
    this.rawMessage = void 0;
    var error2 = "KaTeX parse error: " + message;
    var start;
    var end;
    var loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      var input = loc.lexer.input;
      start = loc.start;
      end = loc.end;
      if (start === input.length) {
        error2 += " at end of input: ";
      } else {
        error2 += " at position " + (start + 1) + ": ";
      }
      var underlined = input.slice(start, end).replace(/[^]/g, "$&");
      var left;
      if (start > 15) {
        left = "" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      var right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "";
      } else {
        right = input.slice(end);
      }
      error2 += left + underlined + right;
    }
    var self2 = new Error(error2);
    self2.name = "ParseError";
    self2.__proto__ = ParseError.prototype;
    self2.position = start;
    if (start != null && end != null) {
      self2.length = end - start;
    }
    self2.rawMessage = message;
    return self2;
  }
}
ParseError.prototype.__proto__ = Error.prototype;
var deflt = function deflt2(setting, defaultIfUndefined) {
  return setting === void 0 ? defaultIfUndefined : setting;
};
var uppercase = /([A-Z])/g;
var hyphenate = function hyphenate2(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};
var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
function escape$1(text2) {
  return String(text2).replace(ESCAPE_REGEX, (match2) => ESCAPE_LOOKUP[match2]);
}
var getBaseElem = function getBaseElem2(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem2(group.body);
  } else {
    return group;
  }
};
var isCharacterBox = function isCharacterBox2(group) {
  var baseElem = getBaseElem(group);
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};
var assert = function assert2(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};
var protocolFromUrl = function protocolFromUrl2(url) {
  var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
  if (!protocol) {
    return "_relative";
  }
  if (protocol[2] !== ":") {
    return null;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  return protocol[1].toLowerCase();
};
var utils$1 = {
  deflt,
  escape: escape$1,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
var SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (color2) => "#" + color2
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def, defs) => {
      defs.push(def);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t) => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (s) => Math.max(0, s),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};
function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }
  var type = schema.type;
  var defaultType = Array.isArray(type) ? type[0] : type;
  if (typeof defaultType !== "string") {
    return defaultType.enum[0];
  }
  switch (defaultType) {
    case "boolean":
      return false;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Settings {
  constructor(options) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    options = options || {};
    for (var prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        var schema = SETTINGS_SCHEMA[prop];
        this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      strict = strict(errorCode, errorMsg, token);
    }
    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error2) {
        strict = "error";
      }
    }
    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      var protocol = utils$1.protocolFromUrl(context.url);
      if (protocol == null) {
        return false;
      }
      context.protocol = protocol;
    }
    var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
}
class Style {
  constructor(id, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var D$1 = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;
var styles = [new Style(D$1, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D$1, Dc, T, Tc, T, Tc, T, Tc];
var Style$1 = {
  DISPLAY: styles[D$1],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
};
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(codepoint) {
  for (var i = 0; i < scriptData.length; i++) {
    var script = scriptData[i];
    for (var _i = 0; _i < script.blocks.length; _i++) {
      var block2 = script.blocks[_i];
      if (codepoint >= block2[0] && codepoint <= block2[1]) {
        return script.name;
      }
    }
  }
  return null;
}
var allBlocks = [];
scriptData.forEach((s) => s.blocks.forEach((b) => allBlocks.push(...b)));
function supportedCodepoint(codepoint) {
  for (var i = 0; i < allBlocks.length; i += 2) {
    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
      return true;
    }
  }
  return false;
}
var hLinePad = 80;
var sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
  return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
  return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
  return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
  return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
  return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
};
var phasePath = function phasePath2(y) {
  var x = y / 2;
  return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
};
var sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
  var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
  return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
};
var sqrtPath = function sqrtPath2(size, extraVinculum, viewBoxHeight) {
  extraVinculum = 1e3 * extraVinculum;
  var path2 = "";
  switch (size) {
    case "sqrtMain":
      path2 = sqrtMain(extraVinculum, hLinePad);
      break;
    case "sqrtSize1":
      path2 = sqrtSize1(extraVinculum, hLinePad);
      break;
    case "sqrtSize2":
      path2 = sqrtSize2(extraVinculum, hLinePad);
      break;
    case "sqrtSize3":
      path2 = sqrtSize3(extraVinculum, hLinePad);
      break;
    case "sqrtSize4":
      path2 = sqrtSize4(extraVinculum, hLinePad);
      break;
    case "sqrtTall":
      path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
  }
  return path2;
};
var innerPath = function innerPath2(name, height) {
  switch (name) {
    case "":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
    case "":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
    case "":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
    case "":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
    case "":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
    case "":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
    case "":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
    case "":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
    case "":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
    default:
      return "";
  }
};
var path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
var tallDelim = function tallDelim2(label, midHeight) {
  switch (label) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class DocumentFragment {
  // Never used; needed for satisfying interface.
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  /** Convert the fragment into a node. */
  toNode() {
    var frag = document.createDocumentFragment();
    for (var i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }
    return frag;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    var markup = "";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
}
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1],
    "8603": [-0.13313, 0.36687, 0, 0, 1],
    "8606": [0.01354, 0.52239, 0, 0, 1],
    "8608": [0.01354, 0.52239, 0, 0, 1],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1],
    "8620": [0, 0.54986, 0, 0, 1],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1],
    "8631": [0, 0.43056, 0, 0, 1],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1],
    "8646": [0.1808, 0.675, 0, 0, 1],
    "8647": [0.1808, 0.675, 0, 0, 1],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1],
    "8652": [0.01354, 0.52239, 0, 0, 1],
    "8653": [-0.13313, 0.36687, 0, 0, 1],
    "8654": [-0.13313, 0.36687, 0, 0, 1],
    "8655": [-0.13313, 0.36687, 0, 0, 1],
    "8666": [0.13667, 0.63667, 0, 0, 1],
    "8667": [0.13667, 0.63667, 0, 0, 1],
    "8669": [-0.13313, 0.37788, 0, 0, 1],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [222e-5, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [222e-5, 0.50222, 0, 0, 0.89444],
    "8801": [222e-5, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1],
    "8599": [0.19444, 0.69444, 0, 0, 1],
    "8600": [0.19444, 0.69444, 0, 0, 1],
    "8601": [0.19444, 0.69444, 0, 0, 1],
    "8614": [0.011, 0.511, 0, 0, 1],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1],
    "8637": [-0.13313, 0.36687, 0, 0, 1],
    "8640": [-0.13313, 0.36687, 0, 0, 1],
    "8641": [-0.13313, 0.36687, 0, 0, 1],
    "8652": [0.011, 0.671, 0, 0, 1],
    "8656": [-0.13313, 0.36687, 0, 0, 1],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1],
    "8811": [0.0391, 0.5391, 0, 0, 1],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [5e-3, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1],
    "8995": [-0.14236, 0.35764, 0, 0, 1],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 421e-5, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 88e-4, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 316e-5, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 981e-5, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-99e-5, 0.601, 0, 0, 0.77778],
    "8593": [1e-5, 0.6, 0, 0, 0.66667],
    "8595": [1e-5, 0.6, 0, 0, 0.66667],
    "8657": [1e-5, 0.6, 0, 0, 0.77778],
    "8659": [1e-5, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1],
    "8739": [-599e-5, 0.606, 0, 0, 0.33333],
    "8741": [-599e-5, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-99e-5, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1],
    "732": [0, 0.75, 0, 0, 1],
    "770": [0, 0.75, 0, 0, 1],
    "771": [0, 0.75, 0, 0, 1],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-5, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-5, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-99e-5, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-99e-5, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-5, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-5, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-499e-5, 0.605, 0, 0, 1.05556],
    "57345": [-499e-5, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};
var sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
};
var extraCharacterMap = {
  // Latin-1
  "": "A",
  "": "D",
  "": "o",
  "": "a",
  "": "d",
  "": "o",
  // Cyrillic
  "": "A",
  "": "B",
  "": "B",
  "": "F",
  "": "A",
  "": "E",
  "": "K",
  "": "3",
  "": "N",
  "": "N",
  "": "K",
  "": "N",
  "": "M",
  "": "H",
  "": "O",
  "": "N",
  "": "P",
  "": "C",
  "": "T",
  "": "y",
  "": "O",
  "": "X",
  "": "U",
  "": "h",
  "": "W",
  "": "W",
  "": "B",
  "": "X",
  "": "B",
  "": "3",
  "": "X",
  "": "R",
  "": "a",
  "": "b",
  "": "a",
  "": "r",
  "": "y",
  "": "e",
  "": "m",
  "": "e",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "m",
  "": "n",
  "": "o",
  "": "n",
  "": "p",
  "": "c",
  "": "o",
  "": "y",
  "": "b",
  "": "x",
  "": "n",
  "": "n",
  "": "w",
  "": "w",
  "": "a",
  "": "m",
  "": "a",
  "": "e",
  "": "m",
  "": "r"
};
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }
  var ch = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];
  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }
  if (!metrics && mode === "text") {
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77];
    }
  }
  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(size) {
  var sizeIndex;
  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }
  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };
    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }
  return fontMetricsBySizeIndex[sizeIndex];
}
var sizeStyleMap = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
];
var sizeMultipliers = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var sizeAtStyle = function sizeAtStyle2(size, style) {
  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
};
class Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this.minRuleThickness = data.minRuleThickness;
    this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(extension) {
    var data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var key in extension) {
      if (extension.hasOwnProperty(key)) {
        data[key] = extension[key];
      }
    }
    return new Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(style) {
    if (this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: sizeAtStyle(this.textSize, style)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(style) {
    style = style || this.style.text();
    var wantSize = sizeAtStyle(Options.BASESIZE, style);
    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
      return this;
    } else {
      return this.extend({
        style,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var size;
    switch (this.style.id) {
      case 4:
      case 5:
        size = 3;
        break;
      case 6:
      case 7:
        size = 1;
        break;
      default:
        size = 6;
    }
    return this.extend({
      style: this.style.text(),
      size
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(color2) {
    return this.extend({
      color: color2
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }
    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }
}
Options.BASESIZE = 6;
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
};
var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};
var validUnit = function validUnit2(unit2) {
  if (typeof unit2 !== "string") {
    unit2 = unit2.unit;
  }
  return unit2 in ptPerUnit || unit2 in relativeUnit || unit2 === "ex";
};
var calculateSize = function calculateSize2(sizeValue, options) {
  var scale;
  if (sizeValue.unit in ptPerUnit) {
    scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
  } else if (sizeValue.unit === "mu") {
    scale = options.fontMetrics().cssEmPerMu;
  } else {
    var unitOptions;
    if (options.style.isTight()) {
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    }
    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }
    if (unitOptions !== options) {
      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }
  return Math.min(sizeValue.number * scale, options.maxSize);
};
var makeEm = function makeEm2(n) {
  return +n.toFixed(4) + "em";
};
var createClass = function createClass2(classes) {
  return classes.filter((cls) => cls).join(" ");
};
var initNode = function initNode2(classes, options, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style || {};
  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }
    var color2 = options.getColor();
    if (color2) {
      this.style.color = color2;
    }
  }
};
var toNode = function toNode2(tagName) {
  var node = document.createElement(tagName);
  node.className = createClass(this.classes);
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      node.style[style] = this.style[style];
    }
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  }
  for (var i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }
  return node;
};
var invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
var toMarkup = function toMarkup2(tagName) {
  var markup = "<" + tagName;
  if (this.classes.length) {
    markup += ' class="' + utils$1.escape(createClass(this.classes)) + '"';
  }
  var styles2 = "";
  for (var style in this.style) {
    if (this.style.hasOwnProperty(style)) {
      styles2 += utils$1.hyphenate(style) + ":" + this.style[style] + ";";
    }
  }
  if (styles2) {
    markup += ' style="' + utils$1.escape(styles2) + '"';
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      if (invalidAttributeNameRegex.test(attr)) {
        throw new ParseError("Invalid attribute name '" + attr + "'");
      }
      markup += " " + attr + '="' + utils$1.escape(this.attributes[attr]) + '"';
    }
  }
  markup += ">";
  for (var i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }
  markup += "</" + tagName + ">";
  return markup;
};
class Span {
  constructor(classes, children, options, style) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options, style);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(attribute2, value) {
    this.attributes[attribute2] = value;
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
}
class Anchor {
  constructor(href, classes, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options);
    this.children = children || [];
    this.setAttribute("href", href);
  }
  setAttribute(attribute2, value) {
    this.attributes[attribute2] = value;
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
}
class Img {
  constructor(src, alt, style) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  toNode() {
    var node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        node.style[style] = this.style[style];
      }
    }
    return node;
  }
  toMarkup() {
    var markup = '<img src="' + utils$1.escape(this.src) + '"' + (' alt="' + utils$1.escape(this.alt) + '"');
    var styles2 = "";
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils$1.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils$1.escape(styles2) + '"';
    }
    markup += "'/>";
    return markup;
  }
}
var iCombinations = {
  "": "",
  "": "",
  "": "",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  "": ""
};
class SymbolNode {
  constructor(text2, height, depth, italic, skew2, width, classes, style) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text2;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew2 || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;
    var script = scriptFromCodepoint(this.text.charCodeAt(0));
    if (script) {
      this.classes.push(script + "_fallback");
    }
    if (/[]/.test(this.text)) {
      this.text = iCombinations[this.text];
    }
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var node = document.createTextNode(this.text);
    var span = null;
    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }
    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        span = span || document.createElement("span");
        span.style[style] = this.style[style];
      }
    }
    if (span) {
      span.appendChild(node);
      return span;
    } else {
      return node;
    }
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var needsSpan = false;
    var markup = "<span";
    if (this.classes.length) {
      needsSpan = true;
      markup += ' class="';
      markup += utils$1.escape(createClass(this.classes));
      markup += '"';
    }
    var styles2 = "";
    if (this.italic > 0) {
      styles2 += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
      if (this.style.hasOwnProperty(style)) {
        styles2 += utils$1.hyphenate(style) + ":" + this.style[style] + ";";
      }
    }
    if (styles2) {
      needsSpan = true;
      markup += ' style="' + utils$1.escape(styles2) + '"';
    }
    var escaped = utils$1.escape(this.text);
    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }
}
class SvgNode {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "svg");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node;
  }
  toMarkup() {
    var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="' + utils$1.escape(this.attributes[attr]) + '"';
      }
    }
    markup += ">";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</svg>";
    return markup;
  }
}
class PathNode {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate;
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "path");
    if (this.alternate) {
      node.setAttribute("d", this.alternate);
    } else {
      node.setAttribute("d", path[this.pathName]);
    }
    return node;
  }
  toMarkup() {
    if (this.alternate) {
      return '<path d="' + utils$1.escape(this.alternate) + '"/>';
    } else {
      return '<path d="' + utils$1.escape(path[this.pathName]) + '"/>';
    }
  }
}
class LineNode {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "line");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    return node;
  }
  toMarkup() {
    var markup = "<line";
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="' + utils$1.escape(this.attributes[attr]) + '"';
      }
    }
    markup += "/>";
    return markup;
  }
}
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
function defineSymbol(mode, font, group, replace2, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace: replace2
  };
  if (acceptUnicodeChar && replace2) {
    symbols[mode][replace2] = symbols[mode][name];
  }
}
var math = "math";
var text$2 = "text";
var main = "main";
var ams = "ams";
var accent = "accent-token";
var bin$1 = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op-token";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";
defineSymbol(math, main, rel, "", "\\equiv", true);
defineSymbol(math, main, rel, "", "\\prec", true);
defineSymbol(math, main, rel, "", "\\succ", true);
defineSymbol(math, main, rel, "", "\\sim", true);
defineSymbol(math, main, rel, "", "\\perp");
defineSymbol(math, main, rel, "", "\\preceq", true);
defineSymbol(math, main, rel, "", "\\succeq", true);
defineSymbol(math, main, rel, "", "\\simeq", true);
defineSymbol(math, main, rel, "", "\\mid", true);
defineSymbol(math, main, rel, "", "\\ll", true);
defineSymbol(math, main, rel, "", "\\gg", true);
defineSymbol(math, main, rel, "", "\\asymp", true);
defineSymbol(math, main, rel, "", "\\parallel");
defineSymbol(math, main, rel, "", "\\bowtie", true);
defineSymbol(math, main, rel, "", "\\smile", true);
defineSymbol(math, main, rel, "", "\\sqsubseteq", true);
defineSymbol(math, main, rel, "", "\\sqsupseteq", true);
defineSymbol(math, main, rel, "", "\\doteq", true);
defineSymbol(math, main, rel, "", "\\frown", true);
defineSymbol(math, main, rel, "", "\\ni", true);
defineSymbol(math, main, rel, "", "\\propto", true);
defineSymbol(math, main, rel, "", "\\vdash", true);
defineSymbol(math, main, rel, "", "\\dashv", true);
defineSymbol(math, main, rel, "", "\\owns");
defineSymbol(math, main, punct, ".", "\\ldotp");
defineSymbol(math, main, punct, "", "\\cdotp");
defineSymbol(math, main, textord, "#", "\\#");
defineSymbol(text$2, main, textord, "#", "\\#");
defineSymbol(math, main, textord, "&", "\\&");
defineSymbol(text$2, main, textord, "&", "\\&");
defineSymbol(math, main, textord, "", "\\aleph", true);
defineSymbol(math, main, textord, "", "\\forall", true);
defineSymbol(math, main, textord, "", "\\hbar", true);
defineSymbol(math, main, textord, "", "\\exists", true);
defineSymbol(math, main, textord, "", "\\nabla", true);
defineSymbol(math, main, textord, "", "\\flat", true);
defineSymbol(math, main, textord, "", "\\ell", true);
defineSymbol(math, main, textord, "", "\\natural", true);
defineSymbol(math, main, textord, "", "\\clubsuit", true);
defineSymbol(math, main, textord, "", "\\wp", true);
defineSymbol(math, main, textord, "", "\\sharp", true);
defineSymbol(math, main, textord, "", "\\diamondsuit", true);
defineSymbol(math, main, textord, "", "\\Re", true);
defineSymbol(math, main, textord, "", "\\heartsuit", true);
defineSymbol(math, main, textord, "", "\\Im", true);
defineSymbol(math, main, textord, "", "\\spadesuit", true);
defineSymbol(math, main, textord, "", "\\S", true);
defineSymbol(text$2, main, textord, "", "\\S");
defineSymbol(math, main, textord, "", "\\P", true);
defineSymbol(text$2, main, textord, "", "\\P");
defineSymbol(math, main, textord, "", "\\dag");
defineSymbol(text$2, main, textord, "", "\\dag");
defineSymbol(text$2, main, textord, "", "\\textdagger");
defineSymbol(math, main, textord, "", "\\ddag");
defineSymbol(text$2, main, textord, "", "\\ddag");
defineSymbol(text$2, main, textord, "", "\\textdaggerdbl");
defineSymbol(math, main, close, "", "\\rmoustache", true);
defineSymbol(math, main, open, "", "\\lmoustache", true);
defineSymbol(math, main, close, "", "\\rgroup", true);
defineSymbol(math, main, open, "", "\\lgroup", true);
defineSymbol(math, main, bin$1, "", "\\mp", true);
defineSymbol(math, main, bin$1, "", "\\ominus", true);
defineSymbol(math, main, bin$1, "", "\\uplus", true);
defineSymbol(math, main, bin$1, "", "\\sqcap", true);
defineSymbol(math, main, bin$1, "", "\\ast");
defineSymbol(math, main, bin$1, "", "\\sqcup", true);
defineSymbol(math, main, bin$1, "", "\\bigcirc", true);
defineSymbol(math, main, bin$1, "", "\\bullet", true);
defineSymbol(math, main, bin$1, "", "\\ddagger");
defineSymbol(math, main, bin$1, "", "\\wr", true);
defineSymbol(math, main, bin$1, "", "\\amalg");
defineSymbol(math, main, bin$1, "&", "\\And");
defineSymbol(math, main, rel, "", "\\longleftarrow", true);
defineSymbol(math, main, rel, "", "\\Leftarrow", true);
defineSymbol(math, main, rel, "", "\\Longleftarrow", true);
defineSymbol(math, main, rel, "", "\\longrightarrow", true);
defineSymbol(math, main, rel, "", "\\Rightarrow", true);
defineSymbol(math, main, rel, "", "\\Longrightarrow", true);
defineSymbol(math, main, rel, "", "\\leftrightarrow", true);
defineSymbol(math, main, rel, "", "\\longleftrightarrow", true);
defineSymbol(math, main, rel, "", "\\Leftrightarrow", true);
defineSymbol(math, main, rel, "", "\\Longleftrightarrow", true);
defineSymbol(math, main, rel, "", "\\mapsto", true);
defineSymbol(math, main, rel, "", "\\longmapsto", true);
defineSymbol(math, main, rel, "", "\\nearrow", true);
defineSymbol(math, main, rel, "", "\\hookleftarrow", true);
defineSymbol(math, main, rel, "", "\\hookrightarrow", true);
defineSymbol(math, main, rel, "", "\\searrow", true);
defineSymbol(math, main, rel, "", "\\leftharpoonup", true);
defineSymbol(math, main, rel, "", "\\rightharpoonup", true);
defineSymbol(math, main, rel, "", "\\swarrow", true);
defineSymbol(math, main, rel, "", "\\leftharpoondown", true);
defineSymbol(math, main, rel, "", "\\rightharpoondown", true);
defineSymbol(math, main, rel, "", "\\nwarrow", true);
defineSymbol(math, main, rel, "", "\\rightleftharpoons", true);
defineSymbol(math, ams, rel, "", "\\nless", true);
defineSymbol(math, ams, rel, "", "\\@nleqslant");
defineSymbol(math, ams, rel, "", "\\@nleqq");
defineSymbol(math, ams, rel, "", "\\lneq", true);
defineSymbol(math, ams, rel, "", "\\lneqq", true);
defineSymbol(math, ams, rel, "", "\\@lvertneqq");
defineSymbol(math, ams, rel, "", "\\lnsim", true);
defineSymbol(math, ams, rel, "", "\\lnapprox", true);
defineSymbol(math, ams, rel, "", "\\nprec", true);
defineSymbol(math, ams, rel, "", "\\npreceq", true);
defineSymbol(math, ams, rel, "", "\\precnsim", true);
defineSymbol(math, ams, rel, "", "\\precnapprox", true);
defineSymbol(math, ams, rel, "", "\\nsim", true);
defineSymbol(math, ams, rel, "", "\\@nshortmid");
defineSymbol(math, ams, rel, "", "\\nmid", true);
defineSymbol(math, ams, rel, "", "\\nvdash", true);
defineSymbol(math, ams, rel, "", "\\nvDash", true);
defineSymbol(math, ams, rel, "", "\\ntriangleleft");
defineSymbol(math, ams, rel, "", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "", "\\subsetneq", true);
defineSymbol(math, ams, rel, "", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "", "\\ngtr", true);
defineSymbol(math, ams, rel, "", "\\@ngeqslant");
defineSymbol(math, ams, rel, "", "\\@ngeqq");
defineSymbol(math, ams, rel, "", "\\gneq", true);
defineSymbol(math, ams, rel, "", "\\gneqq", true);
defineSymbol(math, ams, rel, "", "\\@gvertneqq");
defineSymbol(math, ams, rel, "", "\\gnsim", true);
defineSymbol(math, ams, rel, "", "\\gnapprox", true);
defineSymbol(math, ams, rel, "", "\\nsucc", true);
defineSymbol(math, ams, rel, "", "\\nsucceq", true);
defineSymbol(math, ams, rel, "", "\\succnsim", true);
defineSymbol(math, ams, rel, "", "\\succnapprox", true);
defineSymbol(math, ams, rel, "", "\\ncong", true);
defineSymbol(math, ams, rel, "", "\\@nshortparallel");
defineSymbol(math, ams, rel, "", "\\nparallel", true);
defineSymbol(math, ams, rel, "", "\\nVDash", true);
defineSymbol(math, ams, rel, "", "\\ntriangleright");
defineSymbol(math, ams, rel, "", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "", "\\supsetneq", true);
defineSymbol(math, ams, rel, "", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "", "\\nVdash", true);
defineSymbol(math, ams, rel, "", "\\precneqq", true);
defineSymbol(math, ams, rel, "", "\\succneqq", true);
defineSymbol(math, ams, rel, "", "\\@nsubseteqq");
defineSymbol(math, ams, bin$1, "", "\\unlhd");
defineSymbol(math, ams, bin$1, "", "\\unrhd");
defineSymbol(math, ams, rel, "", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "", "\\nLeftrightarrow", true);
defineSymbol(math, ams, rel, "", "\\vartriangle");
defineSymbol(math, ams, textord, "", "\\hslash");
defineSymbol(math, ams, textord, "", "\\triangledown");
defineSymbol(math, ams, textord, "", "\\lozenge");
defineSymbol(math, ams, textord, "", "\\circledS");
defineSymbol(math, ams, textord, "", "\\circledR");
defineSymbol(text$2, ams, textord, "", "\\circledR");
defineSymbol(math, ams, textord, "", "\\measuredangle", true);
defineSymbol(math, ams, textord, "", "\\nexists");
defineSymbol(math, ams, textord, "", "\\mho");
defineSymbol(math, ams, textord, "", "\\Finv", true);
defineSymbol(math, ams, textord, "", "\\Game", true);
defineSymbol(math, ams, textord, "", "\\backprime");
defineSymbol(math, ams, textord, "", "\\blacktriangle");
defineSymbol(math, ams, textord, "", "\\blacktriangledown");
defineSymbol(math, ams, textord, "", "\\blacksquare");
defineSymbol(math, ams, textord, "", "\\blacklozenge");
defineSymbol(math, ams, textord, "", "\\bigstar");
defineSymbol(math, ams, textord, "", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "", "\\complement", true);
defineSymbol(math, ams, textord, "", "\\eth", true);
defineSymbol(text$2, main, textord, "", "");
defineSymbol(math, ams, textord, "", "\\diagup");
defineSymbol(math, ams, textord, "", "\\diagdown");
defineSymbol(math, ams, textord, "", "\\square");
defineSymbol(math, ams, textord, "", "\\Box");
defineSymbol(math, ams, textord, "", "\\Diamond");
defineSymbol(math, ams, textord, "", "\\yen", true);
defineSymbol(text$2, ams, textord, "", "\\yen", true);
defineSymbol(math, ams, textord, "", "\\checkmark", true);
defineSymbol(text$2, ams, textord, "", "\\checkmark");
defineSymbol(math, ams, textord, "", "\\beth", true);
defineSymbol(math, ams, textord, "", "\\daleth", true);
defineSymbol(math, ams, textord, "", "\\gimel", true);
defineSymbol(math, ams, textord, "", "\\digamma", true);
defineSymbol(math, ams, textord, "", "\\varkappa");
defineSymbol(math, ams, open, "", "\\@ulcorner", true);
defineSymbol(math, ams, close, "", "\\@urcorner", true);
defineSymbol(math, ams, open, "", "\\@llcorner", true);
defineSymbol(math, ams, close, "", "\\@lrcorner", true);
defineSymbol(math, ams, rel, "", "\\leqq", true);
defineSymbol(math, ams, rel, "", "\\leqslant", true);
defineSymbol(math, ams, rel, "", "\\eqslantless", true);
defineSymbol(math, ams, rel, "", "\\lesssim", true);
defineSymbol(math, ams, rel, "", "\\lessapprox", true);
defineSymbol(math, ams, rel, "", "\\approxeq", true);
defineSymbol(math, ams, bin$1, "", "\\lessdot");
defineSymbol(math, ams, rel, "", "\\lll", true);
defineSymbol(math, ams, rel, "", "\\lessgtr", true);
defineSymbol(math, ams, rel, "", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "", "\\doteqdot");
defineSymbol(math, ams, rel, "", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "", "\\backsim", true);
defineSymbol(math, ams, rel, "", "\\backsimeq", true);
defineSymbol(math, ams, rel, "", "\\subseteqq", true);
defineSymbol(math, ams, rel, "", "\\Subset", true);
defineSymbol(math, ams, rel, "", "\\sqsubset", true);
defineSymbol(math, ams, rel, "", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "", "\\precsim", true);
defineSymbol(math, ams, rel, "", "\\precapprox", true);
defineSymbol(math, ams, rel, "", "\\vartriangleleft");
defineSymbol(math, ams, rel, "", "\\trianglelefteq");
defineSymbol(math, ams, rel, "", "\\vDash", true);
defineSymbol(math, ams, rel, "", "\\Vvdash", true);
defineSymbol(math, ams, rel, "", "\\smallsmile");
defineSymbol(math, ams, rel, "", "\\smallfrown");
defineSymbol(math, ams, rel, "", "\\bumpeq", true);
defineSymbol(math, ams, rel, "", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "", "\\geqq", true);
defineSymbol(math, ams, rel, "", "\\geqslant", true);
defineSymbol(math, ams, rel, "", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "", "\\gtrsim", true);
defineSymbol(math, ams, rel, "", "\\gtrapprox", true);
defineSymbol(math, ams, bin$1, "", "\\gtrdot");
defineSymbol(math, ams, rel, "", "\\ggg", true);
defineSymbol(math, ams, rel, "", "\\gtrless", true);
defineSymbol(math, ams, rel, "", "\\gtreqless", true);
defineSymbol(math, ams, rel, "", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "", "\\eqcirc", true);
defineSymbol(math, ams, rel, "", "\\circeq", true);
defineSymbol(math, ams, rel, "", "\\triangleq", true);
defineSymbol(math, ams, rel, "", "\\thicksim");
defineSymbol(math, ams, rel, "", "\\thickapprox");
defineSymbol(math, ams, rel, "", "\\supseteqq", true);
defineSymbol(math, ams, rel, "", "\\Supset", true);
defineSymbol(math, ams, rel, "", "\\sqsupset", true);
defineSymbol(math, ams, rel, "", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "", "\\succsim", true);
defineSymbol(math, ams, rel, "", "\\succapprox", true);
defineSymbol(math, ams, rel, "", "\\vartriangleright");
defineSymbol(math, ams, rel, "", "\\trianglerighteq");
defineSymbol(math, ams, rel, "", "\\Vdash", true);
defineSymbol(math, ams, rel, "", "\\shortmid");
defineSymbol(math, ams, rel, "", "\\shortparallel");
defineSymbol(math, ams, rel, "", "\\between", true);
defineSymbol(math, ams, rel, "", "\\pitchfork", true);
defineSymbol(math, ams, rel, "", "\\varpropto");
defineSymbol(math, ams, rel, "", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "", "\\therefore", true);
defineSymbol(math, ams, rel, "", "\\backepsilon");
defineSymbol(math, ams, rel, "", "\\blacktriangleright");
defineSymbol(math, ams, rel, "", "\\because", true);
defineSymbol(math, ams, rel, "", "\\llless");
defineSymbol(math, ams, rel, "", "\\gggtr");
defineSymbol(math, ams, bin$1, "", "\\lhd");
defineSymbol(math, ams, bin$1, "", "\\rhd");
defineSymbol(math, ams, rel, "", "\\eqsim", true);
defineSymbol(math, main, rel, "", "\\Join");
defineSymbol(math, ams, rel, "", "\\Doteq", true);
defineSymbol(math, ams, bin$1, "", "\\dotplus", true);
defineSymbol(math, ams, bin$1, "", "\\smallsetminus");
defineSymbol(math, ams, bin$1, "", "\\Cap", true);
defineSymbol(math, ams, bin$1, "", "\\Cup", true);
defineSymbol(math, ams, bin$1, "", "\\doublebarwedge", true);
defineSymbol(math, ams, bin$1, "", "\\boxminus", true);
defineSymbol(math, ams, bin$1, "", "\\boxplus", true);
defineSymbol(math, ams, bin$1, "", "\\divideontimes", true);
defineSymbol(math, ams, bin$1, "", "\\ltimes", true);
defineSymbol(math, ams, bin$1, "", "\\rtimes", true);
defineSymbol(math, ams, bin$1, "", "\\leftthreetimes", true);
defineSymbol(math, ams, bin$1, "", "\\rightthreetimes", true);
defineSymbol(math, ams, bin$1, "", "\\curlywedge", true);
defineSymbol(math, ams, bin$1, "", "\\curlyvee", true);
defineSymbol(math, ams, bin$1, "", "\\circleddash", true);
defineSymbol(math, ams, bin$1, "", "\\circledast", true);
defineSymbol(math, ams, bin$1, "", "\\centerdot");
defineSymbol(math, ams, bin$1, "", "\\intercal", true);
defineSymbol(math, ams, bin$1, "", "\\doublecap");
defineSymbol(math, ams, bin$1, "", "\\doublecup");
defineSymbol(math, ams, bin$1, "", "\\boxtimes", true);
defineSymbol(math, ams, rel, "", "\\dashrightarrow", true);
defineSymbol(math, ams, rel, "", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "", "\\curvearrowleft", true);
defineSymbol(math, ams, rel, "", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "", "\\Lsh", true);
defineSymbol(math, ams, rel, "", "\\upuparrows", true);
defineSymbol(math, ams, rel, "", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "", "\\downharpoonleft", true);
defineSymbol(math, main, rel, "", "\\origof", true);
defineSymbol(math, main, rel, "", "\\imageof", true);
defineSymbol(math, ams, rel, "", "\\multimap", true);
defineSymbol(math, ams, rel, "", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "", "\\looparrowright", true);
defineSymbol(math, ams, rel, "", "\\curvearrowright", true);
defineSymbol(math, ams, rel, "", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "", "\\Rsh", true);
defineSymbol(math, ams, rel, "", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "", "\\leadsto");
defineSymbol(math, ams, rel, "", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "", "\\restriction");
defineSymbol(math, main, textord, "", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text$2, main, textord, "$", "\\$");
defineSymbol(text$2, main, textord, "$", "\\textdollar");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text$2, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text$2, main, textord, "_", "\\_");
defineSymbol(text$2, main, textord, "_", "\\textunderscore");
defineSymbol(math, main, textord, "", "\\angle", true);
defineSymbol(math, main, textord, "", "\\infty", true);
defineSymbol(math, main, textord, "", "\\prime");
defineSymbol(math, main, textord, "", "\\triangle");
defineSymbol(math, main, textord, "", "\\Gamma", true);
defineSymbol(math, main, textord, "", "\\Delta", true);
defineSymbol(math, main, textord, "", "\\Theta", true);
defineSymbol(math, main, textord, "", "\\Lambda", true);
defineSymbol(math, main, textord, "", "\\Xi", true);
defineSymbol(math, main, textord, "", "\\Pi", true);
defineSymbol(math, main, textord, "", "\\Sigma", true);
defineSymbol(math, main, textord, "", "\\Upsilon", true);
defineSymbol(math, main, textord, "", "\\Phi", true);
defineSymbol(math, main, textord, "", "\\Psi", true);
defineSymbol(math, main, textord, "", "\\Omega", true);
defineSymbol(math, main, textord, "A", "");
defineSymbol(math, main, textord, "B", "");
defineSymbol(math, main, textord, "E", "");
defineSymbol(math, main, textord, "Z", "");
defineSymbol(math, main, textord, "H", "");
defineSymbol(math, main, textord, "I", "");
defineSymbol(math, main, textord, "K", "");
defineSymbol(math, main, textord, "M", "");
defineSymbol(math, main, textord, "N", "");
defineSymbol(math, main, textord, "O", "");
defineSymbol(math, main, textord, "P", "");
defineSymbol(math, main, textord, "T", "");
defineSymbol(math, main, textord, "X", "");
defineSymbol(math, main, textord, "", "\\neg", true);
defineSymbol(math, main, textord, "", "\\lnot");
defineSymbol(math, main, textord, "", "\\top");
defineSymbol(math, main, textord, "", "\\bot");
defineSymbol(math, main, textord, "", "\\emptyset");
defineSymbol(math, ams, textord, "", "\\varnothing");
defineSymbol(math, main, mathord, "", "\\alpha", true);
defineSymbol(math, main, mathord, "", "\\beta", true);
defineSymbol(math, main, mathord, "", "\\gamma", true);
defineSymbol(math, main, mathord, "", "\\delta", true);
defineSymbol(math, main, mathord, "", "\\epsilon", true);
defineSymbol(math, main, mathord, "", "\\zeta", true);
defineSymbol(math, main, mathord, "", "\\eta", true);
defineSymbol(math, main, mathord, "", "\\theta", true);
defineSymbol(math, main, mathord, "", "\\iota", true);
defineSymbol(math, main, mathord, "", "\\kappa", true);
defineSymbol(math, main, mathord, "", "\\lambda", true);
defineSymbol(math, main, mathord, "", "\\mu", true);
defineSymbol(math, main, mathord, "", "\\nu", true);
defineSymbol(math, main, mathord, "", "\\xi", true);
defineSymbol(math, main, mathord, "", "\\omicron", true);
defineSymbol(math, main, mathord, "", "\\pi", true);
defineSymbol(math, main, mathord, "", "\\rho", true);
defineSymbol(math, main, mathord, "", "\\sigma", true);
defineSymbol(math, main, mathord, "", "\\tau", true);
defineSymbol(math, main, mathord, "", "\\upsilon", true);
defineSymbol(math, main, mathord, "", "\\phi", true);
defineSymbol(math, main, mathord, "", "\\chi", true);
defineSymbol(math, main, mathord, "", "\\psi", true);
defineSymbol(math, main, mathord, "", "\\omega", true);
defineSymbol(math, main, mathord, "", "\\varepsilon", true);
defineSymbol(math, main, mathord, "", "\\vartheta", true);
defineSymbol(math, main, mathord, "", "\\varpi", true);
defineSymbol(math, main, mathord, "", "\\varrho", true);
defineSymbol(math, main, mathord, "", "\\varsigma", true);
defineSymbol(math, main, mathord, "", "\\varphi", true);
defineSymbol(math, main, bin$1, "", "*", true);
defineSymbol(math, main, bin$1, "+", "+");
defineSymbol(math, main, bin$1, "", "-", true);
defineSymbol(math, main, bin$1, "", "\\cdot", true);
defineSymbol(math, main, bin$1, "", "\\circ", true);
defineSymbol(math, main, bin$1, "", "\\div", true);
defineSymbol(math, main, bin$1, "", "\\pm", true);
defineSymbol(math, main, bin$1, "", "\\times", true);
defineSymbol(math, main, bin$1, "", "\\cap", true);
defineSymbol(math, main, bin$1, "", "\\cup", true);
defineSymbol(math, main, bin$1, "", "\\setminus", true);
defineSymbol(math, main, bin$1, "", "\\land");
defineSymbol(math, main, bin$1, "", "\\lor");
defineSymbol(math, main, bin$1, "", "\\wedge", true);
defineSymbol(math, main, bin$1, "", "\\vee", true);
defineSymbol(math, main, textord, "", "\\surd");
defineSymbol(math, main, open, "", "\\langle", true);
defineSymbol(math, main, open, "", "\\lvert");
defineSymbol(math, main, open, "", "\\lVert");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "", "\\rangle", true);
defineSymbol(math, main, close, "", "\\rvert");
defineSymbol(math, main, close, "", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "", "\\approx", true);
defineSymbol(math, main, rel, "", "\\cong", true);
defineSymbol(math, main, rel, "", "\\ge");
defineSymbol(math, main, rel, "", "\\geq", true);
defineSymbol(math, main, rel, "", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt", true);
defineSymbol(math, main, rel, "", "\\in", true);
defineSymbol(math, main, rel, "", "\\@not");
defineSymbol(math, main, rel, "", "\\subset", true);
defineSymbol(math, main, rel, "", "\\supset", true);
defineSymbol(math, main, rel, "", "\\subseteq", true);
defineSymbol(math, main, rel, "", "\\supseteq", true);
defineSymbol(math, ams, rel, "", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "", "\\nsupseteq", true);
defineSymbol(math, main, rel, "", "\\models");
defineSymbol(math, main, rel, "", "\\leftarrow", true);
defineSymbol(math, main, rel, "", "\\le");
defineSymbol(math, main, rel, "", "\\leq", true);
defineSymbol(math, main, rel, "<", "\\lt", true);
defineSymbol(math, main, rel, "", "\\rightarrow", true);
defineSymbol(math, main, rel, "", "\\to");
defineSymbol(math, ams, rel, "", "\\ngeq", true);
defineSymbol(math, ams, rel, "", "\\nleq", true);
defineSymbol(math, main, spacing, "", "\\ ");
defineSymbol(math, main, spacing, "", "\\space");
defineSymbol(math, main, spacing, "", "\\nobreakspace");
defineSymbol(text$2, main, spacing, "", "\\ ");
defineSymbol(text$2, main, spacing, "", " ");
defineSymbol(text$2, main, spacing, "", "\\space");
defineSymbol(text$2, main, spacing, "", "\\nobreakspace");
defineSymbol(math, main, spacing, null, "\\nobreak");
defineSymbol(math, main, spacing, null, "\\allowbreak");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, ams, bin$1, "", "\\barwedge", true);
defineSymbol(math, ams, bin$1, "", "\\veebar", true);
defineSymbol(math, main, bin$1, "", "\\odot", true);
defineSymbol(math, main, bin$1, "", "\\oplus", true);
defineSymbol(math, main, bin$1, "", "\\otimes", true);
defineSymbol(math, main, textord, "", "\\partial", true);
defineSymbol(math, main, bin$1, "", "\\oslash", true);
defineSymbol(math, ams, bin$1, "", "\\circledcirc", true);
defineSymbol(math, ams, bin$1, "", "\\boxdot", true);
defineSymbol(math, main, bin$1, "", "\\bigtriangleup");
defineSymbol(math, main, bin$1, "", "\\bigtriangledown");
defineSymbol(math, main, bin$1, "", "\\dagger");
defineSymbol(math, main, bin$1, "", "\\diamond");
defineSymbol(math, main, bin$1, "", "\\star");
defineSymbol(math, main, bin$1, "", "\\triangleleft");
defineSymbol(math, main, bin$1, "", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text$2, main, textord, "{", "\\{");
defineSymbol(text$2, main, textord, "{", "\\textbraceleft");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text$2, main, textord, "}", "\\}");
defineSymbol(text$2, main, textord, "}", "\\textbraceright");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack", true);
defineSymbol(text$2, main, textord, "[", "\\lbrack", true);
defineSymbol(math, main, close, "]", "\\rbrack", true);
defineSymbol(text$2, main, textord, "]", "\\rbrack", true);
defineSymbol(math, main, open, "(", "\\lparen", true);
defineSymbol(math, main, close, ")", "\\rparen", true);
defineSymbol(text$2, main, textord, "<", "\\textless", true);
defineSymbol(text$2, main, textord, ">", "\\textgreater", true);
defineSymbol(math, main, open, "", "\\lfloor", true);
defineSymbol(math, main, close, "", "\\rfloor", true);
defineSymbol(math, main, open, "", "\\lceil", true);
defineSymbol(math, main, close, "", "\\rceil", true);
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "", "|");
defineSymbol(math, main, textord, "", "\\vert");
defineSymbol(text$2, main, textord, "|", "\\textbar", true);
defineSymbol(math, main, textord, "", "\\|");
defineSymbol(math, main, textord, "", "\\Vert");
defineSymbol(text$2, main, textord, "", "\\textbardbl");
defineSymbol(text$2, main, textord, "~", "\\textasciitilde");
defineSymbol(text$2, main, textord, "\\", "\\textbackslash");
defineSymbol(text$2, main, textord, "^", "\\textasciicircum");
defineSymbol(math, main, rel, "", "\\uparrow", true);
defineSymbol(math, main, rel, "", "\\Uparrow", true);
defineSymbol(math, main, rel, "", "\\downarrow", true);
defineSymbol(math, main, rel, "", "\\Downarrow", true);
defineSymbol(math, main, rel, "", "\\updownarrow", true);
defineSymbol(math, main, rel, "", "\\Updownarrow", true);
defineSymbol(math, main, op, "", "\\coprod");
defineSymbol(math, main, op, "", "\\bigvee");
defineSymbol(math, main, op, "", "\\bigwedge");
defineSymbol(math, main, op, "", "\\biguplus");
defineSymbol(math, main, op, "", "\\bigcap");
defineSymbol(math, main, op, "", "\\bigcup");
defineSymbol(math, main, op, "", "\\int");
defineSymbol(math, main, op, "", "\\intop");
defineSymbol(math, main, op, "", "\\iint");
defineSymbol(math, main, op, "", "\\iiint");
defineSymbol(math, main, op, "", "\\prod");
defineSymbol(math, main, op, "", "\\sum");
defineSymbol(math, main, op, "", "\\bigotimes");
defineSymbol(math, main, op, "", "\\bigoplus");
defineSymbol(math, main, op, "", "\\bigodot");
defineSymbol(math, main, op, "", "\\oint");
defineSymbol(math, main, op, "", "\\oiint");
defineSymbol(math, main, op, "", "\\oiiint");
defineSymbol(math, main, op, "", "\\bigsqcup");
defineSymbol(math, main, op, "", "\\smallint");
defineSymbol(text$2, main, inner, "", "\\textellipsis");
defineSymbol(math, main, inner, "", "\\mathellipsis");
defineSymbol(text$2, main, inner, "", "\\ldots", true);
defineSymbol(math, main, inner, "", "\\ldots", true);
defineSymbol(math, main, inner, "", "\\@cdots", true);
defineSymbol(math, main, inner, "", "\\ddots", true);
defineSymbol(math, main, textord, "", "\\varvdots");
defineSymbol(text$2, main, textord, "", "\\varvdots");
defineSymbol(math, main, accent, "", "\\acute");
defineSymbol(math, main, accent, "", "\\grave");
defineSymbol(math, main, accent, "", "\\ddot");
defineSymbol(math, main, accent, "~", "\\tilde");
defineSymbol(math, main, accent, "", "\\bar");
defineSymbol(math, main, accent, "", "\\breve");
defineSymbol(math, main, accent, "", "\\check");
defineSymbol(math, main, accent, "^", "\\hat");
defineSymbol(math, main, accent, "", "\\vec");
defineSymbol(math, main, accent, "", "\\dot");
defineSymbol(math, main, accent, "", "\\mathring");
defineSymbol(math, main, mathord, "", "\\@imath");
defineSymbol(math, main, mathord, "", "\\@jmath");
defineSymbol(math, main, textord, "", "");
defineSymbol(math, main, textord, "", "");
defineSymbol(text$2, main, textord, "", "\\i", true);
defineSymbol(text$2, main, textord, "", "\\j", true);
defineSymbol(text$2, main, textord, "", "\\ss", true);
defineSymbol(text$2, main, textord, "", "\\ae", true);
defineSymbol(text$2, main, textord, "", "\\oe", true);
defineSymbol(text$2, main, textord, "", "\\o", true);
defineSymbol(text$2, main, textord, "", "\\AE", true);
defineSymbol(text$2, main, textord, "", "\\OE", true);
defineSymbol(text$2, main, textord, "", "\\O", true);
defineSymbol(text$2, main, accent, "", "\\'");
defineSymbol(text$2, main, accent, "", "\\`");
defineSymbol(text$2, main, accent, "", "\\^");
defineSymbol(text$2, main, accent, "", "\\~");
defineSymbol(text$2, main, accent, "", "\\=");
defineSymbol(text$2, main, accent, "", "\\u");
defineSymbol(text$2, main, accent, "", "\\.");
defineSymbol(text$2, main, accent, "", "\\c");
defineSymbol(text$2, main, accent, "", "\\r");
defineSymbol(text$2, main, accent, "", "\\v");
defineSymbol(text$2, main, accent, "", '\\"');
defineSymbol(text$2, main, accent, "", "\\H");
defineSymbol(text$2, main, accent, "", "\\textcircled");
var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text$2, main, textord, "", "--", true);
defineSymbol(text$2, main, textord, "", "\\textendash");
defineSymbol(text$2, main, textord, "", "---", true);
defineSymbol(text$2, main, textord, "", "\\textemdash");
defineSymbol(text$2, main, textord, "", "`", true);
defineSymbol(text$2, main, textord, "", "\\textquoteleft");
defineSymbol(text$2, main, textord, "", "'", true);
defineSymbol(text$2, main, textord, "", "\\textquoteright");
defineSymbol(text$2, main, textord, "", "``", true);
defineSymbol(text$2, main, textord, "", "\\textquotedblleft");
defineSymbol(text$2, main, textord, "", "''", true);
defineSymbol(text$2, main, textord, "", "\\textquotedblright");
defineSymbol(math, main, textord, "", "\\degree", true);
defineSymbol(text$2, main, textord, "", "\\degree");
defineSymbol(text$2, main, textord, "", "\\textdegree", true);
defineSymbol(math, main, textord, "", "\\pounds");
defineSymbol(math, main, textord, "", "\\mathsterling", true);
defineSymbol(text$2, main, textord, "", "\\pounds");
defineSymbol(text$2, main, textord, "", "\\textsterling", true);
defineSymbol(math, ams, textord, "", "\\maltese");
defineSymbol(text$2, ams, textord, "", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (var i = 0; i < mathTextSymbols.length; i++) {
  var ch = mathTextSymbols.charAt(i);
  defineSymbol(math, main, textord, ch, ch);
}
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (var _i = 0; _i < textSymbols.length; _i++) {
  var _ch = textSymbols.charAt(_i);
  defineSymbol(text$2, main, textord, _ch, _ch);
}
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var _i2 = 0; _i2 < letters.length; _i2++) {
  var _ch2 = letters.charAt(_i2);
  defineSymbol(math, main, mathord, _ch2, _ch2);
  defineSymbol(text$2, main, textord, _ch2, _ch2);
}
defineSymbol(math, ams, textord, "C", "");
defineSymbol(text$2, ams, textord, "C", "");
defineSymbol(math, ams, textord, "H", "");
defineSymbol(text$2, ams, textord, "H", "");
defineSymbol(math, ams, textord, "N", "");
defineSymbol(text$2, ams, textord, "N", "");
defineSymbol(math, ams, textord, "P", "");
defineSymbol(text$2, ams, textord, "P", "");
defineSymbol(math, ams, textord, "Q", "");
defineSymbol(text$2, ams, textord, "Q", "");
defineSymbol(math, ams, textord, "R", "");
defineSymbol(text$2, ams, textord, "R", "");
defineSymbol(math, ams, textord, "Z", "");
defineSymbol(text$2, ams, textord, "Z", "");
defineSymbol(math, main, mathord, "h", "");
defineSymbol(text$2, main, mathord, "h", "");
var wideChar = "";
for (var _i3 = 0; _i3 < letters.length; _i3++) {
  var _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56372 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56424 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56580 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56684 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56736 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56788 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56840 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56944 + _i3);
  defineSymbol(math, main, mathord, _ch3, wideChar);
  defineSymbol(text$2, main, textord, _ch3, wideChar);
  if (_i3 < 26) {
    wideChar = String.fromCharCode(55349, 56632 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text$2, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56476 + _i3);
    defineSymbol(math, main, mathord, _ch3, wideChar);
    defineSymbol(text$2, main, textord, _ch3, wideChar);
  }
}
wideChar = String.fromCharCode(55349, 56668);
defineSymbol(math, main, mathord, "k", wideChar);
defineSymbol(text$2, main, textord, "k", wideChar);
for (var _i4 = 0; _i4 < 10; _i4++) {
  var _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text$2, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57314 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text$2, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57324 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text$2, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57334 + _i4);
  defineSymbol(math, main, mathord, _ch4, wideChar);
  defineSymbol(text$2, main, textord, _ch4, wideChar);
}
var extraLatin = "";
for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math, main, mathord, _ch5, _ch5);
  defineSymbol(text$2, main, textord, _ch5, _ch5);
}
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
];
var wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
];
var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
  var H = wideChar2.charCodeAt(0);
  var L = wideChar2.charCodeAt(1);
  var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
  var j = mode === "math" ? 0 : 1;
  if (119808 <= codePoint && codePoint < 120484) {
    var i = Math.floor((codePoint - 119808) / 26);
    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
  } else if (120782 <= codePoint && codePoint <= 120831) {
    var _i = Math.floor((codePoint - 120782) / 10);
    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
  } else if (codePoint === 120485 || codePoint === 120486) {
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
  } else if (120486 < codePoint && codePoint < 120782) {
    return ["", ""];
  } else {
    throw new ParseError("Unsupported character: " + wideChar2);
  }
};
var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
  if (symbols[mode][value] && symbols[mode][value].replace) {
    value = symbols[mode][value].replace;
  }
  return {
    value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
var makeSymbol = function makeSymbol2(value, fontName, mode, options, classes) {
  var lookup = lookupSymbol(value, fontName, mode);
  var metrics = lookup.metrics;
  value = lookup.value;
  var symbolNode;
  if (metrics) {
    var italic = metrics.italic;
    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }
    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
  }
  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;
    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }
    var color2 = options.getColor();
    if (color2) {
      symbolNode.style.color = color2;
    }
  }
  return symbolNode;
};
var mathsym = function mathsym2(value, mode, options, classes) {
  if (classes === void 0) {
    classes = [];
  }
  if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
    return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
  } else if (value === "\\" || symbols[mode][value].font === "main") {
    return makeSymbol(value, "Main-Regular", mode, options, classes);
  } else {
    return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
  }
};
var boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
  if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
var makeOrd = function makeOrd2(group, options, type) {
  var mode = group.mode;
  var text2 = group.text;
  var classes = ["mord"];
  var isFont = mode === "math" || mode === "text" && options.font;
  var fontOrFamily = isFont ? options.font : options.fontFamily;
  var wideFontName = "";
  var wideFontClass = "";
  if (text2.charCodeAt(0) === 55349) {
    [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
  }
  if (wideFontName.length > 0) {
    return makeSymbol(text2, wideFontName, mode, options, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;
    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text2, mode, options, classes, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }
    if (lookupSymbol(text2, fontName, mode).metrics) {
      return makeSymbol(text2, fontName, mode, options, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
      var parts = [];
      for (var i = 0; i < text2.length; i++) {
        parts.push(makeSymbol(text2[i], fontName, mode, options, classes.concat(fontClasses)));
      }
      return makeFragment(parts);
    }
  }
  if (type === "mathord") {
    return makeSymbol(text2, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text2] && symbols[mode][text2].font;
    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
    } else {
      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
var canCombine = (prev, next) => {
  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
    return false;
  }
  if (prev.classes.length === 1) {
    var cls = prev.classes[0];
    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }
  for (var style in prev.style) {
    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
      return false;
    }
  }
  for (var _style in next.style) {
    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
      return false;
    }
  }
  return true;
};
var tryCombineChars = (chars) => {
  for (var i = 0; i < chars.length - 1; i++) {
    var prev = chars[i];
    var next = chars[i + 1];
    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
      prev.text += next.text;
      prev.height = Math.max(prev.height, next.height);
      prev.depth = Math.max(prev.depth, next.depth);
      prev.italic = next.italic;
      chars.splice(i + 1, 1);
      i--;
    }
  }
  return chars;
};
var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;
  for (var i = 0; i < elem.children.length; i++) {
    var child = elem.children[i];
    if (child.height > height) {
      height = child.height;
    }
    if (child.depth > depth) {
      depth = child.depth;
    }
    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }
  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
var makeSpan$2 = function makeSpan(classes, children, options, style) {
  var span = new Span(classes, children, options, style);
  sizeElementFromChildren(span);
  return span;
};
var makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
var makeLineSpan = function makeLineSpan2(className, options, thickness) {
  var line = makeSpan$2([className], [], options);
  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1;
  return line;
};
var makeAnchor = function makeAnchor2(href, classes, children, options) {
  var anchor = new Anchor(href, classes, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
var makeFragment = function makeFragment2(children) {
  var fragment = new DocumentFragment(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
var wrapFragment = function wrapFragment2(group, options) {
  if (group instanceof DocumentFragment) {
    return makeSpan$2([], [group], options);
  }
  return group;
};
var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]];
    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    var currPos = _depth;
    for (var i = 1; i < oldChildren.length; i++) {
      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size
      });
      children.push(oldChildren[i]);
    }
    return {
      children,
      depth: _depth
    };
  }
  var depth;
  if (params.positionType === "top") {
    var bottom = params.positionData;
    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }
    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];
    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }
    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }
  return {
    children: params.children,
    depth
  };
};
var makeVList = function makeVList2(params, options) {
  var {
    children,
    depth
  } = getVListChildrenAndDepth(params);
  var pstrutSize = 0;
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }
  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize);
  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;
  for (var _i2 = 0; _i2 < children.length; _i2++) {
    var _child = children[_i2];
    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes = _child.wrapperClasses || [];
      var style = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }
      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }
      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos);
  var rows;
  if (minPos < 0) {
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos);
    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }
  var vtable = makeSpan$2(["vlist-t"], rows);
  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }
  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
};
var makeGlue = (measurement, options) => {
  var rule = makeSpan$2(["mspace"], [], options);
  var size = calculateSize(measurement, options);
  rule.style.marginRight = makeEm(size);
  return rule;
};
var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";
  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;
    case "textrm":
      baseFontName = "Main";
      break;
    case "textsf":
      baseFontName = "SansSerif";
      break;
    case "texttt":
      baseFontName = "Typewriter";
      break;
    default:
      baseFontName = fontFamily;
  }
  var fontStylesName;
  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }
  return baseFontName + "-" + fontStylesName;
};
var fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  "mathsfit": {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};
var staticSvg = function staticSvg2(value, options) {
  var [pathName, width, height] = svgData[value];
  var path2 = new PathNode(pathName);
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};
var buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
};
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
};
var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
var _functions = {};
var _htmlGroupBuilders = {};
var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler
  };
  for (var i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }
  if (type) {
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
}
function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  });
}
var normalizeArgument = function normalizeArgument2(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
};
var ordargument = function ordargument2(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
var makeSpan$1 = buildCommon.makeSpan;
var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};
var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }
  var groups = [];
  for (var i = 0; i < expression.length; i++) {
    var output = buildGroup$1(expression[i], options);
    if (output instanceof DocumentFragment) {
      var children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  }
  buildCommon.tryCombineChars(groups);
  if (!isRealGroup) {
    return groups;
  }
  var glueOptions = options;
  if (expression.length === 1) {
    var node = expression[0];
    if (node.type === "sizing") {
      glueOptions = options.havingSize(node.size);
    } else if (node.type === "styling") {
      glueOptions = options.havingStyle(styleMap$1[node.style]);
    }
  }
  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
  var isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node2, prev) => {
    var prevType = prev.classes[0];
    var type = node2.classes[0];
    if (prevType === "mbin" && binRightCanceller.includes(type)) {
      prev.classes[0] = "mord";
    } else if (type === "mbin" && binLeftCanceller.includes(prevType)) {
      node2.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node2, prev) => {
    var prevType = getTypeOfDomTree(prev);
    var type = getTypeOfDomTree(node2);
    var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
    if (space) {
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
};
var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
  if (next) {
    nodes.push(next);
  }
  var i = 0;
  for (; i < nodes.length; i++) {
    var node = nodes[i];
    var partialGroup = checkPartialGroup(node);
    if (partialGroup) {
      traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
      continue;
    }
    var nonspace = !node.hasClass("mspace");
    if (nonspace) {
      var result = callback(node, prev.node);
      if (result) {
        if (prev.insertAfter) {
          prev.insertAfter(result);
        } else {
          nodes.unshift(result);
          i++;
        }
      }
    }
    if (nonspace) {
      prev.node = node;
    } else if (isRoot && node.hasClass("newline")) {
      prev.node = makeSpan$1(["leftmost"]);
    }
    prev.insertAfter = /* @__PURE__ */ ((index) => (n) => {
      nodes.splice(index + 1, 0, n);
      i++;
    })(i);
  }
  if (next) {
    nodes.pop();
  }
};
var checkPartialGroup = function checkPartialGroup2(node) {
  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
    return node;
  }
  return null;
};
var getOutermostNode = function getOutermostNode2(node, side) {
  var partialGroup = checkPartialGroup(node);
  if (partialGroup) {
    var children = partialGroup.children;
    if (children.length) {
      if (side === "right") {
        return getOutermostNode2(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode2(children[0], "left");
      }
    }
  }
  return node;
};
var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
  if (!node) {
    return null;
  }
  if (side) {
    node = getOutermostNode(node, side);
  }
  return DomEnum[node.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
  var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return makeSpan$1(classes.concat(moreClasses));
};
var buildGroup$1 = function buildGroup(group, options, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }
  if (_htmlGroupBuilders[group.type]) {
    var groupNode = _htmlGroupBuilders[group.type](group, options);
    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }
    return groupNode;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildHTMLUnbreakable(children, options) {
  var body = makeSpan$1(["base"], children, options);
  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);
  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }
  body.children.unshift(strut);
  return body;
}
function buildHTML(tree, options) {
  var tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }
  var expression = buildExpression$1(tree, options, "root");
  var eqnNum;
  if (expression.length === 2 && expression[1].hasClass("tag")) {
    eqnNum = expression.pop();
  }
  var children = [];
  var parts = [];
  for (var i = 0; i < expression.length; i++) {
    parts.push(expression[i]);
    if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
      var nobreak = false;
      while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
        i++;
        parts.push(expression[i]);
        if (expression[i].hasClass("nobreak")) {
          nobreak = true;
        }
      }
      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
    } else if (expression[i].hasClass("newline")) {
      parts.pop();
      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
      children.push(expression[i]);
    }
  }
  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options));
  }
  var tagChild;
  if (tag) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }
  var htmlNode = makeSpan$1(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true");
  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }
  return htmlNode;
}
function newDocumentFragment(children) {
  return new DocumentFragment(children);
}
class MathNode {
  constructor(type, children, classes) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value) {
    this.attributes[name] = value;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (var i = 0; i < this.children.length; i++) {
      if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
        var text2 = this.children[i].toText() + this.children[++i].toText();
        while (this.children[i + 1] instanceof TextNode) {
          text2 += this.children[++i].toText();
        }
        node.appendChild(new TextNode(text2).toNode());
      } else {
        node.appendChild(this.children[i].toNode());
      }
    }
    return node;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var markup = "<" + this.type;
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils$1.escape(this.attributes[attr]);
        markup += '"';
      }
    }
    if (this.classes.length > 0) {
      markup += ' class ="' + utils$1.escape(createClass(this.classes)) + '"';
    }
    markup += ">";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}
class TextNode {
  constructor(text2) {
    this.text = void 0;
    this.text = text2;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils$1.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class SpaceNode {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width;
    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "";
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "";
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "";
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "";
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "";
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "";
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "";
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "";
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node.setAttribute("width", makeEm(this.width));
      return node;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return '<mspace width="' + makeEm(this.width) + '"/>';
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }
}
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
};
var makeText = function makeText2(text2, mode, options) {
  if (symbols[mode][text2] && symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
    text2 = symbols[mode][text2].replace;
  }
  return new mathMLTree.TextNode(text2);
};
var makeRow = function makeRow2(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
var getVariant = function getVariant2(group, options) {
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }
  var font = options.font;
  if (!font || font === "mathnormal") {
    return null;
  }
  var mode = group.mode;
  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathsfit") {
    return "sans-serif-italic";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }
  var text2 = group.text;
  if (["\\imath", "\\jmath"].includes(text2)) {
    return null;
  }
  if (symbols[mode][text2] && symbols[mode][text2].replace) {
    text2 = symbols[mode][text2].replace;
  }
  var fontName = buildCommon.fontMap[font].fontName;
  if (getCharacterMetrics(text2, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }
  return null;
};
function isNumberPunctuation(group) {
  if (!group) {
    return false;
  }
  if (group.type === "mi" && group.children.length === 1) {
    var child = group.children[0];
    return child instanceof TextNode && child.text === ".";
  } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
    var _child = group.children[0];
    return _child instanceof TextNode && _child.text === ",";
  } else {
    return false;
  }
}
var buildExpression2 = function buildExpression3(expression, options, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup2(expression[0], options);
    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }
  var groups = [];
  var lastGroup;
  for (var i = 0; i < expression.length; i++) {
    var _group = buildGroup2(expression[i], options);
    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (isNumberPunctuation(_group) && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && isNumberPunctuation(lastGroup)) {
        _group.children = [...lastGroup.children, ..._group.children];
        groups.pop();
      } else if ((_group.type === "msup" || _group.type === "msub") && _group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
        var base2 = _group.children[0];
        if (base2 instanceof MathNode && base2.type === "mn") {
          base2.children = [...lastGroup.children, ...base2.children];
          groups.pop();
        }
      } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];
        if (lastChild instanceof TextNode && lastChild.text === "" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
          var child = _group.children[0];
          if (child instanceof TextNode && child.text.length > 0) {
            child.text = child.text.slice(0, 1) + "" + child.text.slice(1);
            groups.pop();
          }
        }
      }
    }
    groups.push(_group);
    lastGroup = _group;
  }
  return groups;
};
var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
  return makeRow(buildExpression2(expression, options, isOrdgroup));
};
var buildGroup2 = function buildGroup3(group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }
  if (_mathmlGroupBuilders[group.type]) {
    var result = _mathmlGroupBuilders[group.type](group, options);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression2(tree, options);
  var wrapper;
  if (expression.length === 1 && expression[0] instanceof MathNode && ["mrow", "mtable"].includes(expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }
  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math2 = new mathMLTree.MathNode("math", [semantics]);
  math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  if (isDisplayMode) {
    math2.setAttribute("display", "block");
  }
  var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([wrapperClass], [math2]);
}
var optionsFromSettings = function optionsFromSettings2(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};
var displayWrap = function displayWrap2(node, settings) {
  if (settings.displayMode) {
    var classes = ["katex-display"];
    if (settings.leqno) {
      classes.push("leqno");
    }
    if (settings.fleqn) {
      classes.push("fleqn");
    }
    node = buildCommon.makeSpan(classes, [node]);
  }
  return node;
};
var buildTree = function buildTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var katexNode;
  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
    var _htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }
  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "",
  underleftarrow: "",
  xleftarrow: "",
  overrightarrow: "",
  underrightarrow: "",
  xrightarrow: "",
  underbrace: "",
  overbrace: "",
  overgroup: "",
  undergroup: "",
  overleftrightarrow: "",
  underleftrightarrow: "",
  xleftrightarrow: "",
  Overrightarrow: "",
  xRightarrow: "",
  overleftharpoon: "",
  xleftharpoonup: "",
  overrightharpoon: "",
  xrightharpoonup: "",
  xLeftarrow: "",
  xLeftrightarrow: "",
  xhookleftarrow: "",
  xhookrightarrow: "",
  xmapsto: "",
  xrightharpoondown: "",
  xleftharpoondown: "",
  xrightleftharpoons: "",
  xleftrightharpoons: "",
  xtwoheadleftarrow: "",
  xtwoheadrightarrow: "",
  xlongequal: "=",
  xtofrom: "",
  xrightleftarrows: "",
  xrightequilibrium: "",
  // Not a perfect match.
  xleftequilibrium: "",
  // None better available.
  "\\cdrightarrow": "",
  "\\cdleftarrow": "",
  "\\cdlongequal": "="
};
var mathMLnode = function mathMLnode2(label) {
  var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
  node.setAttribute("stretchy", "true");
  return node;
};
var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};
var groupLength = function groupLength2(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};
var svgSpan = function svgSpan2(group, options) {
  function buildSvgSpan_() {
    var viewBoxWidth = 4e5;
    var label = group.label.slice(1);
    if (["widehat", "widecheck", "widetilde", "utilde"].includes(label)) {
      var grp = group;
      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;
      var _height;
      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }
      var path2 = new PathNode(pathName);
      var svgNode = new SvgNode([path2], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data = katexImagesData[label];
      var [paths, _minWidth, _viewBoxHeight] = data;
      var _height2 = _viewBoxHeight / 1e3;
      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;
      if (numSvgChildren === 1) {
        var align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }
      for (var i = 0; i < numSvgChildren; i++) {
        var _path = new PathNode(paths[i]);
        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i] + " slice"
        });
        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);
        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth: _minWidth,
        height: _height2
      };
    }
  }
  var {
    span,
    minWidth,
    height
  } = buildSvgSpan_();
  span.height = height;
  span.style.height = makeEm(height);
  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }
  return span;
};
var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
  var img;
  var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);
    if (label === "fbox") {
      var color2 = options.color && options.getColor();
      if (color2) {
        img.style.borderColor = color2;
      }
    }
  } else {
    var lines = [];
    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }
    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }
    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }
  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};
var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
  }
  return node;
}
function assertSymbolNodeType(node) {
  var typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
  }
  return typedNode;
}
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
    return node;
  }
  return null;
}
var htmlBuilder$a = (grp, options) => {
  var base2;
  var group;
  var supSubGroup;
  if (grp && grp.type === "supsub") {
    group = assertNodeType(grp.base, "accent");
    base2 = group.base;
    grp.base = base2;
    supSubGroup = assertSpan(buildGroup$1(grp, options));
    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base2 = group.base;
  }
  var body = buildGroup$1(base2, options.havingCrampedStyle());
  var mustShift = group.isShifty && utils$1.isCharacterBox(base2);
  var skew2 = 0;
  if (mustShift) {
    var baseChar = utils$1.getBaseElem(base2);
    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
    skew2 = assertSymbolDomNode(baseGroup).skew;
  }
  var accentBelow = group.label === "\\c";
  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
  var accentBody;
  if (!group.isStretchy) {
    var accent2;
    var width;
    if (group.label === "\\vec") {
      accent2 = buildCommon.staticSvg("vec", options);
      width = buildCommon.svgData.vec[1];
    } else {
      accent2 = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options, "textord");
      accent2 = assertSymbolDomNode(accent2);
      accent2.italic = 0;
      width = accent2.width;
      if (accentBelow) {
        clearance += accent2.depth;
      }
    }
    accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
    var accentFull = group.label === "\\textcircled";
    if (accentFull) {
      accentBody.classes.push("accent-full");
      clearance = body.height;
    }
    var left = skew2;
    if (!accentFull) {
      left -= width / 2;
    }
    accentBody.style.left = makeEm(left);
    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew2 > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew2) + ")",
          marginLeft: makeEm(2 * skew2)
        } : void 0
      }]
    }, options);
  }
  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
  if (supSubGroup) {
    supSubGroup.children[0] = accentWrap;
    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};
var mathmlBuilder$9 = (group, options) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options), accentNode]);
  node.setAttribute("accent", "true");
  return node;
};
var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    var base2 = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy,
      isShifty,
      base: base2
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var base2 = args[0];
    var mode = context.parser.mode;
    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }
    return {
      type: "accent",
      mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base: base2
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var base2 = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base2
    };
  },
  htmlBuilder: (group, options) => {
    var innerGroup = buildGroup$1(group.base, options);
    var accentBody = stretchy.svgSpan(group, options);
    var kern = group.label === "\\utilde" ? 0.12 : 0;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: (group, options) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options), accentNode]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
var paddedNode = (group) => {
  var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node.setAttribute("width", "+0.6em");
  node.setAttribute("lspace", "0.3em");
  return node;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(group, options) {
    var style = options.style;
    var newOptions = options.havingStyle(style.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;
    if (group.below) {
      newOptions = options.havingStyle(style.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }
    var arrowBody = stretchy.svgSpan(group, options);
    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth;
    }
    var vlist;
    if (lowerGroup) {
      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    }
    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node;
    if (group.body) {
      var upperNode = paddedNode(buildGroup2(group.body, options));
      if (group.below) {
        var lowerNode = paddedNode(buildGroup2(group.below, options));
        node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup2(group.below, options));
      node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      node = paddedNode();
      node = new mathMLTree.MathNode("mover", [arrowNode, node]);
    }
    return node;
  }
});
var makeSpan2 = buildCommon.makeSpan;
function htmlBuilder$9(group, options) {
  var elements = buildExpression$1(group.body, options, true);
  return makeSpan2([group.mclass], elements, options);
}
function mathmlBuilder$8(group, options) {
  var node;
  var inner2 = buildExpression2(group.body, options);
  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner2);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mi";
    } else {
      node = new mathMLTree.MathNode("mi", inner2);
    }
  } else {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mo";
    } else {
      node = new mathMLTree.MathNode("mo", inner2);
    }
    if (group.mclass === "mbin") {
      node.attributes.lspace = "0.22em";
      node.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0.17em";
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node.attributes.lspace = "0.0556em";
      node.attributes.width = "+0.1111em";
    }
  }
  return node;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils$1.isCharacterBox(body)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (arg) => {
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils$1.isCharacterBox(args[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(_ref3, args) {
    var {
      parser,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;
    if (funcName !== "\\stackrel") {
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel";
    }
    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils$1.isCharacterBox(supsub)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "pmb",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, true);
    var node = buildCommon.makeSpan([group.mclass], elements, options);
    node.style.textShadow = "0.02em 0.01em 0.04px";
    return node;
  },
  mathmlBuilder(group, style) {
    var inner2 = buildExpression2(group.body, style);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var newCell = () => {
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};
var isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};
var isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};
function cdArrow(arrowChar, labels, parser) {
  var funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      var bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      var arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel]
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var arrow = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(parser) {
  var parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    var next = parser.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop();
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  var row = [];
  var body = [row];
  for (var i = 0; i < parsedRows.length; i++) {
    var rowNodes = parsedRows[i];
    var cell = newCell();
    for (var j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        cell.body.push(rowNodes[j]);
      } else {
        row.push(cell);
        j += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        if ("=|.".indexOf(arrowChar) > -1) ;
        else if ("<>AV".indexOf(arrowChar) > -1) {
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;
            for (var k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
              }
              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
            }
          }
        } else {
          throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
        }
        var arrow = cdArrow(arrowChar, labels, parser);
        var wrappedArrow = {
          type: "styling",
          body: [arrow],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        row.push(wrappedArrow);
        cell = newCell();
      }
    }
    if (i % 2 === 0) {
      row.push(cell);
    } else {
      row.shift();
    }
    row = [];
    body.push(row);
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  htmlBuilder(group, options) {
    var newOptions = options.havingStyle(options.style.sup());
    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth);
    label.height = 0;
    label.depth = 0;
    return label;
  },
  mathmlBuilder(group, options) {
    var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");
    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    }
    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  htmlBuilder(group, options) {
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number2 = "";
    for (var i = 0; i < group.length; i++) {
      var node = assertNodeType(group[i], "textord");
      number2 += node.text;
    }
    var code2 = parseInt(number2);
    var text2;
    if (isNaN(code2)) {
      throw new ParseError("\\@char has non-numeric argument " + number2);
    } else if (code2 < 0 || code2 >= 1114111) {
      throw new ParseError("\\@char with invalid code point " + number2);
    } else if (code2 <= 65535) {
      text2 = String.fromCharCode(code2);
    } else {
      code2 -= 65536;
      text2 = String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: text2
    };
  }
});
var htmlBuilder$8 = (group, options) => {
  var elements = buildExpression$1(group.body, options.withColor(group.color), false);
  return buildCommon.makeFragment(elements);
};
var mathmlBuilder$7 = (group, options) => {
  var inner2 = buildExpression2(group.body, options.withColor(group.color));
  var node = new mathMLTree.MathNode("mstyle", inner2);
  node.setAttribute("mathcolor", group.color);
  return node;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var color2 = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color: color2,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },
  handler(_ref2, args) {
    var {
      parser,
      breakOnTokenText
    } = _ref2;
    var color2 = assertNodeType(args[0], "color-token").color;
    parser.gullet.macros.set("\\current@color", color2);
    var body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color: color2,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options) {
    var span = buildCommon.makeSpan(["mspace"], [], options);
    if (group.newLine) {
      span.classes.push("newline");
      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options));
      }
    }
    return span;
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mspace");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        node.setAttribute("height", makeEm(calculateSize(group.size, options)));
      }
    }
    return node;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var checkControlSequence = (tok) => {
  var name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};
var getRHS = (parser) => {
  var tok = parser.gullet.popToken();
  if (tok.text === "=") {
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};
var letCommand = (parser, name, tok, global) => {
  var macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser,
      funcName
    } = _ref;
    parser.consumeSpaces();
    var token = parser.fetch();
    if (globalMap[token.text]) {
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError("Invalid token after macro prefix", token);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref2) {
    var {
      parser,
      funcName
    } = _ref2;
    var tok = parser.gullet.popToken();
    var name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }
    var numArgs = 0;
    var insert;
    var delimiters2 = [[]];
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters2[numArgs].push("{");
          break;
        }
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError('Invalid argument number "' + tok.text + '"');
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError('Argument number "' + tok.text + '" out of order');
        }
        numArgs++;
        delimiters2.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters2[numArgs].push(tok.text);
      }
    }
    var {
      tokens
    } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }
    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      tokens.reverse();
    }
    parser.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters: delimiters2
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    var name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    var tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    var name = checkControlSequence(parser.gullet.popToken());
    var middle = parser.gullet.popToken();
    var tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
var getMetrics = function getMetrics2(symbol, font, mode) {
  var replace2 = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace2 || symbol, font, mode);
  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }
  return metrics;
};
var styleWrap = function styleWrap2(delim, toStyle, options, classes) {
  var newOptions = options.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};
var centerSpan = function centerSpan2(span, options, style) {
  var newOptions = options.havingBaseStyle(style);
  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
var makeSmallDelim = function makeSmallDelim2(delim, style, center, options, mode, classes) {
  var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  var span = styleWrap(text2, style, options, classes);
  if (center) {
    centerSpan(span, options, style);
  }
  return span;
};
var mathrmSize = function mathrmSize2(value, size, mode, options) {
  return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
};
var makeLargeDelim = function makeLargeDelim2(delim, size, center, options, mode, classes) {
  var inner2 = mathrmSize(delim, size, mode, options);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), Style$1.TEXT, options, classes);
  if (center) {
    centerSpan(span, options, Style$1.TEXT);
  }
  return span;
};
var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
  var sizeClass;
  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else {
    sizeClass = "delim-size4";
  }
  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
  return {
    type: "elem",
    elem: corner
  };
};
var makeInner = function makeInner2(ch, height, options) {
  var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
  var path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
};
var lapInEms = 8e-3;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
  var top;
  var middle;
  var repeat;
  var bottom;
  var svgLabel = "";
  var viewBoxWidth = 0;
  top = repeat = bottom = delim;
  middle = null;
  var font = "Size1-Regular";
  if (delim === "\\uparrow") {
    repeat = bottom = "";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "";
  } else if (delim === "\\downarrow") {
    top = repeat = "";
  } else if (delim === "\\Downarrow") {
    top = repeat = "";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "";
    bottom = "\\Downarrow";
  } else if (verts.includes(delim)) {
    repeat = "";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (doubleVerts.includes(delim)) {
    repeat = "";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "") {
    repeat = top = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "") {
    top = "";
    repeat = bottom = "";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "") {
    repeat = top = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "") {
    top = "";
    repeat = bottom = "";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "";
    middle = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "";
    middle = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  }
  var topMetrics = getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;
  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  var axisHeight = options.fontMetrics().axisHeight;
  if (center) {
    axisHeight *= options.sizeMultiplier;
  }
  var depth = realHeightTotal / 2 - axisHeight;
  var stack = [];
  if (svgLabel.length > 0) {
    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    var viewBoxHeight = Math.round(realHeightTotal * 1e3);
    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
    var path2 = new PathNode(svgLabel, pathStr);
    var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
    var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
    var svg = new SvgNode([path2], {
      "width": width,
      "height": height,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    var wrapper = buildCommon.makeSvgSpan([], [svg], options);
    wrapper.height = viewBoxHeight / 1e3;
    wrapper.style.width = width;
    wrapper.style.height = height;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    stack.push(makeGlyphSpan(bottom, font, mode));
    stack.push(lap);
    if (middle === null) {
      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options));
    } else {
      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
      stack.push(makeInner(repeat, _innerHeight, options));
      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat, _innerHeight, options));
    }
    stack.push(lap);
    stack.push(makeGlyphSpan(top, font, mode));
  }
  var newOptions = options.havingBaseStyle(Style$1.TEXT);
  var inner2 = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options, classes);
};
var vbPad = 80;
var emPad = 0.08;
var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options) {
  var path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path2);
  var svg = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
};
var makeSqrtImage = function makeSqrtImage2(height, options) {
  var newOptions = options.havingBaseSizing();
  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier;
  var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth;
  if (delim.type === "small") {
    viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
    if (height < 1) {
      sizeMultiplier = 1;
    } else if (height < 1.4) {
      sizeMultiplier = 0.7;
    }
    spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
    texHeight = (1 + extraVinculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier;
  } else if (delim.type === "large") {
    viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1 / sizeMultiplier;
  } else {
    spanHeight = height + extraVinculum + emPad;
    texHeight = height + extraVinculum;
    viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }
  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
  };
};
var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"];
var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""];
var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
var makeSizedDelim = function makeSizedDelim2(delim, size, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "") {
    delim = "\\rangle";
  }
  if (stackLargeDelimiters.includes(delim) || stackNeverDelimiters.includes(delim)) {
    return makeLargeDelim(delim, size, false, options, mode, classes);
  } else if (stackAlwaysDelimiters.includes(delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
  } else {
    throw new ParseError("Illegal delimiter: '" + delim + "'");
  }
};
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}];
var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}];
var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
var delimTypeToFont = function delimTypeToFont2(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
  var start = Math.min(2, 3 - options.style.size);
  for (var i = start; i < sequence.length; i++) {
    if (sequence[i].type === "stack") {
      break;
    }
    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
    var heightDepth = metrics.height + metrics.depth;
    if (sequence[i].type === "small") {
      var newOptions = options.havingBaseStyle(sequence[i].style);
      heightDepth *= newOptions.sizeMultiplier;
    }
    if (heightDepth > height) {
      return sequence[i];
    }
  }
  return sequence[sequence.length - 1];
};
var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "") {
    delim = "\\rangle";
  }
  var sequence;
  if (stackNeverDelimiters.includes(delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (stackLargeDelimiters.includes(delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  var delimType = traverseSequence(delim, height, sequence, options);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
  } else {
    return makeStackedDelim(delim, height, center, options, mode, classes);
  }
};
var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
  var delimiterFactor = 901;
  var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    maxDistFromAxis / 500 * delimiterFactor,
    2 * maxDistFromAxis - delimiterExtend
  );
  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
};
var delimiter$1 = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);
  if (symDelim && delimiters.includes(symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    if (group.delim === ".") {
      return buildCommon.makeSpan([group.mclass]);
    }
    return delimiter$1.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: (group) => {
    var children = [];
    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }
    var node = new mathMLTree.MathNode("mo", children);
    if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.setAttribute("fence", "true");
    } else {
      node.setAttribute("fence", "false");
    }
    node.setAttribute("stretchy", "true");
    var size = makeEm(delimiter$1.sizeToMaxHeight[group.size]);
    node.setAttribute("minsize", size);
    node.setAttribute("maxsize", size);
    return node;
  }
});
function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var color2 = context.parser.gullet.macros.get("\\current@color");
    if (color2 && typeof color2 !== "string") {
      throw new ParseError("\\current@color set to non-string in \\right");
    }
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color: color2
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    var parser = context.parser;
    ++parser.leftrightDepth;
    var body = parser.parseExpression(false);
    --parser.leftrightDepth;
    parser.expect("\\right", false);
    var right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;
    for (var i = 0; i < inner2.length; i++) {
      if (inner2[i].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner2[i].height, innerHeight);
        innerDepth = Math.max(inner2[i].depth, innerDepth);
      }
    }
    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    var leftDelim;
    if (group.left === ".") {
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      leftDelim = delimiter$1.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    }
    inner2.unshift(leftDelim);
    if (hadMiddle) {
      for (var _i = 1; _i < inner2.length; _i++) {
        var middleDelim = inner2[_i];
        var isMiddle = middleDelim.isMiddle;
        if (isMiddle) {
          inner2[_i] = delimiter$1.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }
    var rightDelim;
    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
      rightDelim = delimiter$1.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    }
    inner2.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner2, options);
  },
  mathmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression2(group.body, options);
    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner2.unshift(leftNode);
    }
    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }
      inner2.push(rightNode);
    }
    return makeRow(inner2);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }
    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    var middleDelim;
    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter$1.sizedDelim(group.delim, 1, options, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options
      };
      middleDelim.isMiddle = isMiddle;
    }
    return middleDelim;
  },
  mathmlBuilder: (group, options) => {
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
var htmlBuilder$7 = (group, options) => {
  var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
  var label = group.label.slice(1);
  var scale = options.sizeMultiplier;
  var img;
  var imgShift = 0;
  var isSingleChar = utils$1.isCharacterBox(group.body);
  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else if (label === "phase") {
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options);
    var newOptions = options.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
    inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
    var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
    var path2 = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path2)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1e3),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
    img.style.height = makeEm(angleHeight);
    imgShift = inner2.depth + lineWeight + clearance;
  } else {
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner2.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner2.classes.push("anglpad");
    } else {
      inner2.classes.push("boxpad");
    }
    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0;
    if (/box/.test(label)) {
      ruleThickness = Math.max(
        options.fontMetrics().fboxrule,
        // default
        options.minRuleThickness
        // User override.
      );
      topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      topPad = 4 * ruleThickness;
      bottomPad = Math.max(0, 0.25 - inner2.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }
    img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }
    imgShift = inner2.depth + bottomPad;
    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;
      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }
  var vlist;
  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: img,
          shift: imgShift
        },
        {
          type: "elem",
          elem: inner2,
          shift: 0
        }
      ]
    }, options);
  } else {
    var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: inner2,
          shift: 0
        },
        {
          type: "elem",
          elem: img,
          shift: imgShift,
          wrapperClasses: classes
        }
      ]
    }, options);
  }
  if (/cancel/.test(label)) {
    vlist.height = inner2.height;
    vlist.depth = inner2.depth;
  }
  if (/cancel/.test(label) && !isSingleChar) {
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};
var mathmlBuilder$6 = (group, options) => {
  var fboxsep = 0;
  var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options)]);
  switch (group.label) {
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      node.setAttribute("notation", "box");
      break;
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
      node.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node.setAttribute("lspace", fboxsep + "pt");
      node.setAttribute("voffset", fboxsep + "pt");
      if (group.label === "\\fcolorbox") {
        var thk = Math.max(
          options.fontMetrics().fboxrule,
          // default
          options.minRuleThickness
          // user override
        );
        node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }
      break;
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    var color2 = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color2,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },
  handler(_ref2, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler(_ref3, args) {
    var {
      parser
    } = _ref3;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(_ref4, args) {
    var {
      parser,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },
  handler(_ref5, args) {
    var {
      parser
    } = _ref5;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\angl",
      body: args[0]
    };
  }
});
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (var i = 0; i < names.length; ++i) {
    _environments[names[i]] = data;
  }
  if (htmlBuilder3) {
    _htmlGroupBuilders[type] = htmlBuilder3;
  }
  if (mathmlBuilder3) {
    _mathmlGroupBuilders[type] = mathmlBuilder3;
  }
}
var _macros = {};
function defineMacro(name, body) {
  _macros[name] = body;
}
function getHLines(parser) {
  var hlineInfo = [];
  parser.consumeSpaces();
  var nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}
var validateAmsEnvironmentContext = (context) => {
  var settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError("{" + context.envName + "} can be used only in display mode.");
  }
};
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
}
function parseArray(parser, _ref, style) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser.gullet.beginGroup();
  if (!singleRow) {
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }
  if (!arraystretch) {
    var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
    if (stretch == null) {
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);
      if (!arraystretch || arraystretch < 0) {
        throw new ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  }
  parser.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  var tags = autoTag != null ? [] : void 0;
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token$1("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", void 0, true);
      } else {
        tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();
  hLinesBeforeRow.push(getHLines(parser));
  while (true) {
    var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };
    if (style) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style,
        body: [cell]
      };
    }
    row.push(cell);
    var next = parser.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          throw new ParseError("Too many tab characters: &", parser.nextToken);
        } else {
          parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
        }
      }
      parser.consume();
    } else if (next === "\\end") {
      endRow();
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser.consume();
      var size = void 0;
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();
      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
}
function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}
var htmlBuilder$6 = function htmlBuilder(group, options) {
  var r;
  var c;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    options.fontMetrics().arrayRuleWidth,
    options.minRuleThickness
    // User override.
  );
  var pt = 1 / options.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt;
  if (group.colSeparationType && group.colSeparationType === "small") {
    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
  }
  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options) : 12 * pt;
  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip;
  var arstrutDepth = 0.3 * arrayskip;
  var totalHeight = 0;
  function setHLinePos(hlinesInGap) {
    for (var i = 0; i < hlinesInGap.length; ++i) {
      if (i > 0) {
        totalHeight += 0.25;
      }
      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i]
      });
    }
  }
  setHLinePos(hLinesBeforeRow[0]);
  for (r = 0; r < group.body.length; ++r) {
    var inrow = group.body[r];
    var height = arstrutHeight;
    var depth = arstrutDepth;
    if (nc < inrow.length) {
      nc = inrow.length;
    }
    var outrow = new Array(inrow.length);
    for (c = 0; c < inrow.length; ++c) {
      var elt = buildGroup$1(inrow[c], options);
      if (depth < elt.depth) {
        depth = elt.depth;
      }
      if (height < elt.height) {
        height = elt.height;
      }
      outrow[c] = elt;
    }
    var rowGap = group.rowGaps[r];
    var gap = 0;
    if (rowGap) {
      gap = calculateSize(rowGap, options);
      if (gap > 0) {
        gap += arstrutDepth;
        if (depth < gap) {
          depth = gap;
        }
        gap = 0;
      }
    }
    if (group.addJot) {
      depth += jot;
    }
    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap;
    body[r] = outrow;
    setHLinePos(hLinesBeforeRow[r + 1]);
  }
  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var tagSpans = [];
  if (group.tags && group.tags.some((tag2) => tag2)) {
    for (r = 0; r < nr; ++r) {
      var rw = body[r];
      var shift = rw.pos - offset;
      var tag = group.tags[r];
      var tagSpan = void 0;
      if (tag === true) {
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
      } else if (tag === false) {
        tagSpan = buildCommon.makeSpan([], [], options);
      } else {
        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
      }
      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift
      });
    }
  }
  for (
    c = 0, colDescrNum = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    c < nc || colDescrNum < colDescriptions.length;
    ++c, ++colDescrNum
  ) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;
    while (colDescr.type === "separator") {
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }
      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        var _shift = totalHeight - offset;
        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }
        cols.push(separator);
      } else {
        throw new ParseError("Invalid separator type: " + colDescr.separator);
      }
      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }
    if (c >= nc) {
      continue;
    }
    var sepwidth = void 0;
    if (c > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils$1.deflt(colDescr.pregap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
    var col = [];
    for (r = 0; r < nr; ++r) {
      var row = body[r];
      var elem = row[c];
      if (!elem) {
        continue;
      }
      var _shift2 = row.pos - offset;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem,
        shift: _shift2
      });
    }
    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);
    if (c < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils$1.deflt(colDescr.postgap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }
  body = buildCommon.makeSpan(["mtable"], cols);
  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];
    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset;
      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }
    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }
  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};
var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};
var mathmlBuilder$5 = function mathmlBuilder(group, options) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
  for (var i = 0; i < group.body.length; i++) {
    var rw = group.body[i];
    var row = [];
    for (var j = 0; j < rw.length; j++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j], options)]));
    }
    if (group.tags && group.tags[i]) {
      row.unshift(glue);
      row.push(glue);
      if (group.leqno) {
        row.unshift(tag);
      } else {
        row.push(tag);
      }
    }
    tbl.push(new mathMLTree.MathNode("mtr", row));
  }
  var table2 = new mathMLTree.MathNode("mtable", tbl);
  var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table2.setAttribute("rowspacing", makeEm(gap));
  var menclose = "";
  var align = "";
  if (group.cols && group.cols.length > 0) {
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;
    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }
    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }
    for (var _i = iStart; _i < iEnd; _i++) {
      if (cols[_i].type === "align") {
        align += alignMap[cols[_i].align];
        if (prevTypeWasAlign) {
          columnLines += "none ";
        }
        prevTypeWasAlign = true;
      } else if (cols[_i].type === "separator") {
        if (prevTypeWasAlign) {
          columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }
    table2.setAttribute("columnalign", align.trim());
    if (/[sd]/.test(columnLines)) {
      table2.setAttribute("columnlines", columnLines.trim());
    }
  }
  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];
    var spacing2 = "";
    for (var _i2 = 1; _i2 < _cols.length; _i2++) {
      spacing2 += _i2 % 2 ? "0em " : "1em ";
    }
    table2.setAttribute("columnspacing", spacing2.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table2.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table2.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table2.setAttribute("columnspacing", "0.5em");
  } else {
    table2.setAttribute("columnspacing", "1em");
  }
  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
    rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
  }
  if (/[sd]/.test(rowLines)) {
    table2.setAttribute("rowlines", rowLines.trim());
  }
  if (menclose !== "") {
    table2 = new mathMLTree.MathNode("menclose", [table2]);
    table2.setAttribute("notation", menclose.trim());
  }
  if (group.arraystretch && group.arraystretch < 1) {
    table2 = new mathMLTree.MathNode("mstyle", [table2]);
    table2.setAttribute("scriptlevel", "1");
  }
  return table2;
};
var alignedHandler = function alignedHandler2(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  var cols = [];
  var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  var isSplit = context.envName === "split";
  var res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? void 0 : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : void 0,
    leqno: context.parser.settings.leqno
  }, "display");
  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };
  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";
    for (var i = 0; i < args[0].body.length; i++) {
      var textord2 = assertNodeType(args[0].body[i], "textord");
      arg0 += textord2.text;
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  var isAligned = !numCols;
  res.body.forEach(function(row) {
    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
      var styling = assertNodeType(row[_i4], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }
    if (!isAligned) {
      var curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      numCols = row.length;
    }
  });
  for (var _i5 = 0; _i5 < numCols; ++_i5) {
    var align = "r";
    var pregap = 0;
    if (_i5 % 2 === 1) {
      align = "l";
    } else if (_i5 > 0 && isAligned) {
      pregap = 1;
    }
    cols[_i5] = {
      type: "align",
      align,
      pregap,
      postgap: 0
    };
  }
  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var delimiters2 = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      var parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    var numCols = Math.max(0, ...res.body.map((row) => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters2 ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters2[0],
      right: delimiters2[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (["gather", "gather*"].includes(context.envName)) {
      validateAmsEnvironmentContext(context);
    }
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    var res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(context.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    var envName = "";
    for (var i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }
    if (funcName === "\\begin") {
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      var env = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser.parseArguments("\\begin{" + envName + "}", env);
      var context = {
        mode: parser.mode,
        envName,
        parser
      };
      var result = env.handler(context, _args, optArgs);
      parser.expect("\\end", false);
      var endNameToken = parser.nextToken;
      var end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      }
      return result;
    }
    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});
var htmlBuilder$5 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup$1(group.body, newOptions);
};
var mathmlBuilder$4 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup2(group.body, newOptions);
};
var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    var isCharacterBox3 = utils$1.isCharacterBox(body);
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox3
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = "math" + funcName.slice(1);
    return {
      type: "font",
      mode,
      font: style,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (size, originalStyle) => {
  var style = originalStyle;
  if (size === "display") {
    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
  } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
    style = Style$1.TEXT;
  } else if (size === "script") {
    style = Style$1.SCRIPT;
  } else if (size === "scriptscript") {
    style = Style$1.SCRIPTSCRIPT;
  }
  return style;
};
var htmlBuilder$4 = (group, options) => {
  var style = adjustStyle(group.size, options.style);
  var nstyle = style.fracNum();
  var dstyle = style.fracDen();
  var newOptions;
  newOptions = options.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options);
  if (group.continued) {
    var hStrut = 8.5 / options.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }
  newOptions = options.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options);
  var rule;
  var ruleWidth;
  var ruleSpacing;
  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options);
      rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options);
    }
    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  }
  var numShift;
  var clearance;
  var denomShift;
  if (style.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;
    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom2;
  }
  var frac;
  if (!rule) {
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    var axisHeight = options.fontMetrics().axisHeight;
    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }
    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }
    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  }
  newOptions = options.havingStyle(style);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
  var delimSize;
  if (style.size === Style$1.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options.fontMetrics().delim2;
  }
  var leftDelim;
  var rightDelim;
  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter$1.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
  }
  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]);
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter$1.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
  }
  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};
var mathmlBuilder$3 = (group, options) => {
  var node = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options), buildGroup2(group.denom, options)]);
  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options);
    node.setAttribute("linethickness", makeEm(ruleWidth));
  }
  var style = adjustStyle(group.size, options.style);
  if (style.size !== options.style.size) {
    node = new mathMLTree.MathNode("mstyle", [node]);
    var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
    node.setAttribute("displaystyle", isDisplay);
    node.setAttribute("scriptlevel", "0");
  }
  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];
    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }
    withDelims.push(node);
    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }
    return makeRow(withDelims);
  }
  return node;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";
    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName,
      token
    } = _ref3;
    var replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];
var delimFromValue = function delimFromValue2(delimString) {
  var delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(_ref4, args) {
    var {
      parser
    } = _ref4;
    var numer = args[4];
    var denom = args[5];
    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;
    if (barNode.isBlank) {
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }
    var size = "auto";
    var styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size = stylArray[Number(styl.text)];
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler(_ref5, args) {
    var {
      parser,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (grp, options) => {
  var style = options.style;
  var supSubGroup;
  var group;
  if (grp.type === "supsub") {
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  }
  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
  var braceBody = stretchy.svgSpan(group, options);
  var vlist;
  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options);
    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options);
    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }
  if (supSubGroup) {
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }
  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};
var mathmlBuilder$2 = (group, options) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options), accentNode]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\href");
    }
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements, options);
  },
  mathmlBuilder: (group, options) => {
    var math2 = buildExpressionRow(group.body, options);
    if (!(math2 instanceof MathNode)) {
      math2 = new MathNode("mrow", [math2]);
    }
    math2.setAttribute("href", group.href);
    return math2;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\url");
    }
    var chars = [];
    for (var i = 0; i < href.length; i++) {
      var c = href[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    var body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName,
      token
    } = _ref;
    var value = assertNodeType(args[0], "raw").string;
    var body = args[1];
    if (parser.settings.strict) {
      parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }
    var trustContext;
    var attributes = {};
    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value;
        trustContext = {
          command: "\\htmlClass",
          class: value
        };
        break;
      case "\\htmlId":
        attributes.id = value;
        trustContext = {
          command: "\\htmlId",
          id: value
        };
        break;
      case "\\htmlStyle":
        attributes.style = value;
        trustContext = {
          command: "\\htmlStyle",
          style: value
        };
        break;
      case "\\htmlData": {
        var data = value.split(",");
        for (var i = 0; i < data.length; i++) {
          var item = data[i];
          var firstEquals = item.indexOf("=");
          if (firstEquals < 0) {
            throw new ParseError("\\htmlData key/value '" + item + "' missing equals sign");
          }
          var key = item.slice(0, firstEquals);
          var _value = item.slice(firstEquals + 1);
          attributes["data-" + key.trim()] = _value;
        }
        trustContext = {
          command: "\\htmlData",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!parser.settings.isTrusted(trustContext)) {
      return parser.formatUnsupportedCmd(funcName);
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    var classes = ["enclosing"];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    var span = buildCommon.makeSpan(classes, elements, options);
    for (var attr in group.attributes) {
      if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
        span.setAttribute(attr, group.attributes[attr]);
      }
    }
    return span;
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.body, options);
  }
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.html, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.mathml, options);
  }
});
var sizeData = function sizeData2(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match2) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    var data = {
      number: +(match2[1] + match2[2]),
      // sign + magnitude, cast to number
      unit: match2[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data;
  }
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var width = {
      number: 0,
      unit: "em"
    };
    var height = {
      number: 0.9,
      unit: "em"
    };
    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";
    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string;
      var attributes = attributeStr.split(",");
      for (var i = 0; i < attributes.length; i++) {
        var keyVal = attributes[i].split("=");
        if (keyVal.length === 2) {
          var str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;
            case "width":
              width = sizeData(str);
              break;
            case "height":
              height = sizeData(str);
              break;
            case "totalheight":
              totalheight = sizeData(str);
              break;
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    var src = assertNodeType(args[0], "url").url;
    if (alt === "") {
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }
    if (!parser.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser.formatUnsupportedCmd("\\includegraphics");
    }
    return {
      type: "includegraphics",
      mode: parser.mode,
      alt,
      width,
      height,
      totalheight,
      src
    };
  },
  htmlBuilder: (group, options) => {
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
    }
    var width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, options);
    }
    var style = {
      height: makeEm(height + depth)
    };
    if (width > 0) {
      style.width = makeEm(width);
    }
    if (depth > 0) {
      style.verticalAlign = makeEm(-depth);
    }
    var node = new Img(group.src, group.alt, style);
    node.height = height;
    node.depth = depth;
    return node;
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mglyph", []);
    node.setAttribute("alt", group.alt);
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
      node.setAttribute("valign", makeEm(-depth));
    }
    node.setAttribute("height", makeEm(height + depth));
    if (group.width.number > 0) {
      var width = calculateSize(group.width, options);
      node.setAttribute("width", makeEm(width));
    }
    node.setAttribute("src", group.src);
    return node;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      var mathFunction = funcName[1] === "m";
      var muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }
        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },
  mathmlBuilder(group, options) {
    var dimension = calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2;
    if (group.alignment === "clap") {
      inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
      inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
    } else {
      inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
    }
    var fix = buildCommon.makeSpan(["fix"], []);
    var node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node.height + node.depth);
    if (node.depth) {
      strut.style.verticalAlign = makeEm(-node.depth);
    }
    node.children.unshift(strut);
    node = buildCommon.makeSpan(["thinbox"], [node], options);
    return buildCommon.makeSpan(["mord", "vbox"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.alignment !== "rlap") {
      var offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
    }
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(_ref, args) {
    var {
      funcName,
      parser
    } = _ref;
    var outerMode = parser.mode;
    parser.switchMode("math");
    var close2 = funcName === "\\(" ? "\\)" : "$";
    var body = parser.parseExpression(false, close2);
    parser.expect(close2);
    parser.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, args) {
    throw new ParseError("Mismatched " + context.funcName);
  }
});
var chooseMathStyle = (group, options) => {
  switch (options.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;
    case Style$1.TEXT.size:
      return group.text;
    case Style$1.SCRIPT.size:
      return group.script;
    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;
    default:
      return group.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    var elements = buildExpression$1(body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});
var assembleSupSub = (base2, supGroup, subGroup, options, style, slant, baseShift) => {
  base2 = buildCommon.makeSpan([], [base2]);
  var subIsSingleCharacter = subGroup && utils$1.isCharacterBox(subGroup);
  var sub2;
  var sup2;
  if (supGroup) {
    var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);
    sup2 = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }
  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);
    sub2 = {
      elem: _elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  }
  var finalGroup;
  if (sup2 && sub2) {
    var bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base2.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base2
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else if (sub2) {
    var top = base2.height - baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base2
      }]
    }, options);
  } else if (sup2) {
    var _bottom = base2.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base2
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else {
    return base2;
  }
  var parts = [finalGroup];
  if (sub2 && slant !== 0 && !subIsSingleCharacter) {
    var spacer = buildCommon.makeSpan(["mspace"], [], options);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
};
var noSuccessor = ["\\smallint"];
var htmlBuilder$2 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }
  var style = options.style;
  var large = false;
  if (style.size === Style$1.DISPLAY.size && group.symbol && !noSuccessor.includes(group.name)) {
    large = true;
  }
  var base2;
  if (group.symbol) {
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";
    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }
    base2 = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
    if (stash.length > 0) {
      var italic = base2.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base2 = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base2,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options);
      group.name = "\\" + stash;
      base2.classes.unshift("mop");
      base2.italic = italic;
    }
  } else if (group.body) {
    var inner2 = buildExpression$1(group.body, options, true);
    if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
      base2 = inner2[0];
      base2.classes[0] = "mop";
    } else {
      base2 = buildCommon.makeSpan(["mop"], inner2, options);
    }
  } else {
    var output = [];
    for (var i = 1; i < group.name.length; i++) {
      output.push(buildCommon.mathsym(group.name[i], group.mode, options));
    }
    base2 = buildCommon.makeSpan(["mop"], output, options);
  }
  var baseShift = 0;
  var slant = 0;
  if ((base2 instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
    slant = base2.italic;
  }
  if (hasLimits) {
    return assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift);
  } else {
    if (baseShift) {
      base2.style.position = "relative";
      base2.style.top = makeEm(baseShift);
    }
    return base2;
  }
};
var mathmlBuilder$1 = (group, options) => {
  var node;
  if (group.symbol) {
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (noSuccessor.includes(group.name)) {
      node.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    node = new MathNode("mo", buildExpression2(group.body, options));
  } else {
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
    var operator = new MathNode("mo", [makeText("", "text")]);
    if (group.parentIsSupSub) {
      node = new MathNode("mrow", [node, operator]);
    } else {
      node = newDocumentFragment([node, operator]);
    }
  }
  return node;
};
var singleCharBigOps = {
  "": "\\prod",
  "": "\\coprod",
  "": "\\sum",
  "": "\\bigwedge",
  "": "\\bigvee",
  "": "\\bigcap",
  "": "\\bigcup",
  "": "\\bigodot",
  "": "\\bigoplus",
  "": "\\bigotimes",
  "": "\\biguplus",
  "": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "": "\\int",
  "": "\\iint",
  "": "\\iiint",
  "": "\\oint",
  "": "\\oiint",
  "": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
  props: {
    numArgs: 0,
    allowedInArgument: true
  },
  handler(_ref5) {
    var {
      parser,
      funcName
    } = _ref5;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }
  var base2;
  if (group.body.length > 0) {
    var body = group.body.map((child2) => {
      var childText = child2.text;
      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child2.mode,
          text: childText
        };
      } else {
        return child2;
      }
    });
    var expression = buildExpression$1(body, options.withFont("mathrm"), true);
    for (var i = 0; i < expression.length; i++) {
      var child = expression[i];
      if (child instanceof SymbolNode) {
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }
    base2 = buildCommon.makeSpan(["mop"], expression, options);
  } else {
    base2 = buildCommon.makeSpan(["mop"], [], options);
  }
  if (hasLimits) {
    return assembleSupSub(base2, supGroup, subGroup, options, options.style, 0, 0);
  } else {
    return base2;
  }
};
var mathmlBuilder2 = (group, options) => {
  var expression = buildExpression2(group.body, options.withFont("mathrm"));
  var isAllString = true;
  for (var i = 0; i < expression.length; i++) {
    var node = expression[i];
    if (node instanceof mathMLTree.SpaceNode) ;
    else if (node instanceof mathMLTree.MathNode) {
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break;
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }
  if (isAllString) {
    var word = expression.map((node2) => node2.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }
  var identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal");
  var operator = new mathMLTree.MathNode("mo", [makeText("", "text")]);
  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder: mathmlBuilder2
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
    }
    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
  },
  mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options, true);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
    var line = buildCommon.makeLineSpan("overline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options), operator]);
    node.setAttribute("accent", "true");
    return node;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options.withPhantom(), false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner2);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
    node.height = 0;
    node.depth = 0;
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        node.children[i].height = 0;
        node.children[i].depth = 0;
      }
    }
    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var dy = calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    var dy = group.dy.number + group.dy.unit;
    node.setAttribute("voffset", dy);
    return node;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInArgument: true
  },
  handler(_ref) {
    var {
      parser
    } = _ref;
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["size", "size", "size"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var shift = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  htmlBuilder(group, options) {
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    rule.style.borderRightWidth = makeEm(width);
    rule.style.borderTopWidth = makeEm(height);
    rule.style.bottom = makeEm(shift);
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;
    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
    return rule;
  },
  mathmlBuilder(group, options) {
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    var color2 = options.color && options.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color2);
    rule.setAttribute("width", makeEm(width));
    rule.setAttribute("height", makeEm(height));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }
    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }
});
function sizingGroup(value, options, baseOptions) {
  var inner2 = buildExpression$1(value, options, false);
  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
  for (var i = 0; i < inner2.length; i++) {
    var pos = inner2[i].classes.indexOf("sizing");
    if (pos < 0) {
      Array.prototype.push.apply(inner2[i].classes, options.sizingClasses(baseOptions));
    } else if (inner2[i].classes[pos + 1] === "reset-size" + options.size) {
      inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
    }
    inner2[i].height *= multiplier;
    inner2[i].depth *= multiplier;
  }
  return buildCommon.makeFragment(inner2);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder2 = (group, options) => {
  var newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder: htmlBuilder2,
  mathmlBuilder: (group, options) => {
    var newOptions = options.havingSize(group.size);
    var inner2 = buildExpression2(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      var letter = "";
      for (var i = 0; i < tbArg.body.length; ++i) {
        var node = tbArg.body[i];
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }
    var body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
    if (!group.smashHeight && !group.smashDepth) {
      return node;
    }
    if (group.smashHeight) {
      node.height = 0;
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          node.children[i].height = 0;
        }
      }
    }
    if (group.smashDepth) {
      node.depth = 0;
      if (node.children) {
        for (var _i = 0; _i < node.children.length; _i++) {
          node.children[_i].depth = 0;
        }
      }
    }
    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }
    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }
    return node;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var index = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  htmlBuilder(group, options) {
    var inner2 = buildGroup$1(group.body, options.havingCrampedStyle());
    if (inner2.height === 0) {
      inner2.height = options.fontMetrics().xHeight;
    }
    inner2 = buildCommon.wrapFragment(inner2, options);
    var metrics = options.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;
    if (options.style.id < Style$1.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    }
    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter$1.sqrtImage(minDelimiterHeight, options);
    var delimDepth = img.height - ruleWidth;
    if (delimDepth > inner2.height + inner2.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
    }
    var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
    inner2.style.paddingLeft = makeEm(advanceWidth);
    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner2,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner2.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);
    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options);
      var toShift = 0.6 * (body.height - body.depth);
      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options);
      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },
  mathmlBuilder(group, options) {
    var {
      body,
      index
    } = group;
    return index ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options), buildGroup2(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options)]);
  }
});
var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style,
      body
    };
  },
  htmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle).withFont("");
    return sizingGroup(group.body, newOptions, options);
  },
  mathmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle);
    var inner2 = buildExpression2(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr = styleAttributes[group.style];
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);
    return node;
  }
});
var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
  var base2 = group.base;
  if (!base2) {
    return null;
  } else if (base2.type === "op") {
    var delegate = base2.limits && (options.style.size === Style$1.DISPLAY.size || base2.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base2.type === "operatorname") {
    var _delegate = base2.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base2.limits);
    return _delegate ? htmlBuilder$1 : null;
  } else if (base2.type === "accent") {
    return utils$1.isCharacterBox(base2.base) ? htmlBuilder$a : null;
  } else if (base2.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base2.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(group, options) {
    var builderDelegate = htmlBuilderDelegate(group, options);
    if (builderDelegate) {
      return builderDelegate(group, options);
    }
    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base2 = buildGroup$1(valueBase, options);
    var supm;
    var subm;
    var metrics = options.fontMetrics();
    var supShift = 0;
    var subShift = 0;
    var isCharacterBox3 = valueBase && utils$1.isCharacterBox(valueBase);
    if (valueSup) {
      var newOptions = options.havingStyle(options.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options);
      if (!isCharacterBox3) {
        supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    if (valueSub) {
      var _newOptions = options.havingStyle(options.style.sub());
      subm = buildGroup$1(valueSub, _newOptions, options);
      if (!isCharacterBox3) {
        subShift = base2.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    var minSupShift;
    if (options.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    }
    var multiplier = options.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;
    if (subm) {
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
      if (base2 instanceof SymbolNode || isOiint) {
        marginLeft = makeEm(-base2.italic);
      }
    }
    var supsub;
    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness;
      var maxWidth = 4 * ruleWidth;
      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options);
    } else if (supm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    }
    var mclass = getTypeOfDomTree(base2, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },
  mathmlBuilder(group, options) {
    var isBrace = false;
    var isOver;
    var isSup;
    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }
    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }
    var children = [buildGroup2(group.base, options)];
    if (group.sub) {
      children.push(buildGroup2(group.sub, options));
    }
    if (group.sup) {
      children.push(buildGroup2(group.sup, options));
    }
    var nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base2 = group.base;
      if (base2 && base2.type === "op" && base2.limits && (options.style === Style$1.DISPLAY || base2.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;
      if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;
      if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }
    return new mathMLTree.MathNode(nodeType, children);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "bin") {
      var variant = getVariant(group, options);
      if (variant === "bold-italic") {
        node.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      node.setAttribute("stretchy", "false");
    }
    return node;
  }
});
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
    var variant = getVariant(group, options) || "italic";
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },
  mathmlBuilder(group, options) {
    var text2 = makeText(group.text, group.mode, options);
    var variant = getVariant(group, options) || "normal";
    var node;
    if (group.mode === "text") {
      node = new mathMLTree.MathNode("mtext", [text2]);
    } else if (/[0-9]/.test(group.text)) {
      node = new mathMLTree.MathNode("mn", [text2]);
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text2]);
    } else {
      node = new mathMLTree.MathNode("mi", [text2]);
    }
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || "";
      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
  },
  mathmlBuilder(group, options) {
    var node;
    if (regularSpace.hasOwnProperty(group.text)) {
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
    return node;
  }
});
var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(group, options) {
    var table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table2.setAttribute("width", "100%");
    return table2;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var optionsWithFont = (group, options) => {
  var font = group.font;
  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
  }
  return options.withTextFontShape(textFontShapes[font]);
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  htmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    var inner2 = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
  },
  mathmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options);
    var line = buildCommon.makeLineSpan("underline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options), operator]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var axisHeight = options.fontMetrics().axisHeight;
    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(group, options) {
    var text2 = makeVerb(group);
    var body = [];
    var newOptions = options.havingStyle(options.style.text());
    for (var i = 0; i < text2.length; i++) {
      var c = text2[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder(group, options) {
    var text2 = new mathMLTree.TextNode(makeVerb(group));
    var node = new mathMLTree.MathNode("mtext", [text2]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});
var makeVerb = (group) => group.body.replace(/ /g, group.star ? "" : "");
var functions = _functions;
var spaceRegexString = "[ \r\n	]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
var combiningDiacriticalMarkString = "[-]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
(controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]---]" + // single codepoint
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
("|" + controlSymbolRegexString + ")");
class Lexer {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, "g");
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(char, code2) {
    this.catcodes[char] = code2;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token$1("EOF", new SourceLocation(this, pos, pos));
    }
    var match2 = this.tokenRegex.exec(input);
    if (match2 === null || match2.index !== pos) {
      throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token$1(input[pos], new SourceLocation(this, pos, pos + 1)));
    }
    var text2 = match2[6] || match2[3] || (match2[2] ? "\\ " : " ");
    if (this.catcodes[text2] === 14) {
      var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length;
        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }
    return new Token$1(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}
class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }
    if (globalMacros === void 0) {
      globalMacros = {};
    }
    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    }
    var undefs = this.undefStack.pop();
    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(name, value, global) {
    if (global === void 0) {
      global = false;
    }
    if (global) {
      for (var i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      var top = this.undefStack[this.undefStack.length - 1];
      if (top && !top.hasOwnProperty(name)) {
        top[name] = this.current[name];
      }
    }
    if (value == null) {
      delete this.current[name];
    } else {
      this.current[name] = value;
    }
  }
}
var macros = _macros;
defineMacro("\\noexpand", function(context) {
  var t = context.popToken();
  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }
  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(context) {
  var t = context.popToken();
  context.expandOnce(true);
  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(context) {
  var args = context.consumeArgs(3);
  context.consumeSpaces();
  var nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(context) {
  var args = context.consumeArgs(2);
  if (context.mode === "text") {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
});
var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
defineMacro("\\char", function(context) {
  var token = context.popToken();
  var base2;
  var number2 = "";
  if (token.text === "'") {
    base2 = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base2 = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number2 = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number2 = token.text.charCodeAt(0);
    }
  } else {
    base2 = 10;
  }
  if (base2) {
    number2 = digitToNumber[token.text];
    if (number2 == null || number2 >= base2) {
      throw new ParseError("Invalid base-" + base2 + " digit " + token.text);
    }
    var digit;
    while ((digit = digitToNumber[context.future().text]) != null && digit < base2) {
      number2 *= base2;
      number2 += digit;
      context.popToken();
    }
  }
  return "\\@char{" + number2 + "}";
});
var newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
  var arg = context.consumeArg().tokens;
  if (arg.length !== 1) {
    throw new ParseError("\\newcommand's first argument must be a macro name");
  }
  var name = arg[0].text;
  var exists = context.isDefined(name);
  if (exists && !existsOK) {
    throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }
  if (!exists && !nonexistsOK) {
    throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
  }
  var numArgs = 0;
  arg = context.consumeArg().tokens;
  if (arg.length === 1 && arg[0].text === "[") {
    var argText = "";
    var token = context.expandNextToken();
    while (token.text !== "]" && token.text !== "EOF") {
      argText += token.text;
      token = context.expandNextToken();
    }
    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError("Invalid number of arguments: " + argText);
    }
    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  }
  if (!(exists && skipIfExists)) {
    context.macros.set(name, {
      tokens: arg,
      numArgs
    });
  }
  return "";
};
defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
defineMacro("\\message", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.log(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\errmessage", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.error(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\show", (context) => {
  var tok = context.popToken();
  var name = tok.text;
  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
  return "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
defineMacro("", "\\mathscr{B}");
defineMacro("", "\\mathscr{E}");
defineMacro("", "\\mathscr{F}");
defineMacro("", "\\mathscr{H}");
defineMacro("", "\\mathscr{I}");
defineMacro("", "\\mathscr{L}");
defineMacro("", "\\mathscr{M}");
defineMacro("", "\\mathscr{R}");
defineMacro("", "\\mathfrak{C}");
defineMacro("", "\\mathfrak{H}");
defineMacro("", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
defineMacro("\\ne", "\\neq");
defineMacro("", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
defineMacro("", "\\notin");
defineMacro("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\perp");
defineMacro("", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("", "\\notni");
defineMacro("", "\\ulcorner");
defineMacro("", "\\urcorner");
defineMacro("", "\\llcorner");
defineMacro("", "\\lrcorner");
defineMacro("", "\\copyright");
defineMacro("", "\\textregistered");
defineMacro("", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(context) {
  var thedots = "\\dotso";
  var next = context.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (["bin", "rel"].includes(symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  "$": true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};
defineMacro("\\dotso", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("", "\\dblcolon");
defineMacro("", "\\eqcolon");
defineMacro("", "\\coloneqq");
defineMacro("", "\\eqqcolon");
defineMacro("", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
defineMacro("", "\\llbracket");
defineMacro("", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
defineMacro("", "\\lBrace");
defineMacro("", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
defineMacro("", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (one2) => (context) => {
  var left = context.consumeArg().tokens;
  var middle = context.consumeArg().tokens;
  var middleDouble = context.consumeArg().tokens;
  var right = context.consumeArg().tokens;
  var oldMiddle = context.macros.get("|");
  var oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();
  var midMacro = (double) => (context2) => {
    if (one2) {
      context2.macros.set("|", oldMiddle);
      if (middleDouble.length) {
        context2.macros.set("\\|", oldMiddleDouble);
      }
    }
    var doubled = double;
    if (!double && middleDouble.length) {
      var nextToken = context2.future();
      if (nextToken.text === "|") {
        context2.popToken();
        doubled = true;
      }
    }
    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };
  context.macros.set("|", midMacro(false));
  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }
  var arg = context.consumeArg().tokens;
  var expanded = context.expandTokens([
    ...right,
    ...arg,
    ...left
    // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true
  // Parser.js
};
class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future();
    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    var start;
    var end;
    var tokens;
    if (isOptional) {
      this.consumeSpaces();
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken();
      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start,
        end
      } = this.consumeArg());
    }
    this.pushToken(new Token$1("EOF", end.loc));
    this.pushTokens(tokens);
    return new Token$1("", SourceLocation.range(start, end));
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims2) {
    var tokens = [];
    var isDelimited = delims2 && delims2.length > 0;
    if (!isDelimited) {
      this.consumeSpaces();
    }
    var start = this.future();
    var tok;
    var depth = 0;
    var match2 = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims2 && isDelimited ? delims2[match2] : "}") + "'", tok);
      }
      if (delims2 && isDelimited) {
        if ((depth === 0 || depth === 1 && delims2[match2] === "{") && tok.text === delims2[match2]) {
          ++match2;
          if (match2 === delims2.length) {
            tokens.splice(-match2, match2);
            break;
          }
        } else {
          match2 = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse();
    return {
      tokens,
      start,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters2) {
    if (delimiters2) {
      if (delimiters2.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      var delims2 = delimiters2[0];
      for (var i = 0; i < delims2.length; i++) {
        var tok = this.popToken();
        if (delims2[i] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }
    var args = [];
    for (var _i = 0; _i < numArgs; _i++) {
      args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
    }
    return args;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(amount) {
    this.expansionCount += amount;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
    }
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.countExpansion(1);
    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      tokens = tokens.slice();
      for (var i = tokens.length - 1; i >= 0; --i) {
        var tok = tokens[i];
        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i];
          if (tok.text === "#") {
            tokens.splice(i + 1, 1);
          } else if (/^[1-9]$/.test(tok.text)) {
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    this.pushTokens(tokens);
    return tokens.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; ) {
      if (this.expandOnce() === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token;
      }
    }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token$1(name)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      if (this.expandOnce(true) === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    this.countExpansion(output.length);
    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    var tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    var definition = this.macros.get(name);
    if (definition == null) {
      return definition;
    }
    if (name.length === 1) {
      var catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return;
      }
    }
    var expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      var numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      var bodyLexer = new Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse();
      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }
    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    var macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
  }
}
var unicodeSubRegEx = /^[]/;
var uSubsAndSups = Object.freeze({
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "a",
  "": "e",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "x",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "A",
  "": "B",
  "": "D",
  "": "E",
  "": "G",
  "": "H",
  "": "I",
  "": "J",
  "": "K",
  "": "L",
  "": "M",
  "": "N",
  "": "O",
  "": "P",
  "": "R",
  "": "T",
  "": "U",
  "": "V",
  "": "W",
  "": "a",
  "": "b",
  "": "c",
  "": "d",
  "": "e",
  "": "f",
  "": "g",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "w",
  "": "x",
  "": "y",
  "": "z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
});
var unicodeAccents = {
  "": {
    "text": "\\'",
    "math": "\\acute"
  },
  "": {
    "text": "\\`",
    "math": "\\grave"
  },
  "": {
    "text": '\\"',
    "math": "\\ddot"
  },
  "": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "": {
    "text": "\\=",
    "math": "\\bar"
  },
  "": {
    "text": "\\u",
    "math": "\\breve"
  },
  "": {
    "text": "\\v",
    "math": "\\check"
  },
  "": {
    "text": "\\^",
    "math": "\\hat"
  },
  "": {
    "text": "\\.",
    "math": "\\dot"
  },
  "": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "": {
    "text": "\\H"
  },
  "": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "b",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "d",
  "": "d",
  "": "d",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "f",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "h",
  "": "h",
  "": "h",
  "": "h",
  "": "h",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "j",
  "": "j",
  "": "k",
  "": "k",
  "": "k",
  "": "l",
  "": "l",
  "": "l",
  "": "m",
  "": "m",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "p",
  "": "p",
  "": "r",
  "": "r",
  "": "r",
  "": "r",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "t",
  "": "t",
  "": "t",
  "": "t",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "v",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "x",
  "": "x",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "z",
  "": "z",
  "": "z",
  "": "z",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "B",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "D",
  "": "D",
  "": "D",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "F",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "H",
  "": "H",
  "": "H",
  "": "H",
  "": "H",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "J",
  "": "K",
  "": "K",
  "": "K",
  "": "L",
  "": "L",
  "": "L",
  "": "M",
  "": "M",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "P",
  "": "P",
  "": "R",
  "": "R",
  "": "R",
  "": "R",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "T",
  "": "T",
  "": "T",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "V",
  "": "W",
  "": "W",
  "": "W",
  "": "W",
  "": "W",
  "": "X",
  "": "X",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
};
class Parser {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    this.mode = "math";
    this.gullet = new MacroExpander(input, settings, this.mode);
    this.settings = settings;
    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text2, consume) {
    if (consume === void 0) {
      consume = true;
    }
    if (this.fetch().text !== text2) {
      throw new ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    if (!this.settings.globalGroup) {
      this.gullet.beginGroup();
    }
    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }
    try {
      var parse = this.parseExpression(false);
      this.expect("EOF");
      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }
      return parse;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    var oldToken = this.nextToken;
    this.consume();
    this.gullet.pushToken(new Token$1("}"));
    this.gullet.pushTokens(tokens);
    var parse = this.parseExpression(false);
    this.expect("}");
    this.nextToken = oldToken;
    return parse;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence than infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = [];
    while (true) {
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      var lex = this.fetch();
      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      var atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;
    for (var i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i].token);
        }
        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }
    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);
      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }
      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }
      var node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(name) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces();
    var group;
    do {
      var _group;
      group = this.parseGroup(name);
    } while (((_group = group) == null ? void 0 : _group.type) === "internal");
    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }
    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text2) {
    var textordArray = [];
    for (var i = 0; i < text2.length; i++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text2[i]
      });
    }
    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    var base2 = this.parseGroup("atom", breakOnTokenText);
    if ((base2 == null ? void 0 : base2.type) === "internal") {
      return base2;
    }
    if (this.mode === "text") {
      return base2;
    }
    var superscript;
    var subscript;
    while (true) {
      this.consumeSpaces();
      var lex = this.fetch();
      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        if (base2 && base2.type === "op") {
          var limits = lex.text === "\\limits";
          base2.limits = limits;
          base2.alwaysHandleSupSub = true;
        } else if (base2 && base2.type === "operatorname") {
          if (base2.alwaysHandleSupSub) {
            base2.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        };
        var primes = [prime];
        this.consume();
        while (this.fetch().text === "'") {
          primes.push(prime);
          this.consume();
        }
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        var isSub = unicodeSubRegEx.test(lex.text);
        var subsupTokens = [];
        subsupTokens.push(new Token$1(uSubsAndSups[lex.text]));
        this.consume();
        while (true) {
          var token = this.fetch().text;
          if (!uSubsAndSups[token]) {
            break;
          }
          if (unicodeSubRegEx.test(token) !== isSub) {
            break;
          }
          subsupTokens.unshift(new Token$1(uSubsAndSups[token]));
          this.consume();
        }
        var body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        break;
      }
    }
    if (superscript || subscript) {
      return {
        type: "supsub",
        mode: this.mode,
        base: base2,
        sup: superscript,
        sub: subscript
      };
    } else {
      return base2;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(breakOnTokenText, name) {
    var token = this.fetch();
    var func = token.text;
    var funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume();
    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }
    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    var context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    var func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }
    var args = [];
    var optArgs = [];
    for (var i = 0; i < totalArgs; i++) {
      var argType = funcData.argTypes && funcData.argTypes[i];
      var isOptional = i < funcData.numOptionalArgs;
      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
        argType = "primitive";
      }
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        throw new ParseError("Null argument, please report this as a bug");
      }
    }
    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        var group = this.parseArgumentGroup(optional, "text");
        return group != null ? {
          type: "styling",
          mode: group.mode,
          body: [group],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var token = this.parseStringGroup("raw", optional);
        return token != null ? {
          type: "raw",
          mode: "text",
          string: token.text
        } : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        var _group2 = this.parseGroup(name);
        if (_group2 == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return _group2;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(modeName, optional) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume();
    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(regex2, modeName) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex2.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);
    if (res == null) {
      return null;
    }
    var match2 = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
    if (!match2) {
      throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    var color2 = match2[0];
    if (/^[0-9a-f]{6}$/i.test(color2)) {
      color2 = "#" + color2;
    }
    return {
      type: "color-token",
      mode: this.mode,
      color: color2
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    var res;
    var isBlank = false;
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      res.text = "0pt";
      isBlank = true;
    }
    var match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
    if (!match2) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
      number: +(match2[1] + match2[2]),
      // sign + magnitude, cast to number
      unit: match2[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13);
    this.gullet.lexer.setCatcode("~", 12);
    var res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14);
    this.gullet.lexer.setCatcode("~", 13);
    if (res == null) {
      return null;
    }
    var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var outerMode = this.mode;
    if (mode) {
      this.switchMode(mode);
    }
    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF");
    this.expect("EOF");
    this.gullet.endGroup();
    var result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };
    if (mode) {
      this.switchMode(outerMode);
    }
    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(name, breakOnTokenText) {
    var firstToken = this.fetch();
    var text2 = firstToken.text;
    var result;
    if (text2 === "{" || text2 === "\\begingroup") {
      this.consume();
      var groupEnd = text2 === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd);
      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text2 === "\\begingroup" || void 0
      };
    } else {
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
        if (this.settings.throwOnError) {
          throw new ParseError("Undefined control sequence: " + text2, firstToken);
        }
        result = this.formatUnsupportedCmd(text2);
        this.consume();
      }
    }
    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    var n = group.length - 1;
    for (var i = 0; i < n; ++i) {
      var a = group[i];
      var v = a.text;
      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }
      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var nucleus = this.fetch();
    var text2 = nucleus.text;
    if (/^\\verb[^a-zA-Z]/.test(text2)) {
      this.consume();
      var arg = text2.slice(5);
      var star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }
      arg = arg.slice(1, -1);
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    if (unicodeSymbols.hasOwnProperty(text2[0]) && !symbols[this.mode][text2[0]]) {
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      text2 = unicodeSymbols[text2[0]] + text2.slice(1);
    }
    var match2 = combiningDiacriticalMarksEndRegex.exec(text2);
    if (match2) {
      text2 = text2.substring(0, match2.index);
      if (text2 === "i") {
        text2 = "";
      } else if (text2 === "j") {
        text2 = "";
      }
    }
    var symbol;
    if (symbols[this.mode][text2]) {
      if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      var group = symbols[this.mode][text2].group;
      var loc = SourceLocation.range(nucleus);
      var s;
      if (ATOMS.hasOwnProperty(group)) {
        var family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text: text2
        };
      } else {
        s = {
          type: group,
          mode: this.mode,
          loc,
          text: text2
        };
      }
      symbol = s;
    } else if (text2.charCodeAt(0) >= 128) {
      if (this.settings.strict) {
        if (!supportedCodepoint(text2.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
        }
      }
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text: text2
      };
    } else {
      return null;
    }
    this.consume();
    if (match2) {
      for (var i = 0; i < match2[0].length; i++) {
        var accent2 = match2[0][i];
        if (!unicodeAccents[accent2]) {
          throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
        }
        var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
        if (!command) {
          throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    }
    return symbol;
  }
}
Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function parseTree2(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("KaTeX can only parse string typed expression");
  }
  var parser = new Parser(toParse, settings);
  delete parser.gullet.macros.current["\\df@tag"];
  var tree = parser.parse();
  delete parser.gullet.macros.current["\\current@color"];
  delete parser.gullet.macros.current["\\color"];
  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError("\\tag works only in display equations");
    }
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.subparse([new Token$1("\\df@tag")])
    }];
  }
  return tree;
};
var render = function render2(expression, baseNode, options) {
  baseNode.textContent = "";
  var node = renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node);
};
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
    render = function render3() {
      throw new ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
var renderToString = function renderToString2(expression, options) {
  var markup = renderToDomTree(expression, options).toMarkup();
  return markup;
};
var generateParseTree = function generateParseTree2(expression, options) {
  var settings = new Settings(options);
  return parseTree(expression, settings);
};
var renderError = function renderError2(error2, expression, options) {
  if (options.throwOnError || !(error2 instanceof ParseError)) {
    throw error2;
  }
  var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node.setAttribute("title", error2.toString());
  node.setAttribute("style", "color:" + options.errorColor);
  return node;
};
var renderToDomTree = function renderToDomTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error2) {
    return renderError(error2, expression, settings);
  }
};
var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error2) {
    return renderError(error2, expression, settings);
  }
};
var version = "0.16.28";
var __domTree = {
  Span,
  Anchor,
  SymbolNode,
  SvgNode,
  PathNode,
  LineNode
};
var katex$2 = {
  /**
   * Current KaTeX version
   */
  version,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: defineFunction,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree
};
const decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode$1(string2, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode$1.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    let result = "";
    for (let i = 0, l = seq.length; i < l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "";
    }
    return result;
  });
}
decode$1.defaultChars = ";/?:@&=+$,#";
decode$1.componentChars = "";
const encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode$1(string2, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string2.length; i < l; i++) {
    const code2 = string2.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
        result += string2.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string2.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string2[i] + string2[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string2[i]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
function format$1(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
const protocolPattern = /^([a-z0-9.+-]+:)/i;
const portPattern = /:[0-9]*$/;
const simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
const delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
const unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
const autoEscape = ["'"].concat(unwise);
const nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
const hostEndingChars = ["/", "?", "#"];
const hostnameMaxLen = 255;
const hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
const hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
const hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
const slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
const mdurl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$1,
  encode: encode$1,
  format: format$1,
  parse: urlParse
}, Symbol.toStringTag, { value: "Module" }));
const Any = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
const Cc = /[\0-\x1F\x7F-\x9F]/;
const regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
const P = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
const regex = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
const Z = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
const ucmicro = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any,
  Cc,
  Cf: regex$1,
  P,
  S: regex,
  Z
}, Symbol.toStringTag, { value: "Module" }));
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((c) => c.charCodeAt(0))
);
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c) => c.charCodeAt(0))
);
var _a;
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint$1 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base2) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint$1(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
const htmlDecoder = getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}
function _class$1(obj) {
  return Object.prototype.toString.call(obj);
}
function isString$1(obj) {
  return _class$1(obj) === "[object String]";
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function has(object2, key) {
  return _hasOwnProperty.call(object2, key);
}
function assign$1(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
const UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
const ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
const UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
const DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match2, name) {
  if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
    const code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint(code2);
    }
    return match2;
  }
  const decoded = decodeHTML(match2);
  if (decoded !== match2) {
    return decoded;
  }
  return match2;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match2, entity2);
  });
}
const HTML_ESCAPE_TEST_RE = /[&<>"]/;
const HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
const HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
const REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE$1(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return P.test(ch) || regex.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("".toLowerCase() === "") {
    str = str.replace(//g, "");
  }
  return str.toLowerCase().toUpperCase();
}
const lib = { mdurl, ucmicro };
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt,
  assign: assign$1,
  escapeHtml,
  escapeRE: escapeRE$1,
  fromCodePoint,
  has,
  isMdAsciiPunct,
  isPunctChar,
  isSpace,
  isString: isString$1,
  isValidEntityCode,
  isWhiteSpace,
  lib,
  normalizeReference,
  unescapeAll,
  unescapeMd
}, Symbol.toStringTag, { value: "Module" }));
function parseLinkLabel(state, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state.posMax;
  const oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}
function parseLinkDestination(str, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}
function parseLinkTitle(str, start, max, prev_state) {
  let code2;
  let pos = start;
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str.slice(start, pos));
      state.ok = true;
      return state;
    } else if (code2 === 40 && state.marker === 41) {
      return state;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str.slice(start, pos));
  return state;
}
const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination,
  parseLinkLabel,
  parseLinkTitle
}, Symbol.toStringTag, { value: "Module" }));
const default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign$1({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type = tokens[i].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self2 = this;
  const chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name, fn, options) {
  const index = this.__find__(name);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index = this.__find__(beforeName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index = this.__find__(afterName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
function Token2(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token2.prototype.attrIndex = function attrIndex(name) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};
Token2.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token2.prototype.attrSet = function attrSet(name, value) {
  const idx = this.attrIndex(name);
  const attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token2.prototype.attrGet = function attrGet(name) {
  const idx = this.attrIndex(name);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token2.prototype.attrJoin = function attrJoin(name, value) {
  const idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = Token2;
const NEWLINES_RE = /\r\n?|\n/g;
const NULL_RE = /\0/g;
function normalize$1(state) {
  let str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "");
  state.src = str;
}
function block(state) {
  let token;
  if (state.inlineMode) {
    token = new state.Token("inline", "", 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}
function inline(state) {
  const tokens = state.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}
function isLinkOpen$1(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose$1(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify$1(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose$1(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content;
        let links = state.md.linkify.match(text2);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state.Token("text", "", 0);
            token.content = text2.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text2.length) {
          const token = new state.Token("text", "", 0);
          token.content = text2.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}
const RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
const SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
const SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
const SCOPED_ABBR = {
  c: "",
  r: "",
  tm: ""
};
function replaceFn(match2, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1").replace(/(^|\s)--(?=\s|$)/mg, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}
const QUOTE_TEST_RE = /['"]/;
const QUOTE_RE = /['"]/g;
const APOSTROPHE = "";
function replaceAt(str, index, ch) {
  return str.slice(0, index) + ch + str.slice(index + 1);
}
function process_inlines(tokens, state) {
  let j;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text2 = token.content;
    let pos = 0;
    let max = text2.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text2);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text2.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text2.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text2 = token.content;
              max = text2.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}
function text_join(state) {
  let curr, last;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline") continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
}
const _rules$2 = [
  ["normalize", normalize$1],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify$1],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}
Core.prototype.process = function(state) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};
Core.prototype.State = StateCore;
function StateBlock(src, md, env, tokens) {
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token = new Token2(type, tag, nesting);
  token.block = true;
  if (nesting < 0) this.level--;
  token.level = this.level;
  if (nesting > 0) this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return "";
  }
  const queue = new Array(end - begin);
  for (let i = 0, line = begin; line < end; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first = lineStart;
    let last;
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = Token2;
const MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max = state.eMarks[line];
  return state.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t = columns[i].trim();
    if (!t) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "") columns.shift();
  if (columns.length && columns[columns.length - 1] === "") columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}
function code(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  const token = state.push("code_block", "code", 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token.map = [startLine, state.line];
  return true;
}
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state.push("fence", "code", 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
}
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
}
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token = state.push("hr", "hr", 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token = state.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state.push("ordered_list_close", "ol", -1);
  } else {
    token = state.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max2 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max2 + 1);
  }
  let str = state.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) ;
    else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) ;
    else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null) break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}
const block_names = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
const unquoted = "[^\"'=<>`\\x00-\\x20]+";
const single_quoted = "'[^']*'";
const double_quoted = '"[^"]*"';
const attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
const attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
const open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
const close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
const comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
const processing = "<[?][\\s\\S]*?[?]>";
const declaration = "<![A-Za-z][^>]*>";
const cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
const HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
const HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
const HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token = state.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}
function heading(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  const tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}
const _rules$1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok) throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = StateBlock;
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new Token2("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new Token2(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count2 = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count2 };
};
StateInline.prototype.Token = Token2;
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}
const SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify(state, silent) {
  if (!state.md.options.linkify) return false;
  if (state.linkLevel > 0) return false;
  const pos = state.pos;
  const max = state.posMax;
  if (pos + 3 > max) return false;
  if (state.src.charCodeAt(pos) !== 58) return false;
  if (state.src.charCodeAt(pos + 1) !== 47) return false;
  if (state.src.charCodeAt(pos + 2) !== 47) return false;
  const match2 = state.pending.match(SCHEME_RE);
  if (!match2) return false;
  const proto = match2[1];
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link2) return false;
  let url = link2.url;
  if (url.length <= proto.length) return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url);
  if (!state.md.validateLink(fullUrl)) return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url.length - proto.length;
  return true;
}
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}
const ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape(state, silent) {
  let pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92) return false;
  pos++;
  if (pos >= max) return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1)) break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
}
function strikethrough_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token = state.push("text", "", 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess$1(state, delimiters2) {
  let token;
  const loneMarkers = [];
  const max = delimiters2.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters2[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters2[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess$1(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters);
    }
  }
}
const r_strikethrough = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};
function emphasis_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token = state.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters2) {
  const max = delimiters2.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters2[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters2[startDelim.end];
    const isStrong = i > 0 && delimiters2[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters2[i - 1].marker === startDelim.marker && delimiters2[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters2[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters2[i - 1].token].content = "";
      state.tokens[delimiters2[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
const r_emphasis = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};
function link(state, silent) {
  let code2, label, res, ref;
  let href = "";
  let title = "";
  let start = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}
function image(state, silent) {
  let code2, content, label, pos, ref, res, title, start;
  let href = "";
  const oldPos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token = state.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token.attrs = attrs;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}
const EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
const AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max) return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60) return false;
    if (ch === 62) break;
  }
  const url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match2 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = match2[0];
    if (isLinkOpen(token.content)) state.linkLevel++;
    if (isLinkClose(token.content)) state.linkLevel--;
  }
  state.pos += match2[0].length;
  return true;
}
const DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
const NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38) return false;
  if (pos + 1 >= max) return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match2 = state.src.slice(pos).match(DIGITAL_RE);
    if (match2) {
      if (!silent) {
        const code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
        const token = state.push("text_special", "", 0);
        token.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
        token.markup = match2[0];
        token.info = "entity";
      }
      state.pos += match2[0].length;
      return true;
    }
  } else {
    const match2 = state.src.slice(pos).match(NAMED_RE);
    if (match2) {
      const decoded = decodeHTML(match2[0]);
      if (decoded !== match2[0]) {
        if (!silent) {
          const token = state.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match2[0];
          token.info = "entity";
        }
        state.pos += match2[0].length;
        return true;
      }
    }
  }
  return false;
}
function processDelimiters(delimiters2) {
  const openersBottom = {};
  const max = delimiters2.length;
  if (!max) return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters2[closerIdx];
    jumps.push(0);
    if (delimiters2[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close) continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters2[openerIdx];
      if (opener.marker !== closer.marker) continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters2[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}
function fragments_join(state) {
  let curr, last;
  let level = 0;
  const tokens = state.tokens;
  const max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0) level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}
const _rules = [
  ["text", text],
  ["linkify", linkify],
  ["newline", newline],
  ["escape", escape],
  ["backticks", backtick],
  ["strikethrough", r_strikethrough.tokenize],
  ["emphasis", r_emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
const _rules2 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", r_strikethrough.postProcess],
  ["emphasis", r_emphasis.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new Ruler();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  this.ruler2 = new Ruler();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state.level++;
      ok = rules[i](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md, env, outTokens) {
  const state = new this.State(str, md, env, outTokens);
  this.tokenize(state);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline.prototype.State = StateInline;
function reFactory(opts) {
  const re2 = {};
  opts = opts || {};
  re2.src_Any = Any.source;
  re2.src_Cc = Cc.source;
  re2.src_Z = Z.source;
  re2.src_P = P.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  const text_separators = "[><]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re2.src_ZPCc + "))((?![$+<=>^`|])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re2.src_ZPCc + "))((?![$+<=>^`|])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
function isObject(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
const defaultSchemas = {
  "http:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text2[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
          "i"
        );
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
const tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
const tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re2) {
  return function(text2, pos) {
    const tail = text2.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
function compile(self2) {
  const re2 = self2.re = reFactory(self2.__opts__);
  const tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re2.src_xn);
  re2.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re2.src_tlds);
  }
  re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
  re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
  re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
  re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
  const aliases = [];
  self2.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name) {
    const val = self2.__schemas__[name];
    if (val === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self2.__compiled__[name] = compiled;
    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString(val)) {
      aliases.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self2.__compiled__).filter(function(name) {
    return name.length > 0 && self2.__compiled__[name];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp(
    "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self2);
}
function Match(self2, shift) {
  const start = self2.__index__;
  const end = self2.__last_index__;
  const text2 = self2.__text_cache__.slice(start, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text2;
  this.text = text2;
  this.url = text2;
}
function createMatch(self2, shift) {
  const match2 = new Match(self2, shift);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt.prototype.add = function add2(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) {
    return false;
  }
  let m, ml, me, len, shift, next, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text2)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m = re2.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m[2], re2.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text2.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text2.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
};
LinkifyIt.prototype.match = function match(text2) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text2.slice(shift) : text2;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) return null;
  const m = this.re.schema_at_start.exec(text2);
  if (!m) return null;
  const len = this.testSchemaAt(text2, m[2], m[0].length);
  if (!len) return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map$1(array2, callback) {
  const result = [];
  let length = array2.length;
  while (length--) {
    result[length] = callback(array2[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map$1(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string2) {
  const output = [];
  let counter = 0;
  const length = string2.length;
  while (counter < length) {
    const value = string2.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string2.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
const basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
const decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
const encode = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string2) {
    return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string2) {
    return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
  });
};
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
const cfg_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
const cfg_zero = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
const cfg_commonmark = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
const config = {
  default: cfg_default,
  zero: cfg_zero,
  commonmark: cfg_commonmark
};
const BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
const GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
const RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = urlParse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode$1(format$1(parsed));
}
function normalizeLinkText(url) {
  const parsed = urlParse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode$1(format$1(parsed), decode$1.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString$1(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new Core();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils;
  this.helpers = assign$1({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign$1(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self2 = this;
  if (isString$1(presets)) {
    const presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name) {
      if (presets.components[name].rules) {
        self2[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self2[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var texmath = { exports: {} };
var katex$1 = { exports: {} };
var katex = katex$1.exports;
var hasRequiredKatex;
function requireKatex() {
  if (hasRequiredKatex) return katex$1.exports;
  hasRequiredKatex = 1;
  (function(module, exports$1) {
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    })(typeof self !== "undefined" ? self : katex, function() {
      return (
        /******/
        (function() {
          var __webpack_require__ = {};
          !(function() {
            __webpack_require__.d = function(exports$12, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports$12, key)) {
                  Object.defineProperty(exports$12, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          !(function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          })();
          var __webpack_exports__ = {};
          __webpack_require__.d(__webpack_exports__, {
            "default": function() {
              return (
                /* binding */
                katex_webpack
              );
            }
          });
          class ParseError2 {
            // Error start position based on passed-in Token or ParseNode.
            // Length of affected text based on passed-in Token or ParseNode.
            // The underlying error message without any context added.
            constructor(message, token) {
              this.name = void 0;
              this.position = void 0;
              this.length = void 0;
              this.rawMessage = void 0;
              let error2 = "KaTeX parse error: " + message;
              let start;
              let end;
              const loc = token && token.loc;
              if (loc && loc.start <= loc.end) {
                const input = loc.lexer.input;
                start = loc.start;
                end = loc.end;
                if (start === input.length) {
                  error2 += " at end of input: ";
                } else {
                  error2 += " at position " + (start + 1) + ": ";
                }
                const underlined = input.slice(start, end).replace(/[^]/g, "$&");
                let left;
                if (start > 15) {
                  left = "" + input.slice(start - 15, start);
                } else {
                  left = input.slice(0, start);
                }
                let right;
                if (end + 15 < input.length) {
                  right = input.slice(end, end + 15) + "";
                } else {
                  right = input.slice(end);
                }
                error2 += left + underlined + right;
              }
              const self2 = new Error(error2);
              self2.name = "ParseError";
              self2.__proto__ = ParseError2.prototype;
              self2.position = start;
              if (start != null && end != null) {
                self2.length = end - start;
              }
              self2.rawMessage = message;
              return self2;
            }
          }
          ParseError2.prototype.__proto__ = Error.prototype;
          var src_ParseError = ParseError2;
          const deflt3 = function(setting, defaultIfUndefined) {
            return setting === void 0 ? defaultIfUndefined : setting;
          };
          const uppercase2 = /([A-Z])/g;
          const hyphenate3 = function(str) {
            return str.replace(uppercase2, "-$1").toLowerCase();
          };
          const ESCAPE_LOOKUP2 = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;",
            "'": "&#x27;"
          };
          const ESCAPE_REGEX2 = /[&><"']/g;
          function utils_escape(text2) {
            return String(text2).replace(ESCAPE_REGEX2, (match2) => ESCAPE_LOOKUP2[match2]);
          }
          const getBaseElem3 = function(group) {
            if (group.type === "ordgroup") {
              if (group.body.length === 1) {
                return getBaseElem3(group.body[0]);
              } else {
                return group;
              }
            } else if (group.type === "color") {
              if (group.body.length === 1) {
                return getBaseElem3(group.body[0]);
              } else {
                return group;
              }
            } else if (group.type === "font") {
              return getBaseElem3(group.body);
            } else {
              return group;
            }
          };
          const isCharacterBox3 = function(group) {
            const baseElem = getBaseElem3(group);
            return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
          };
          const assert3 = function(value) {
            if (!value) {
              throw new Error("Expected non-null, but got " + String(value));
            }
            return value;
          };
          const protocolFromUrl3 = function(url) {
            const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
            if (!protocol) {
              return "_relative";
            }
            if (protocol[2] !== ":") {
              return null;
            }
            if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
              return null;
            }
            return protocol[1].toLowerCase();
          };
          var utils2 = {
            deflt: deflt3,
            escape: utils_escape,
            hyphenate: hyphenate3,
            getBaseElem: getBaseElem3,
            isCharacterBox: isCharacterBox3,
            protocolFromUrl: protocolFromUrl3
          };
          const SETTINGS_SCHEMA2 = {
            displayMode: {
              type: "boolean",
              description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
              cli: "-d, --display-mode"
            },
            output: {
              type: {
                enum: ["htmlAndMathml", "html", "mathml"]
              },
              description: "Determines the markup language of the output.",
              cli: "-F, --format <type>"
            },
            leqno: {
              type: "boolean",
              description: "Render display math in leqno style (left-justified tags)."
            },
            fleqn: {
              type: "boolean",
              description: "Render display math flush left."
            },
            throwOnError: {
              type: "boolean",
              default: true,
              cli: "-t, --no-throw-on-error",
              cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
            },
            errorColor: {
              type: "string",
              default: "#cc0000",
              cli: "-c, --error-color <color>",
              cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
              cliProcessor: (color2) => "#" + color2
            },
            macros: {
              type: "object",
              cli: "-m, --macro <def>",
              cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
              cliDefault: [],
              cliProcessor: (def, defs) => {
                defs.push(def);
                return defs;
              }
            },
            minRuleThickness: {
              type: "number",
              description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
              processor: (t) => Math.max(0, t),
              cli: "--min-rule-thickness <size>",
              cliProcessor: parseFloat
            },
            colorIsTextColor: {
              type: "boolean",
              description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
              cli: "-b, --color-is-text-color"
            },
            strict: {
              type: [{
                enum: ["warn", "ignore", "error"]
              }, "boolean", "function"],
              description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
              cli: "-S, --strict",
              cliDefault: false
            },
            trust: {
              type: ["boolean", "function"],
              description: "Trust the input, enabling all HTML features such as \\url.",
              cli: "-T, --trust"
            },
            maxSize: {
              type: "number",
              default: Infinity,
              description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
              processor: (s) => Math.max(0, s),
              cli: "-s, --max-size <n>",
              cliProcessor: parseInt
            },
            maxExpand: {
              type: "number",
              default: 1e3,
              description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
              processor: (n) => Math.max(0, n),
              cli: "-e, --max-expand <n>",
              cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
            },
            globalGroup: {
              type: "boolean",
              cli: false
            }
          };
          function getDefaultValue2(schema) {
            if (schema.default) {
              return schema.default;
            }
            const type = schema.type;
            const defaultType = Array.isArray(type) ? type[0] : type;
            if (typeof defaultType !== "string") {
              return defaultType.enum[0];
            }
            switch (defaultType) {
              case "boolean":
                return false;
              case "string":
                return "";
              case "number":
                return 0;
              case "object":
                return {};
            }
          }
          class Settings2 {
            constructor(options) {
              this.displayMode = void 0;
              this.output = void 0;
              this.leqno = void 0;
              this.fleqn = void 0;
              this.throwOnError = void 0;
              this.errorColor = void 0;
              this.macros = void 0;
              this.minRuleThickness = void 0;
              this.colorIsTextColor = void 0;
              this.strict = void 0;
              this.trust = void 0;
              this.maxSize = void 0;
              this.maxExpand = void 0;
              this.globalGroup = void 0;
              options = options || {};
              for (const prop in SETTINGS_SCHEMA2) {
                if (SETTINGS_SCHEMA2.hasOwnProperty(prop)) {
                  const schema = SETTINGS_SCHEMA2[prop];
                  this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue2(schema);
                }
              }
            }
            /**
             * Report nonstrict (non-LaTeX-compatible) input.
             * Can safely not be called if `this.strict` is false in JavaScript.
             */
            reportNonstrict(errorCode, errorMsg, token) {
              let strict = this.strict;
              if (typeof strict === "function") {
                strict = strict(errorCode, errorMsg, token);
              }
              if (!strict || strict === "ignore") {
                return;
              } else if (strict === true || strict === "error") {
                throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
              } else if (strict === "warn") {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
              } else {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
              }
            }
            /**
             * Check whether to apply strict (LaTeX-adhering) behavior for unusual
             * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
             * instead, "error" translates to a return value of `true`, while "ignore"
             * translates to a return value of `false`.  May still print a warning:
             * "warn" prints a warning and returns `false`.
             * This is for the second category of `errorCode`s listed in the README.
             */
            useStrictBehavior(errorCode, errorMsg, token) {
              let strict = this.strict;
              if (typeof strict === "function") {
                try {
                  strict = strict(errorCode, errorMsg, token);
                } catch (error2) {
                  strict = "error";
                }
              }
              if (!strict || strict === "ignore") {
                return false;
              } else if (strict === true || strict === "error") {
                return true;
              } else if (strict === "warn") {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                return false;
              } else {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                return false;
              }
            }
            /**
             * Check whether to test potentially dangerous input, and return
             * `true` (trusted) or `false` (untrusted).  The sole argument `context`
             * should be an object with `command` field specifying the relevant LaTeX
             * command (as a string starting with `\`), and any other arguments, etc.
             * If `context` has a `url` field, a `protocol` field will automatically
             * get added by this function (changing the specified object).
             */
            isTrusted(context) {
              if (context.url && !context.protocol) {
                const protocol = utils2.protocolFromUrl(context.url);
                if (protocol == null) {
                  return false;
                }
                context.protocol = protocol;
              }
              const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
              return Boolean(trust);
            }
          }
          class Style2 {
            constructor(id, size, cramped) {
              this.id = void 0;
              this.size = void 0;
              this.cramped = void 0;
              this.id = id;
              this.size = size;
              this.cramped = cramped;
            }
            /**
             * Get the style of a superscript given a base in the current style.
             */
            sup() {
              return styles2[sup2[this.id]];
            }
            /**
             * Get the style of a subscript given a base in the current style.
             */
            sub() {
              return styles2[sub2[this.id]];
            }
            /**
             * Get the style of a fraction numerator given the fraction in the current
             * style.
             */
            fracNum() {
              return styles2[fracNum2[this.id]];
            }
            /**
             * Get the style of a fraction denominator given the fraction in the current
             * style.
             */
            fracDen() {
              return styles2[fracDen2[this.id]];
            }
            /**
             * Get the cramped version of a style (in particular, cramping a cramped style
             * doesn't change the style).
             */
            cramp() {
              return styles2[cramp2[this.id]];
            }
            /**
             * Get a text or display version of this style.
             */
            text() {
              return styles2[Style_text[this.id]];
            }
            /**
             * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
             */
            isTight() {
              return this.size >= 2;
            }
          }
          const D2 = 0;
          const Dc2 = 1;
          const T2 = 2;
          const Tc2 = 3;
          const S2 = 4;
          const Sc2 = 5;
          const SS2 = 6;
          const SSc2 = 7;
          const styles2 = [new Style2(D2, 0, false), new Style2(Dc2, 0, true), new Style2(T2, 1, false), new Style2(Tc2, 1, true), new Style2(S2, 2, false), new Style2(Sc2, 2, true), new Style2(SS2, 3, false), new Style2(SSc2, 3, true)];
          const sup2 = [S2, Sc2, S2, Sc2, SS2, SSc2, SS2, SSc2];
          const sub2 = [Sc2, Sc2, Sc2, Sc2, SSc2, SSc2, SSc2, SSc2];
          const fracNum2 = [T2, Tc2, S2, Sc2, SS2, SSc2, SS2, SSc2];
          const fracDen2 = [Tc2, Tc2, Sc2, Sc2, SSc2, SSc2, SSc2, SSc2];
          const cramp2 = [Dc2, Dc2, Tc2, Tc2, Sc2, Sc2, SSc2, SSc2];
          const Style_text = [D2, Dc2, T2, Tc2, T2, Tc2, T2, Tc2];
          var src_Style = {
            DISPLAY: styles2[D2],
            TEXT: styles2[T2],
            SCRIPT: styles2[S2],
            SCRIPTSCRIPT: styles2[SS2]
          };
          const scriptData2 = [{
            // Latin characters beyond the Latin-1 characters we have metrics for.
            // Needed for Czech, Hungarian and Turkish text, for example.
            name: "latin",
            blocks: [
              [256, 591],
              // Latin Extended-A and Latin Extended-B
              [768, 879]
              // Combining Diacritical marks
            ]
          }, {
            // The Cyrillic script used by Russian and related languages.
            // A Cyrillic subset used to be supported as explicitly defined
            // symbols in symbols.js
            name: "cyrillic",
            blocks: [[1024, 1279]]
          }, {
            // Armenian
            name: "armenian",
            blocks: [[1328, 1423]]
          }, {
            // The Brahmic scripts of South and Southeast Asia
            // Devanagari (0900097F)
            // Bengali (098009FF)
            // Gurmukhi (0A000A7F)
            // Gujarati (0A800AFF)
            // Oriya (0B000B7F)
            // Tamil (0B800BFF)
            // Telugu (0C000C7F)
            // Kannada (0C800CFF)
            // Malayalam (0D000D7F)
            // Sinhala (0D800DFF)
            // Thai (0E000E7F)
            // Lao (0E800EFF)
            // Tibetan (0F000FFF)
            // Myanmar (1000109F)
            name: "brahmic",
            blocks: [[2304, 4255]]
          }, {
            name: "georgian",
            blocks: [[4256, 4351]]
          }, {
            // Chinese and Japanese.
            // The "k" in cjk is for Korean, but we've separated Korean out
            name: "cjk",
            blocks: [
              [12288, 12543],
              // CJK symbols and punctuation, Hiragana, Katakana
              [19968, 40879],
              // CJK ideograms
              [65280, 65376]
              // Fullwidth punctuation
              // TODO: add halfwidth Katakana and Romanji glyphs
            ]
          }, {
            // Korean
            name: "hangul",
            blocks: [[44032, 55215]]
          }];
          function scriptFromCodepoint2(codepoint) {
            for (let i = 0; i < scriptData2.length; i++) {
              const script = scriptData2[i];
              for (let i2 = 0; i2 < script.blocks.length; i2++) {
                const block2 = script.blocks[i2];
                if (codepoint >= block2[0] && codepoint <= block2[1]) {
                  return script.name;
                }
              }
            }
            return null;
          }
          const allBlocks2 = [];
          scriptData2.forEach((s) => s.blocks.forEach((b) => allBlocks2.push(...b)));
          function supportedCodepoint2(codepoint) {
            for (let i = 0; i < allBlocks2.length; i += 2) {
              if (codepoint >= allBlocks2[i] && codepoint <= allBlocks2[i + 1]) {
                return true;
              }
            }
            return false;
          }
          const hLinePad2 = 80;
          const sqrtMain3 = function(extraVinculum, hLinePad3) {
            return "M95," + (622 + extraVinculum + hLinePad3) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad3 + "h400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize13 = function(extraVinculum, hLinePad3) {
            return "M263," + (601 + extraVinculum + hLinePad3) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad3 + "h400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize23 = function(extraVinculum, hLinePad3) {
            return "M983 " + (10 + extraVinculum + hLinePad3) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad3 + "h400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize33 = function(extraVinculum, hLinePad3) {
            return "M424," + (2398 + extraVinculum + hLinePad3) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad3 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize43 = function(extraVinculum, hLinePad3) {
            return "M473," + (2713 + extraVinculum + hLinePad3) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad3 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
          };
          const phasePath3 = function(y) {
            const x = y / 2;
            return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
          };
          const sqrtTall3 = function(extraVinculum, hLinePad3, viewBoxHeight) {
            const vertSegment = viewBoxHeight - 54 - hLinePad3 - extraVinculum;
            return "M702 " + (extraVinculum + hLinePad3) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad3 + "H400000v" + (40 + extraVinculum) + "H742z";
          };
          const sqrtPath3 = function(size, extraVinculum, viewBoxHeight) {
            extraVinculum = 1e3 * extraVinculum;
            let path3 = "";
            switch (size) {
              case "sqrtMain":
                path3 = sqrtMain3(extraVinculum, hLinePad2);
                break;
              case "sqrtSize1":
                path3 = sqrtSize13(extraVinculum, hLinePad2);
                break;
              case "sqrtSize2":
                path3 = sqrtSize23(extraVinculum, hLinePad2);
                break;
              case "sqrtSize3":
                path3 = sqrtSize33(extraVinculum, hLinePad2);
                break;
              case "sqrtSize4":
                path3 = sqrtSize43(extraVinculum, hLinePad2);
                break;
              case "sqrtTall":
                path3 = sqrtTall3(extraVinculum, hLinePad2, viewBoxHeight);
            }
            return path3;
          };
          const innerPath3 = function(name, height) {
            switch (name) {
              case "":
                return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
              case "":
                return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
              case "":
                return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
              case "":
                return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
              case "":
                return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
              case "":
                return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
              case "":
                return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
              case "":
                return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
              case "":
                return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
              default:
                return "";
            }
          };
          const path2 = {
            // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
            doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
            // doublerightarrow is from glyph U+21D2 in font KaTeX Main
            doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
            // leftarrow is from glyph U+2190 in font KaTeX Main
            leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
            // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
            leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
            leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
            // overgroup is from the MnSymbol package (public domain)
            leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
            leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
            // Harpoons are from glyph U+21BD in font KaTeX Main
            leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
            leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
            leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
            leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
            // hook is from glyph U+21A9 in font KaTeX Main
            lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
            leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
            leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
            // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
            leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
            longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
            midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
            midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
            oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
            oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
            oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
            oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
            rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
            rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
            rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
            rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
            rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
            rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
            rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
            rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
            rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
            righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
            rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
            rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
            // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
            twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
            twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
            // tilde1 is a modified version of a glyph from the MnSymbol package
            tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
            // ditto tilde2, tilde3, & tilde4
            tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
            tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
            tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
            // vec is from glyph U+20D7 in font KaTeX Main
            vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
            // widehat1 is a modified version of a glyph from the MnSymbol package
            widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
            // ditto widehat2, widehat3, & widehat4
            widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            // widecheck paths are all inverted versions of widehat
            widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
            widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            // The next ten paths support reaction arrows from the mhchem package.
            // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
            // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
            baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
            // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
            rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
            // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
            // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
            baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
            rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
            shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
            shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
          };
          const tallDelim3 = function(label, midHeight) {
            switch (label) {
              case "lbrack":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
              case "rbrack":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
              case "vert":
                return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
              case "doublevert":
                return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
              case "lfloor":
                return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
              case "rfloor":
                return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
              case "lceil":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
              case "rceil":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
              case "lparen":
                return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
              case "rparen":
                return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
              default:
                throw new Error("Unknown stretchy delimiter.");
            }
          };
          var fontMetricsData2 = {
            "AMS-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.68889, 0, 0, 0.72222],
              "66": [0, 0.68889, 0, 0, 0.66667],
              "67": [0, 0.68889, 0, 0, 0.72222],
              "68": [0, 0.68889, 0, 0, 0.72222],
              "69": [0, 0.68889, 0, 0, 0.66667],
              "70": [0, 0.68889, 0, 0, 0.61111],
              "71": [0, 0.68889, 0, 0, 0.77778],
              "72": [0, 0.68889, 0, 0, 0.77778],
              "73": [0, 0.68889, 0, 0, 0.38889],
              "74": [0.16667, 0.68889, 0, 0, 0.5],
              "75": [0, 0.68889, 0, 0, 0.77778],
              "76": [0, 0.68889, 0, 0, 0.66667],
              "77": [0, 0.68889, 0, 0, 0.94445],
              "78": [0, 0.68889, 0, 0, 0.72222],
              "79": [0.16667, 0.68889, 0, 0, 0.77778],
              "80": [0, 0.68889, 0, 0, 0.61111],
              "81": [0.16667, 0.68889, 0, 0, 0.77778],
              "82": [0, 0.68889, 0, 0, 0.72222],
              "83": [0, 0.68889, 0, 0, 0.55556],
              "84": [0, 0.68889, 0, 0, 0.66667],
              "85": [0, 0.68889, 0, 0, 0.72222],
              "86": [0, 0.68889, 0, 0, 0.72222],
              "87": [0, 0.68889, 0, 0, 1],
              "88": [0, 0.68889, 0, 0, 0.72222],
              "89": [0, 0.68889, 0, 0, 0.72222],
              "90": [0, 0.68889, 0, 0, 0.66667],
              "107": [0, 0.68889, 0, 0, 0.55556],
              "160": [0, 0, 0, 0, 0.25],
              "165": [0, 0.675, 0.025, 0, 0.75],
              "174": [0.15559, 0.69224, 0, 0, 0.94666],
              "240": [0, 0.68889, 0, 0, 0.55556],
              "295": [0, 0.68889, 0, 0, 0.54028],
              "710": [0, 0.825, 0, 0, 2.33334],
              "732": [0, 0.9, 0, 0, 2.33334],
              "770": [0, 0.825, 0, 0, 2.33334],
              "771": [0, 0.9, 0, 0, 2.33334],
              "989": [0.08167, 0.58167, 0, 0, 0.77778],
              "1008": [0, 0.43056, 0.04028, 0, 0.66667],
              "8245": [0, 0.54986, 0, 0, 0.275],
              "8463": [0, 0.68889, 0, 0, 0.54028],
              "8487": [0, 0.68889, 0, 0, 0.72222],
              "8498": [0, 0.68889, 0, 0, 0.55556],
              "8502": [0, 0.68889, 0, 0, 0.66667],
              "8503": [0, 0.68889, 0, 0, 0.44445],
              "8504": [0, 0.68889, 0, 0, 0.66667],
              "8513": [0, 0.68889, 0, 0, 0.63889],
              "8592": [-0.03598, 0.46402, 0, 0, 0.5],
              "8594": [-0.03598, 0.46402, 0, 0, 0.5],
              "8602": [-0.13313, 0.36687, 0, 0, 1],
              "8603": [-0.13313, 0.36687, 0, 0, 1],
              "8606": [0.01354, 0.52239, 0, 0, 1],
              "8608": [0.01354, 0.52239, 0, 0, 1],
              "8610": [0.01354, 0.52239, 0, 0, 1.11111],
              "8611": [0.01354, 0.52239, 0, 0, 1.11111],
              "8619": [0, 0.54986, 0, 0, 1],
              "8620": [0, 0.54986, 0, 0, 1],
              "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
              "8622": [-0.13313, 0.36687, 0, 0, 1],
              "8624": [0, 0.69224, 0, 0, 0.5],
              "8625": [0, 0.69224, 0, 0, 0.5],
              "8630": [0, 0.43056, 0, 0, 1],
              "8631": [0, 0.43056, 0, 0, 1],
              "8634": [0.08198, 0.58198, 0, 0, 0.77778],
              "8635": [0.08198, 0.58198, 0, 0, 0.77778],
              "8638": [0.19444, 0.69224, 0, 0, 0.41667],
              "8639": [0.19444, 0.69224, 0, 0, 0.41667],
              "8642": [0.19444, 0.69224, 0, 0, 0.41667],
              "8643": [0.19444, 0.69224, 0, 0, 0.41667],
              "8644": [0.1808, 0.675, 0, 0, 1],
              "8646": [0.1808, 0.675, 0, 0, 1],
              "8647": [0.1808, 0.675, 0, 0, 1],
              "8648": [0.19444, 0.69224, 0, 0, 0.83334],
              "8649": [0.1808, 0.675, 0, 0, 1],
              "8650": [0.19444, 0.69224, 0, 0, 0.83334],
              "8651": [0.01354, 0.52239, 0, 0, 1],
              "8652": [0.01354, 0.52239, 0, 0, 1],
              "8653": [-0.13313, 0.36687, 0, 0, 1],
              "8654": [-0.13313, 0.36687, 0, 0, 1],
              "8655": [-0.13313, 0.36687, 0, 0, 1],
              "8666": [0.13667, 0.63667, 0, 0, 1],
              "8667": [0.13667, 0.63667, 0, 0, 1],
              "8669": [-0.13313, 0.37788, 0, 0, 1],
              "8672": [-0.064, 0.437, 0, 0, 1.334],
              "8674": [-0.064, 0.437, 0, 0, 1.334],
              "8705": [0, 0.825, 0, 0, 0.5],
              "8708": [0, 0.68889, 0, 0, 0.55556],
              "8709": [0.08167, 0.58167, 0, 0, 0.77778],
              "8717": [0, 0.43056, 0, 0, 0.42917],
              "8722": [-0.03598, 0.46402, 0, 0, 0.5],
              "8724": [0.08198, 0.69224, 0, 0, 0.77778],
              "8726": [0.08167, 0.58167, 0, 0, 0.77778],
              "8733": [0, 0.69224, 0, 0, 0.77778],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8737": [0, 0.69224, 0, 0, 0.72222],
              "8738": [0.03517, 0.52239, 0, 0, 0.72222],
              "8739": [0.08167, 0.58167, 0, 0, 0.22222],
              "8740": [0.25142, 0.74111, 0, 0, 0.27778],
              "8741": [0.08167, 0.58167, 0, 0, 0.38889],
              "8742": [0.25142, 0.74111, 0, 0, 0.5],
              "8756": [0, 0.69224, 0, 0, 0.66667],
              "8757": [0, 0.69224, 0, 0, 0.66667],
              "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
              "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8774": [0.30274, 0.79383, 0, 0, 0.77778],
              "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
              "8778": [0.08167, 0.58167, 0, 0, 0.77778],
              "8782": [0.06062, 0.54986, 0, 0, 0.77778],
              "8783": [0.06062, 0.54986, 0, 0, 0.77778],
              "8785": [0.08198, 0.58198, 0, 0, 0.77778],
              "8786": [0.08198, 0.58198, 0, 0, 0.77778],
              "8787": [0.08198, 0.58198, 0, 0, 0.77778],
              "8790": [0, 0.69224, 0, 0, 0.77778],
              "8791": [0.22958, 0.72958, 0, 0, 0.77778],
              "8796": [0.08198, 0.91667, 0, 0, 0.77778],
              "8806": [0.25583, 0.75583, 0, 0, 0.77778],
              "8807": [0.25583, 0.75583, 0, 0, 0.77778],
              "8808": [0.25142, 0.75726, 0, 0, 0.77778],
              "8809": [0.25142, 0.75726, 0, 0, 0.77778],
              "8812": [0.25583, 0.75583, 0, 0, 0.5],
              "8814": [0.20576, 0.70576, 0, 0, 0.77778],
              "8815": [0.20576, 0.70576, 0, 0, 0.77778],
              "8816": [0.30274, 0.79383, 0, 0, 0.77778],
              "8817": [0.30274, 0.79383, 0, 0, 0.77778],
              "8818": [0.22958, 0.72958, 0, 0, 0.77778],
              "8819": [0.22958, 0.72958, 0, 0, 0.77778],
              "8822": [0.1808, 0.675, 0, 0, 0.77778],
              "8823": [0.1808, 0.675, 0, 0, 0.77778],
              "8828": [0.13667, 0.63667, 0, 0, 0.77778],
              "8829": [0.13667, 0.63667, 0, 0, 0.77778],
              "8830": [0.22958, 0.72958, 0, 0, 0.77778],
              "8831": [0.22958, 0.72958, 0, 0, 0.77778],
              "8832": [0.20576, 0.70576, 0, 0, 0.77778],
              "8833": [0.20576, 0.70576, 0, 0, 0.77778],
              "8840": [0.30274, 0.79383, 0, 0, 0.77778],
              "8841": [0.30274, 0.79383, 0, 0, 0.77778],
              "8842": [0.13597, 0.63597, 0, 0, 0.77778],
              "8843": [0.13597, 0.63597, 0, 0, 0.77778],
              "8847": [0.03517, 0.54986, 0, 0, 0.77778],
              "8848": [0.03517, 0.54986, 0, 0, 0.77778],
              "8858": [0.08198, 0.58198, 0, 0, 0.77778],
              "8859": [0.08198, 0.58198, 0, 0, 0.77778],
              "8861": [0.08198, 0.58198, 0, 0, 0.77778],
              "8862": [0, 0.675, 0, 0, 0.77778],
              "8863": [0, 0.675, 0, 0, 0.77778],
              "8864": [0, 0.675, 0, 0, 0.77778],
              "8865": [0, 0.675, 0, 0, 0.77778],
              "8872": [0, 0.69224, 0, 0, 0.61111],
              "8873": [0, 0.69224, 0, 0, 0.72222],
              "8874": [0, 0.69224, 0, 0, 0.88889],
              "8876": [0, 0.68889, 0, 0, 0.61111],
              "8877": [0, 0.68889, 0, 0, 0.61111],
              "8878": [0, 0.68889, 0, 0, 0.72222],
              "8879": [0, 0.68889, 0, 0, 0.72222],
              "8882": [0.03517, 0.54986, 0, 0, 0.77778],
              "8883": [0.03517, 0.54986, 0, 0, 0.77778],
              "8884": [0.13667, 0.63667, 0, 0, 0.77778],
              "8885": [0.13667, 0.63667, 0, 0, 0.77778],
              "8888": [0, 0.54986, 0, 0, 1.11111],
              "8890": [0.19444, 0.43056, 0, 0, 0.55556],
              "8891": [0.19444, 0.69224, 0, 0, 0.61111],
              "8892": [0.19444, 0.69224, 0, 0, 0.61111],
              "8901": [0, 0.54986, 0, 0, 0.27778],
              "8903": [0.08167, 0.58167, 0, 0, 0.77778],
              "8905": [0.08167, 0.58167, 0, 0, 0.77778],
              "8906": [0.08167, 0.58167, 0, 0, 0.77778],
              "8907": [0, 0.69224, 0, 0, 0.77778],
              "8908": [0, 0.69224, 0, 0, 0.77778],
              "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
              "8910": [0, 0.54986, 0, 0, 0.76042],
              "8911": [0, 0.54986, 0, 0, 0.76042],
              "8912": [0.03517, 0.54986, 0, 0, 0.77778],
              "8913": [0.03517, 0.54986, 0, 0, 0.77778],
              "8914": [0, 0.54986, 0, 0, 0.66667],
              "8915": [0, 0.54986, 0, 0, 0.66667],
              "8916": [0, 0.69224, 0, 0, 0.66667],
              "8918": [0.0391, 0.5391, 0, 0, 0.77778],
              "8919": [0.0391, 0.5391, 0, 0, 0.77778],
              "8920": [0.03517, 0.54986, 0, 0, 1.33334],
              "8921": [0.03517, 0.54986, 0, 0, 1.33334],
              "8922": [0.38569, 0.88569, 0, 0, 0.77778],
              "8923": [0.38569, 0.88569, 0, 0, 0.77778],
              "8926": [0.13667, 0.63667, 0, 0, 0.77778],
              "8927": [0.13667, 0.63667, 0, 0, 0.77778],
              "8928": [0.30274, 0.79383, 0, 0, 0.77778],
              "8929": [0.30274, 0.79383, 0, 0, 0.77778],
              "8934": [0.23222, 0.74111, 0, 0, 0.77778],
              "8935": [0.23222, 0.74111, 0, 0, 0.77778],
              "8936": [0.23222, 0.74111, 0, 0, 0.77778],
              "8937": [0.23222, 0.74111, 0, 0, 0.77778],
              "8938": [0.20576, 0.70576, 0, 0, 0.77778],
              "8939": [0.20576, 0.70576, 0, 0, 0.77778],
              "8940": [0.30274, 0.79383, 0, 0, 0.77778],
              "8941": [0.30274, 0.79383, 0, 0, 0.77778],
              "8994": [0.19444, 0.69224, 0, 0, 0.77778],
              "8995": [0.19444, 0.69224, 0, 0, 0.77778],
              "9416": [0.15559, 0.69224, 0, 0, 0.90222],
              "9484": [0, 0.69224, 0, 0, 0.5],
              "9488": [0, 0.69224, 0, 0, 0.5],
              "9492": [0, 0.37788, 0, 0, 0.5],
              "9496": [0, 0.37788, 0, 0, 0.5],
              "9585": [0.19444, 0.68889, 0, 0, 0.88889],
              "9586": [0.19444, 0.74111, 0, 0, 0.88889],
              "9632": [0, 0.675, 0, 0, 0.77778],
              "9633": [0, 0.675, 0, 0, 0.77778],
              "9650": [0, 0.54986, 0, 0, 0.72222],
              "9651": [0, 0.54986, 0, 0, 0.72222],
              "9654": [0.03517, 0.54986, 0, 0, 0.77778],
              "9660": [0, 0.54986, 0, 0, 0.72222],
              "9661": [0, 0.54986, 0, 0, 0.72222],
              "9664": [0.03517, 0.54986, 0, 0, 0.77778],
              "9674": [0.11111, 0.69224, 0, 0, 0.66667],
              "9733": [0.19444, 0.69224, 0, 0, 0.94445],
              "10003": [0, 0.69224, 0, 0, 0.83334],
              "10016": [0, 0.69224, 0, 0, 0.83334],
              "10731": [0.11111, 0.69224, 0, 0, 0.66667],
              "10846": [0.19444, 0.75583, 0, 0, 0.61111],
              "10877": [0.13667, 0.63667, 0, 0, 0.77778],
              "10878": [0.13667, 0.63667, 0, 0, 0.77778],
              "10885": [0.25583, 0.75583, 0, 0, 0.77778],
              "10886": [0.25583, 0.75583, 0, 0, 0.77778],
              "10887": [0.13597, 0.63597, 0, 0, 0.77778],
              "10888": [0.13597, 0.63597, 0, 0, 0.77778],
              "10889": [0.26167, 0.75726, 0, 0, 0.77778],
              "10890": [0.26167, 0.75726, 0, 0, 0.77778],
              "10891": [0.48256, 0.98256, 0, 0, 0.77778],
              "10892": [0.48256, 0.98256, 0, 0, 0.77778],
              "10901": [0.13667, 0.63667, 0, 0, 0.77778],
              "10902": [0.13667, 0.63667, 0, 0, 0.77778],
              "10933": [0.25142, 0.75726, 0, 0, 0.77778],
              "10934": [0.25142, 0.75726, 0, 0, 0.77778],
              "10935": [0.26167, 0.75726, 0, 0, 0.77778],
              "10936": [0.26167, 0.75726, 0, 0, 0.77778],
              "10937": [0.26167, 0.75726, 0, 0, 0.77778],
              "10938": [0.26167, 0.75726, 0, 0, 0.77778],
              "10949": [0.25583, 0.75583, 0, 0, 0.77778],
              "10950": [0.25583, 0.75583, 0, 0, 0.77778],
              "10955": [0.28481, 0.79383, 0, 0, 0.77778],
              "10956": [0.28481, 0.79383, 0, 0, 0.77778],
              "57350": [0.08167, 0.58167, 0, 0, 0.22222],
              "57351": [0.08167, 0.58167, 0, 0, 0.38889],
              "57352": [0.08167, 0.58167, 0, 0, 0.77778],
              "57353": [0, 0.43056, 0.04028, 0, 0.66667],
              "57356": [0.25142, 0.75726, 0, 0, 0.77778],
              "57357": [0.25142, 0.75726, 0, 0, 0.77778],
              "57358": [0.41951, 0.91951, 0, 0, 0.77778],
              "57359": [0.30274, 0.79383, 0, 0, 0.77778],
              "57360": [0.30274, 0.79383, 0, 0, 0.77778],
              "57361": [0.41951, 0.91951, 0, 0, 0.77778],
              "57366": [0.25142, 0.75726, 0, 0, 0.77778],
              "57367": [0.25142, 0.75726, 0, 0, 0.77778],
              "57368": [0.25142, 0.75726, 0, 0, 0.77778],
              "57369": [0.25142, 0.75726, 0, 0, 0.77778],
              "57370": [0.13597, 0.63597, 0, 0, 0.77778],
              "57371": [0.13597, 0.63597, 0, 0, 0.77778]
            },
            "Caligraphic-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.68333, 0, 0.19445, 0.79847],
              "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
              "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
              "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
              "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
              "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
              "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
              "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
              "73": [0, 0.68333, 0.07382, 0, 0.54452],
              "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
              "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
              "76": [0, 0.68333, 0, 0.13889, 0.68972],
              "77": [0, 0.68333, 0, 0.13889, 1.2009],
              "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
              "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
              "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
              "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
              "82": [0, 0.68333, 0, 0.08334, 0.8475],
              "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
              "84": [0, 0.68333, 0.25417, 0, 0.54464],
              "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
              "86": [0, 0.68333, 0.08222, 0, 0.61278],
              "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
              "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
              "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
              "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
              "160": [0, 0, 0, 0, 0.25]
            },
            "Fraktur-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69141, 0, 0, 0.29574],
              "34": [0, 0.69141, 0, 0, 0.21471],
              "38": [0, 0.69141, 0, 0, 0.73786],
              "39": [0, 0.69141, 0, 0, 0.21201],
              "40": [0.24982, 0.74947, 0, 0, 0.38865],
              "41": [0.24982, 0.74947, 0, 0, 0.38865],
              "42": [0, 0.62119, 0, 0, 0.27764],
              "43": [0.08319, 0.58283, 0, 0, 0.75623],
              "44": [0, 0.10803, 0, 0, 0.27764],
              "45": [0.08319, 0.58283, 0, 0, 0.75623],
              "46": [0, 0.10803, 0, 0, 0.27764],
              "47": [0.24982, 0.74947, 0, 0, 0.50181],
              "48": [0, 0.47534, 0, 0, 0.50181],
              "49": [0, 0.47534, 0, 0, 0.50181],
              "50": [0, 0.47534, 0, 0, 0.50181],
              "51": [0.18906, 0.47534, 0, 0, 0.50181],
              "52": [0.18906, 0.47534, 0, 0, 0.50181],
              "53": [0.18906, 0.47534, 0, 0, 0.50181],
              "54": [0, 0.69141, 0, 0, 0.50181],
              "55": [0.18906, 0.47534, 0, 0, 0.50181],
              "56": [0, 0.69141, 0, 0, 0.50181],
              "57": [0.18906, 0.47534, 0, 0, 0.50181],
              "58": [0, 0.47534, 0, 0, 0.21606],
              "59": [0.12604, 0.47534, 0, 0, 0.21606],
              "61": [-0.13099, 0.36866, 0, 0, 0.75623],
              "63": [0, 0.69141, 0, 0, 0.36245],
              "65": [0, 0.69141, 0, 0, 0.7176],
              "66": [0, 0.69141, 0, 0, 0.88397],
              "67": [0, 0.69141, 0, 0, 0.61254],
              "68": [0, 0.69141, 0, 0, 0.83158],
              "69": [0, 0.69141, 0, 0, 0.66278],
              "70": [0.12604, 0.69141, 0, 0, 0.61119],
              "71": [0, 0.69141, 0, 0, 0.78539],
              "72": [0.06302, 0.69141, 0, 0, 0.7203],
              "73": [0, 0.69141, 0, 0, 0.55448],
              "74": [0.12604, 0.69141, 0, 0, 0.55231],
              "75": [0, 0.69141, 0, 0, 0.66845],
              "76": [0, 0.69141, 0, 0, 0.66602],
              "77": [0, 0.69141, 0, 0, 1.04953],
              "78": [0, 0.69141, 0, 0, 0.83212],
              "79": [0, 0.69141, 0, 0, 0.82699],
              "80": [0.18906, 0.69141, 0, 0, 0.82753],
              "81": [0.03781, 0.69141, 0, 0, 0.82699],
              "82": [0, 0.69141, 0, 0, 0.82807],
              "83": [0, 0.69141, 0, 0, 0.82861],
              "84": [0, 0.69141, 0, 0, 0.66899],
              "85": [0, 0.69141, 0, 0, 0.64576],
              "86": [0, 0.69141, 0, 0, 0.83131],
              "87": [0, 0.69141, 0, 0, 1.04602],
              "88": [0, 0.69141, 0, 0, 0.71922],
              "89": [0.18906, 0.69141, 0, 0, 0.83293],
              "90": [0.12604, 0.69141, 0, 0, 0.60201],
              "91": [0.24982, 0.74947, 0, 0, 0.27764],
              "93": [0.24982, 0.74947, 0, 0, 0.27764],
              "94": [0, 0.69141, 0, 0, 0.49965],
              "97": [0, 0.47534, 0, 0, 0.50046],
              "98": [0, 0.69141, 0, 0, 0.51315],
              "99": [0, 0.47534, 0, 0, 0.38946],
              "100": [0, 0.62119, 0, 0, 0.49857],
              "101": [0, 0.47534, 0, 0, 0.40053],
              "102": [0.18906, 0.69141, 0, 0, 0.32626],
              "103": [0.18906, 0.47534, 0, 0, 0.5037],
              "104": [0.18906, 0.69141, 0, 0, 0.52126],
              "105": [0, 0.69141, 0, 0, 0.27899],
              "106": [0, 0.69141, 0, 0, 0.28088],
              "107": [0, 0.69141, 0, 0, 0.38946],
              "108": [0, 0.69141, 0, 0, 0.27953],
              "109": [0, 0.47534, 0, 0, 0.76676],
              "110": [0, 0.47534, 0, 0, 0.52666],
              "111": [0, 0.47534, 0, 0, 0.48885],
              "112": [0.18906, 0.52396, 0, 0, 0.50046],
              "113": [0.18906, 0.47534, 0, 0, 0.48912],
              "114": [0, 0.47534, 0, 0, 0.38919],
              "115": [0, 0.47534, 0, 0, 0.44266],
              "116": [0, 0.62119, 0, 0, 0.33301],
              "117": [0, 0.47534, 0, 0, 0.5172],
              "118": [0, 0.52396, 0, 0, 0.5118],
              "119": [0, 0.52396, 0, 0, 0.77351],
              "120": [0.18906, 0.47534, 0, 0, 0.38865],
              "121": [0.18906, 0.47534, 0, 0, 0.49884],
              "122": [0.18906, 0.47534, 0, 0, 0.39054],
              "160": [0, 0, 0, 0, 0.25],
              "8216": [0, 0.69141, 0, 0, 0.21471],
              "8217": [0, 0.69141, 0, 0, 0.21471],
              "58112": [0, 0.62119, 0, 0, 0.49749],
              "58113": [0, 0.62119, 0, 0, 0.4983],
              "58114": [0.18906, 0.69141, 0, 0, 0.33328],
              "58115": [0.18906, 0.69141, 0, 0, 0.32923],
              "58116": [0.18906, 0.47534, 0, 0, 0.50343],
              "58117": [0, 0.69141, 0, 0, 0.33301],
              "58118": [0, 0.62119, 0, 0, 0.33409],
              "58119": [0, 0.47534, 0, 0, 0.50073]
            },
            "Main-Bold": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.35],
              "34": [0, 0.69444, 0, 0, 0.60278],
              "35": [0.19444, 0.69444, 0, 0, 0.95833],
              "36": [0.05556, 0.75, 0, 0, 0.575],
              "37": [0.05556, 0.75, 0, 0, 0.95833],
              "38": [0, 0.69444, 0, 0, 0.89444],
              "39": [0, 0.69444, 0, 0, 0.31944],
              "40": [0.25, 0.75, 0, 0, 0.44722],
              "41": [0.25, 0.75, 0, 0, 0.44722],
              "42": [0, 0.75, 0, 0, 0.575],
              "43": [0.13333, 0.63333, 0, 0, 0.89444],
              "44": [0.19444, 0.15556, 0, 0, 0.31944],
              "45": [0, 0.44444, 0, 0, 0.38333],
              "46": [0, 0.15556, 0, 0, 0.31944],
              "47": [0.25, 0.75, 0, 0, 0.575],
              "48": [0, 0.64444, 0, 0, 0.575],
              "49": [0, 0.64444, 0, 0, 0.575],
              "50": [0, 0.64444, 0, 0, 0.575],
              "51": [0, 0.64444, 0, 0, 0.575],
              "52": [0, 0.64444, 0, 0, 0.575],
              "53": [0, 0.64444, 0, 0, 0.575],
              "54": [0, 0.64444, 0, 0, 0.575],
              "55": [0, 0.64444, 0, 0, 0.575],
              "56": [0, 0.64444, 0, 0, 0.575],
              "57": [0, 0.64444, 0, 0, 0.575],
              "58": [0, 0.44444, 0, 0, 0.31944],
              "59": [0.19444, 0.44444, 0, 0, 0.31944],
              "60": [0.08556, 0.58556, 0, 0, 0.89444],
              "61": [-0.10889, 0.39111, 0, 0, 0.89444],
              "62": [0.08556, 0.58556, 0, 0, 0.89444],
              "63": [0, 0.69444, 0, 0, 0.54305],
              "64": [0, 0.69444, 0, 0, 0.89444],
              "65": [0, 0.68611, 0, 0, 0.86944],
              "66": [0, 0.68611, 0, 0, 0.81805],
              "67": [0, 0.68611, 0, 0, 0.83055],
              "68": [0, 0.68611, 0, 0, 0.88194],
              "69": [0, 0.68611, 0, 0, 0.75555],
              "70": [0, 0.68611, 0, 0, 0.72361],
              "71": [0, 0.68611, 0, 0, 0.90416],
              "72": [0, 0.68611, 0, 0, 0.9],
              "73": [0, 0.68611, 0, 0, 0.43611],
              "74": [0, 0.68611, 0, 0, 0.59444],
              "75": [0, 0.68611, 0, 0, 0.90138],
              "76": [0, 0.68611, 0, 0, 0.69166],
              "77": [0, 0.68611, 0, 0, 1.09166],
              "78": [0, 0.68611, 0, 0, 0.9],
              "79": [0, 0.68611, 0, 0, 0.86388],
              "80": [0, 0.68611, 0, 0, 0.78611],
              "81": [0.19444, 0.68611, 0, 0, 0.86388],
              "82": [0, 0.68611, 0, 0, 0.8625],
              "83": [0, 0.68611, 0, 0, 0.63889],
              "84": [0, 0.68611, 0, 0, 0.8],
              "85": [0, 0.68611, 0, 0, 0.88472],
              "86": [0, 0.68611, 0.01597, 0, 0.86944],
              "87": [0, 0.68611, 0.01597, 0, 1.18888],
              "88": [0, 0.68611, 0, 0, 0.86944],
              "89": [0, 0.68611, 0.02875, 0, 0.86944],
              "90": [0, 0.68611, 0, 0, 0.70277],
              "91": [0.25, 0.75, 0, 0, 0.31944],
              "92": [0.25, 0.75, 0, 0, 0.575],
              "93": [0.25, 0.75, 0, 0, 0.31944],
              "94": [0, 0.69444, 0, 0, 0.575],
              "95": [0.31, 0.13444, 0.03194, 0, 0.575],
              "97": [0, 0.44444, 0, 0, 0.55902],
              "98": [0, 0.69444, 0, 0, 0.63889],
              "99": [0, 0.44444, 0, 0, 0.51111],
              "100": [0, 0.69444, 0, 0, 0.63889],
              "101": [0, 0.44444, 0, 0, 0.52708],
              "102": [0, 0.69444, 0.10903, 0, 0.35139],
              "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
              "104": [0, 0.69444, 0, 0, 0.63889],
              "105": [0, 0.69444, 0, 0, 0.31944],
              "106": [0.19444, 0.69444, 0, 0, 0.35139],
              "107": [0, 0.69444, 0, 0, 0.60694],
              "108": [0, 0.69444, 0, 0, 0.31944],
              "109": [0, 0.44444, 0, 0, 0.95833],
              "110": [0, 0.44444, 0, 0, 0.63889],
              "111": [0, 0.44444, 0, 0, 0.575],
              "112": [0.19444, 0.44444, 0, 0, 0.63889],
              "113": [0.19444, 0.44444, 0, 0, 0.60694],
              "114": [0, 0.44444, 0, 0, 0.47361],
              "115": [0, 0.44444, 0, 0, 0.45361],
              "116": [0, 0.63492, 0, 0, 0.44722],
              "117": [0, 0.44444, 0, 0, 0.63889],
              "118": [0, 0.44444, 0.01597, 0, 0.60694],
              "119": [0, 0.44444, 0.01597, 0, 0.83055],
              "120": [0, 0.44444, 0, 0, 0.60694],
              "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
              "122": [0, 0.44444, 0, 0, 0.51111],
              "123": [0.25, 0.75, 0, 0, 0.575],
              "124": [0.25, 0.75, 0, 0, 0.31944],
              "125": [0.25, 0.75, 0, 0, 0.575],
              "126": [0.35, 0.34444, 0, 0, 0.575],
              "160": [0, 0, 0, 0, 0.25],
              "163": [0, 0.69444, 0, 0, 0.86853],
              "168": [0, 0.69444, 0, 0, 0.575],
              "172": [0, 0.44444, 0, 0, 0.76666],
              "176": [0, 0.69444, 0, 0, 0.86944],
              "177": [0.13333, 0.63333, 0, 0, 0.89444],
              "184": [0.17014, 0, 0, 0, 0.51111],
              "198": [0, 0.68611, 0, 0, 1.04166],
              "215": [0.13333, 0.63333, 0, 0, 0.89444],
              "216": [0.04861, 0.73472, 0, 0, 0.89444],
              "223": [0, 0.69444, 0, 0, 0.59722],
              "230": [0, 0.44444, 0, 0, 0.83055],
              "247": [0.13333, 0.63333, 0, 0, 0.89444],
              "248": [0.09722, 0.54167, 0, 0, 0.575],
              "305": [0, 0.44444, 0, 0, 0.31944],
              "338": [0, 0.68611, 0, 0, 1.16944],
              "339": [0, 0.44444, 0, 0, 0.89444],
              "567": [0.19444, 0.44444, 0, 0, 0.35139],
              "710": [0, 0.69444, 0, 0, 0.575],
              "711": [0, 0.63194, 0, 0, 0.575],
              "713": [0, 0.59611, 0, 0, 0.575],
              "714": [0, 0.69444, 0, 0, 0.575],
              "715": [0, 0.69444, 0, 0, 0.575],
              "728": [0, 0.69444, 0, 0, 0.575],
              "729": [0, 0.69444, 0, 0, 0.31944],
              "730": [0, 0.69444, 0, 0, 0.86944],
              "732": [0, 0.69444, 0, 0, 0.575],
              "733": [0, 0.69444, 0, 0, 0.575],
              "915": [0, 0.68611, 0, 0, 0.69166],
              "916": [0, 0.68611, 0, 0, 0.95833],
              "920": [0, 0.68611, 0, 0, 0.89444],
              "923": [0, 0.68611, 0, 0, 0.80555],
              "926": [0, 0.68611, 0, 0, 0.76666],
              "928": [0, 0.68611, 0, 0, 0.9],
              "931": [0, 0.68611, 0, 0, 0.83055],
              "933": [0, 0.68611, 0, 0, 0.89444],
              "934": [0, 0.68611, 0, 0, 0.83055],
              "936": [0, 0.68611, 0, 0, 0.89444],
              "937": [0, 0.68611, 0, 0, 0.83055],
              "8211": [0, 0.44444, 0.03194, 0, 0.575],
              "8212": [0, 0.44444, 0.03194, 0, 1.14999],
              "8216": [0, 0.69444, 0, 0, 0.31944],
              "8217": [0, 0.69444, 0, 0, 0.31944],
              "8220": [0, 0.69444, 0, 0, 0.60278],
              "8221": [0, 0.69444, 0, 0, 0.60278],
              "8224": [0.19444, 0.69444, 0, 0, 0.51111],
              "8225": [0.19444, 0.69444, 0, 0, 0.51111],
              "8242": [0, 0.55556, 0, 0, 0.34444],
              "8407": [0, 0.72444, 0.15486, 0, 0.575],
              "8463": [0, 0.69444, 0, 0, 0.66759],
              "8465": [0, 0.69444, 0, 0, 0.83055],
              "8467": [0, 0.69444, 0, 0, 0.47361],
              "8472": [0.19444, 0.44444, 0, 0, 0.74027],
              "8476": [0, 0.69444, 0, 0, 0.83055],
              "8501": [0, 0.69444, 0, 0, 0.70277],
              "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8593": [0.19444, 0.69444, 0, 0, 0.575],
              "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8595": [0.19444, 0.69444, 0, 0, 0.575],
              "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8597": [0.25, 0.75, 0, 0, 0.575],
              "8598": [0.19444, 0.69444, 0, 0, 1.14999],
              "8599": [0.19444, 0.69444, 0, 0, 1.14999],
              "8600": [0.19444, 0.69444, 0, 0, 1.14999],
              "8601": [0.19444, 0.69444, 0, 0, 1.14999],
              "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8657": [0.19444, 0.69444, 0, 0, 0.70277],
              "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8659": [0.19444, 0.69444, 0, 0, 0.70277],
              "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8661": [0.25, 0.75, 0, 0, 0.70277],
              "8704": [0, 0.69444, 0, 0, 0.63889],
              "8706": [0, 0.69444, 0.06389, 0, 0.62847],
              "8707": [0, 0.69444, 0, 0, 0.63889],
              "8709": [0.05556, 0.75, 0, 0, 0.575],
              "8711": [0, 0.68611, 0, 0, 0.95833],
              "8712": [0.08556, 0.58556, 0, 0, 0.76666],
              "8715": [0.08556, 0.58556, 0, 0, 0.76666],
              "8722": [0.13333, 0.63333, 0, 0, 0.89444],
              "8723": [0.13333, 0.63333, 0, 0, 0.89444],
              "8725": [0.25, 0.75, 0, 0, 0.575],
              "8726": [0.25, 0.75, 0, 0, 0.575],
              "8727": [-0.02778, 0.47222, 0, 0, 0.575],
              "8728": [-0.02639, 0.47361, 0, 0, 0.575],
              "8729": [-0.02639, 0.47361, 0, 0, 0.575],
              "8730": [0.18, 0.82, 0, 0, 0.95833],
              "8733": [0, 0.44444, 0, 0, 0.89444],
              "8734": [0, 0.44444, 0, 0, 1.14999],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8739": [0.25, 0.75, 0, 0, 0.31944],
              "8741": [0.25, 0.75, 0, 0, 0.575],
              "8743": [0, 0.55556, 0, 0, 0.76666],
              "8744": [0, 0.55556, 0, 0, 0.76666],
              "8745": [0, 0.55556, 0, 0, 0.76666],
              "8746": [0, 0.55556, 0, 0, 0.76666],
              "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
              "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
              "8768": [0.19444, 0.69444, 0, 0, 0.31944],
              "8771": [222e-5, 0.50222, 0, 0, 0.89444],
              "8773": [0.027, 0.638, 0, 0, 0.894],
              "8776": [0.02444, 0.52444, 0, 0, 0.89444],
              "8781": [222e-5, 0.50222, 0, 0, 0.89444],
              "8801": [222e-5, 0.50222, 0, 0, 0.89444],
              "8804": [0.19667, 0.69667, 0, 0, 0.89444],
              "8805": [0.19667, 0.69667, 0, 0, 0.89444],
              "8810": [0.08556, 0.58556, 0, 0, 1.14999],
              "8811": [0.08556, 0.58556, 0, 0, 1.14999],
              "8826": [0.08556, 0.58556, 0, 0, 0.89444],
              "8827": [0.08556, 0.58556, 0, 0, 0.89444],
              "8834": [0.08556, 0.58556, 0, 0, 0.89444],
              "8835": [0.08556, 0.58556, 0, 0, 0.89444],
              "8838": [0.19667, 0.69667, 0, 0, 0.89444],
              "8839": [0.19667, 0.69667, 0, 0, 0.89444],
              "8846": [0, 0.55556, 0, 0, 0.76666],
              "8849": [0.19667, 0.69667, 0, 0, 0.89444],
              "8850": [0.19667, 0.69667, 0, 0, 0.89444],
              "8851": [0, 0.55556, 0, 0, 0.76666],
              "8852": [0, 0.55556, 0, 0, 0.76666],
              "8853": [0.13333, 0.63333, 0, 0, 0.89444],
              "8854": [0.13333, 0.63333, 0, 0, 0.89444],
              "8855": [0.13333, 0.63333, 0, 0, 0.89444],
              "8856": [0.13333, 0.63333, 0, 0, 0.89444],
              "8857": [0.13333, 0.63333, 0, 0, 0.89444],
              "8866": [0, 0.69444, 0, 0, 0.70277],
              "8867": [0, 0.69444, 0, 0, 0.70277],
              "8868": [0, 0.69444, 0, 0, 0.89444],
              "8869": [0, 0.69444, 0, 0, 0.89444],
              "8900": [-0.02639, 0.47361, 0, 0, 0.575],
              "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
              "8902": [-0.02778, 0.47222, 0, 0, 0.575],
              "8968": [0.25, 0.75, 0, 0, 0.51111],
              "8969": [0.25, 0.75, 0, 0, 0.51111],
              "8970": [0.25, 0.75, 0, 0, 0.51111],
              "8971": [0.25, 0.75, 0, 0, 0.51111],
              "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
              "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
              "9651": [0.19444, 0.69444, 0, 0, 1.02222],
              "9657": [-0.02778, 0.47222, 0, 0, 0.575],
              "9661": [0.19444, 0.69444, 0, 0, 1.02222],
              "9667": [-0.02778, 0.47222, 0, 0, 0.575],
              "9711": [0.19444, 0.69444, 0, 0, 1.14999],
              "9824": [0.12963, 0.69444, 0, 0, 0.89444],
              "9825": [0.12963, 0.69444, 0, 0, 0.89444],
              "9826": [0.12963, 0.69444, 0, 0, 0.89444],
              "9827": [0.12963, 0.69444, 0, 0, 0.89444],
              "9837": [0, 0.75, 0, 0, 0.44722],
              "9838": [0.19444, 0.69444, 0, 0, 0.44722],
              "9839": [0.19444, 0.69444, 0, 0, 0.44722],
              "10216": [0.25, 0.75, 0, 0, 0.44722],
              "10217": [0.25, 0.75, 0, 0, 0.44722],
              "10815": [0, 0.68611, 0, 0, 0.9],
              "10927": [0.19667, 0.69667, 0, 0, 0.89444],
              "10928": [0.19667, 0.69667, 0, 0, 0.89444],
              "57376": [0.19444, 0.69444, 0, 0, 0]
            },
            "Main-BoldItalic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.11417, 0, 0.38611],
              "34": [0, 0.69444, 0.07939, 0, 0.62055],
              "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
              "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
              "38": [0, 0.69444, 0.08528, 0, 0.88555],
              "39": [0, 0.69444, 0.12945, 0, 0.35555],
              "40": [0.25, 0.75, 0.15806, 0, 0.47333],
              "41": [0.25, 0.75, 0.03306, 0, 0.47333],
              "42": [0, 0.75, 0.14333, 0, 0.59111],
              "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
              "44": [0.19444, 0.14722, 0, 0, 0.35555],
              "45": [0, 0.44444, 0.02611, 0, 0.41444],
              "46": [0, 0.14722, 0, 0, 0.35555],
              "47": [0.25, 0.75, 0.15806, 0, 0.59111],
              "48": [0, 0.64444, 0.13167, 0, 0.59111],
              "49": [0, 0.64444, 0.13167, 0, 0.59111],
              "50": [0, 0.64444, 0.13167, 0, 0.59111],
              "51": [0, 0.64444, 0.13167, 0, 0.59111],
              "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
              "53": [0, 0.64444, 0.13167, 0, 0.59111],
              "54": [0, 0.64444, 0.13167, 0, 0.59111],
              "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
              "56": [0, 0.64444, 0.13167, 0, 0.59111],
              "57": [0, 0.64444, 0.13167, 0, 0.59111],
              "58": [0, 0.44444, 0.06695, 0, 0.35555],
              "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
              "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
              "63": [0, 0.69444, 0.11472, 0, 0.59111],
              "64": [0, 0.69444, 0.09208, 0, 0.88555],
              "65": [0, 0.68611, 0, 0, 0.86555],
              "66": [0, 0.68611, 0.0992, 0, 0.81666],
              "67": [0, 0.68611, 0.14208, 0, 0.82666],
              "68": [0, 0.68611, 0.09062, 0, 0.87555],
              "69": [0, 0.68611, 0.11431, 0, 0.75666],
              "70": [0, 0.68611, 0.12903, 0, 0.72722],
              "71": [0, 0.68611, 0.07347, 0, 0.89527],
              "72": [0, 0.68611, 0.17208, 0, 0.8961],
              "73": [0, 0.68611, 0.15681, 0, 0.47166],
              "74": [0, 0.68611, 0.145, 0, 0.61055],
              "75": [0, 0.68611, 0.14208, 0, 0.89499],
              "76": [0, 0.68611, 0, 0, 0.69777],
              "77": [0, 0.68611, 0.17208, 0, 1.07277],
              "78": [0, 0.68611, 0.17208, 0, 0.8961],
              "79": [0, 0.68611, 0.09062, 0, 0.85499],
              "80": [0, 0.68611, 0.0992, 0, 0.78721],
              "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
              "82": [0, 0.68611, 0.02559, 0, 0.85944],
              "83": [0, 0.68611, 0.11264, 0, 0.64999],
              "84": [0, 0.68611, 0.12903, 0, 0.7961],
              "85": [0, 0.68611, 0.17208, 0, 0.88083],
              "86": [0, 0.68611, 0.18625, 0, 0.86555],
              "87": [0, 0.68611, 0.18625, 0, 1.15999],
              "88": [0, 0.68611, 0.15681, 0, 0.86555],
              "89": [0, 0.68611, 0.19803, 0, 0.86555],
              "90": [0, 0.68611, 0.14208, 0, 0.70888],
              "91": [0.25, 0.75, 0.1875, 0, 0.35611],
              "93": [0.25, 0.75, 0.09972, 0, 0.35611],
              "94": [0, 0.69444, 0.06709, 0, 0.59111],
              "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
              "97": [0, 0.44444, 0.09426, 0, 0.59111],
              "98": [0, 0.69444, 0.07861, 0, 0.53222],
              "99": [0, 0.44444, 0.05222, 0, 0.53222],
              "100": [0, 0.69444, 0.10861, 0, 0.59111],
              "101": [0, 0.44444, 0.085, 0, 0.53222],
              "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
              "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
              "104": [0, 0.69444, 0.09426, 0, 0.59111],
              "105": [0, 0.69326, 0.11387, 0, 0.35555],
              "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
              "107": [0, 0.69444, 0.11111, 0, 0.53222],
              "108": [0, 0.69444, 0.10861, 0, 0.29666],
              "109": [0, 0.44444, 0.09426, 0, 0.94444],
              "110": [0, 0.44444, 0.09426, 0, 0.64999],
              "111": [0, 0.44444, 0.07861, 0, 0.59111],
              "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
              "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
              "114": [0, 0.44444, 0.11111, 0, 0.50167],
              "115": [0, 0.44444, 0.08167, 0, 0.48694],
              "116": [0, 0.63492, 0.09639, 0, 0.385],
              "117": [0, 0.44444, 0.09426, 0, 0.62055],
              "118": [0, 0.44444, 0.11111, 0, 0.53222],
              "119": [0, 0.44444, 0.11111, 0, 0.76777],
              "120": [0, 0.44444, 0.12583, 0, 0.56055],
              "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
              "122": [0, 0.44444, 0.13889, 0, 0.49055],
              "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.69444, 0.11473, 0, 0.59111],
              "176": [0, 0.69444, 0, 0, 0.94888],
              "184": [0.17014, 0, 0, 0, 0.53222],
              "198": [0, 0.68611, 0.11431, 0, 1.02277],
              "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
              "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
              "230": [0, 0.44444, 0.085, 0, 0.82666],
              "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
              "305": [0, 0.44444, 0.09426, 0, 0.35555],
              "338": [0, 0.68611, 0.11431, 0, 1.14054],
              "339": [0, 0.44444, 0.085, 0, 0.82666],
              "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
              "710": [0, 0.69444, 0.06709, 0, 0.59111],
              "711": [0, 0.63194, 0.08271, 0, 0.59111],
              "713": [0, 0.59444, 0.10444, 0, 0.59111],
              "714": [0, 0.69444, 0.08528, 0, 0.59111],
              "715": [0, 0.69444, 0, 0, 0.59111],
              "728": [0, 0.69444, 0.10333, 0, 0.59111],
              "729": [0, 0.69444, 0.12945, 0, 0.35555],
              "730": [0, 0.69444, 0, 0, 0.94888],
              "732": [0, 0.69444, 0.11472, 0, 0.59111],
              "733": [0, 0.69444, 0.11472, 0, 0.59111],
              "915": [0, 0.68611, 0.12903, 0, 0.69777],
              "916": [0, 0.68611, 0, 0, 0.94444],
              "920": [0, 0.68611, 0.09062, 0, 0.88555],
              "923": [0, 0.68611, 0, 0, 0.80666],
              "926": [0, 0.68611, 0.15092, 0, 0.76777],
              "928": [0, 0.68611, 0.17208, 0, 0.8961],
              "931": [0, 0.68611, 0.11431, 0, 0.82666],
              "933": [0, 0.68611, 0.10778, 0, 0.88555],
              "934": [0, 0.68611, 0.05632, 0, 0.82666],
              "936": [0, 0.68611, 0.10778, 0, 0.88555],
              "937": [0, 0.68611, 0.0992, 0, 0.82666],
              "8211": [0, 0.44444, 0.09811, 0, 0.59111],
              "8212": [0, 0.44444, 0.09811, 0, 1.18221],
              "8216": [0, 0.69444, 0.12945, 0, 0.35555],
              "8217": [0, 0.69444, 0.12945, 0, 0.35555],
              "8220": [0, 0.69444, 0.16772, 0, 0.62055],
              "8221": [0, 0.69444, 0.07939, 0, 0.62055]
            },
            "Main-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.12417, 0, 0.30667],
              "34": [0, 0.69444, 0.06961, 0, 0.51444],
              "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
              "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
              "38": [0, 0.69444, 0.09694, 0, 0.76666],
              "39": [0, 0.69444, 0.12417, 0, 0.30667],
              "40": [0.25, 0.75, 0.16194, 0, 0.40889],
              "41": [0.25, 0.75, 0.03694, 0, 0.40889],
              "42": [0, 0.75, 0.14917, 0, 0.51111],
              "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
              "44": [0.19444, 0.10556, 0, 0, 0.30667],
              "45": [0, 0.43056, 0.02826, 0, 0.35778],
              "46": [0, 0.10556, 0, 0, 0.30667],
              "47": [0.25, 0.75, 0.16194, 0, 0.51111],
              "48": [0, 0.64444, 0.13556, 0, 0.51111],
              "49": [0, 0.64444, 0.13556, 0, 0.51111],
              "50": [0, 0.64444, 0.13556, 0, 0.51111],
              "51": [0, 0.64444, 0.13556, 0, 0.51111],
              "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
              "53": [0, 0.64444, 0.13556, 0, 0.51111],
              "54": [0, 0.64444, 0.13556, 0, 0.51111],
              "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
              "56": [0, 0.64444, 0.13556, 0, 0.51111],
              "57": [0, 0.64444, 0.13556, 0, 0.51111],
              "58": [0, 0.43056, 0.0582, 0, 0.30667],
              "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
              "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
              "63": [0, 0.69444, 0.1225, 0, 0.51111],
              "64": [0, 0.69444, 0.09597, 0, 0.76666],
              "65": [0, 0.68333, 0, 0, 0.74333],
              "66": [0, 0.68333, 0.10257, 0, 0.70389],
              "67": [0, 0.68333, 0.14528, 0, 0.71555],
              "68": [0, 0.68333, 0.09403, 0, 0.755],
              "69": [0, 0.68333, 0.12028, 0, 0.67833],
              "70": [0, 0.68333, 0.13305, 0, 0.65277],
              "71": [0, 0.68333, 0.08722, 0, 0.77361],
              "72": [0, 0.68333, 0.16389, 0, 0.74333],
              "73": [0, 0.68333, 0.15806, 0, 0.38555],
              "74": [0, 0.68333, 0.14028, 0, 0.525],
              "75": [0, 0.68333, 0.14528, 0, 0.76888],
              "76": [0, 0.68333, 0, 0, 0.62722],
              "77": [0, 0.68333, 0.16389, 0, 0.89666],
              "78": [0, 0.68333, 0.16389, 0, 0.74333],
              "79": [0, 0.68333, 0.09403, 0, 0.76666],
              "80": [0, 0.68333, 0.10257, 0, 0.67833],
              "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
              "82": [0, 0.68333, 0.03868, 0, 0.72944],
              "83": [0, 0.68333, 0.11972, 0, 0.56222],
              "84": [0, 0.68333, 0.13305, 0, 0.71555],
              "85": [0, 0.68333, 0.16389, 0, 0.74333],
              "86": [0, 0.68333, 0.18361, 0, 0.74333],
              "87": [0, 0.68333, 0.18361, 0, 0.99888],
              "88": [0, 0.68333, 0.15806, 0, 0.74333],
              "89": [0, 0.68333, 0.19383, 0, 0.74333],
              "90": [0, 0.68333, 0.14528, 0, 0.61333],
              "91": [0.25, 0.75, 0.1875, 0, 0.30667],
              "93": [0.25, 0.75, 0.10528, 0, 0.30667],
              "94": [0, 0.69444, 0.06646, 0, 0.51111],
              "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
              "97": [0, 0.43056, 0.07671, 0, 0.51111],
              "98": [0, 0.69444, 0.06312, 0, 0.46],
              "99": [0, 0.43056, 0.05653, 0, 0.46],
              "100": [0, 0.69444, 0.10333, 0, 0.51111],
              "101": [0, 0.43056, 0.07514, 0, 0.46],
              "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
              "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
              "104": [0, 0.69444, 0.07671, 0, 0.51111],
              "105": [0, 0.65536, 0.1019, 0, 0.30667],
              "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
              "107": [0, 0.69444, 0.10764, 0, 0.46],
              "108": [0, 0.69444, 0.10333, 0, 0.25555],
              "109": [0, 0.43056, 0.07671, 0, 0.81777],
              "110": [0, 0.43056, 0.07671, 0, 0.56222],
              "111": [0, 0.43056, 0.06312, 0, 0.51111],
              "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
              "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
              "114": [0, 0.43056, 0.10764, 0, 0.42166],
              "115": [0, 0.43056, 0.08208, 0, 0.40889],
              "116": [0, 0.61508, 0.09486, 0, 0.33222],
              "117": [0, 0.43056, 0.07671, 0, 0.53666],
              "118": [0, 0.43056, 0.10764, 0, 0.46],
              "119": [0, 0.43056, 0.10764, 0, 0.66444],
              "120": [0, 0.43056, 0.12042, 0, 0.46389],
              "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
              "122": [0, 0.43056, 0.12292, 0, 0.40889],
              "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.66786, 0.10474, 0, 0.51111],
              "176": [0, 0.69444, 0, 0, 0.83129],
              "184": [0.17014, 0, 0, 0, 0.46],
              "198": [0, 0.68333, 0.12028, 0, 0.88277],
              "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
              "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
              "230": [0, 0.43056, 0.07514, 0, 0.71555],
              "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
              "338": [0, 0.68333, 0.12028, 0, 0.98499],
              "339": [0, 0.43056, 0.07514, 0, 0.71555],
              "710": [0, 0.69444, 0.06646, 0, 0.51111],
              "711": [0, 0.62847, 0.08295, 0, 0.51111],
              "713": [0, 0.56167, 0.10333, 0, 0.51111],
              "714": [0, 0.69444, 0.09694, 0, 0.51111],
              "715": [0, 0.69444, 0, 0, 0.51111],
              "728": [0, 0.69444, 0.10806, 0, 0.51111],
              "729": [0, 0.66786, 0.11752, 0, 0.30667],
              "730": [0, 0.69444, 0, 0, 0.83129],
              "732": [0, 0.66786, 0.11585, 0, 0.51111],
              "733": [0, 0.69444, 0.1225, 0, 0.51111],
              "915": [0, 0.68333, 0.13305, 0, 0.62722],
              "916": [0, 0.68333, 0, 0, 0.81777],
              "920": [0, 0.68333, 0.09403, 0, 0.76666],
              "923": [0, 0.68333, 0, 0, 0.69222],
              "926": [0, 0.68333, 0.15294, 0, 0.66444],
              "928": [0, 0.68333, 0.16389, 0, 0.74333],
              "931": [0, 0.68333, 0.12028, 0, 0.71555],
              "933": [0, 0.68333, 0.11111, 0, 0.76666],
              "934": [0, 0.68333, 0.05986, 0, 0.71555],
              "936": [0, 0.68333, 0.11111, 0, 0.76666],
              "937": [0, 0.68333, 0.10257, 0, 0.71555],
              "8211": [0, 0.43056, 0.09208, 0, 0.51111],
              "8212": [0, 0.43056, 0.09208, 0, 1.02222],
              "8216": [0, 0.69444, 0.12417, 0, 0.30667],
              "8217": [0, 0.69444, 0.12417, 0, 0.30667],
              "8220": [0, 0.69444, 0.1685, 0, 0.51444],
              "8221": [0, 0.69444, 0.06961, 0, 0.51444],
              "8463": [0, 0.68889, 0, 0, 0.54028]
            },
            "Main-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.27778],
              "34": [0, 0.69444, 0, 0, 0.5],
              "35": [0.19444, 0.69444, 0, 0, 0.83334],
              "36": [0.05556, 0.75, 0, 0, 0.5],
              "37": [0.05556, 0.75, 0, 0, 0.83334],
              "38": [0, 0.69444, 0, 0, 0.77778],
              "39": [0, 0.69444, 0, 0, 0.27778],
              "40": [0.25, 0.75, 0, 0, 0.38889],
              "41": [0.25, 0.75, 0, 0, 0.38889],
              "42": [0, 0.75, 0, 0, 0.5],
              "43": [0.08333, 0.58333, 0, 0, 0.77778],
              "44": [0.19444, 0.10556, 0, 0, 0.27778],
              "45": [0, 0.43056, 0, 0, 0.33333],
              "46": [0, 0.10556, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0, 0, 0.5],
              "48": [0, 0.64444, 0, 0, 0.5],
              "49": [0, 0.64444, 0, 0, 0.5],
              "50": [0, 0.64444, 0, 0, 0.5],
              "51": [0, 0.64444, 0, 0, 0.5],
              "52": [0, 0.64444, 0, 0, 0.5],
              "53": [0, 0.64444, 0, 0, 0.5],
              "54": [0, 0.64444, 0, 0, 0.5],
              "55": [0, 0.64444, 0, 0, 0.5],
              "56": [0, 0.64444, 0, 0, 0.5],
              "57": [0, 0.64444, 0, 0, 0.5],
              "58": [0, 0.43056, 0, 0, 0.27778],
              "59": [0.19444, 0.43056, 0, 0, 0.27778],
              "60": [0.0391, 0.5391, 0, 0, 0.77778],
              "61": [-0.13313, 0.36687, 0, 0, 0.77778],
              "62": [0.0391, 0.5391, 0, 0, 0.77778],
              "63": [0, 0.69444, 0, 0, 0.47222],
              "64": [0, 0.69444, 0, 0, 0.77778],
              "65": [0, 0.68333, 0, 0, 0.75],
              "66": [0, 0.68333, 0, 0, 0.70834],
              "67": [0, 0.68333, 0, 0, 0.72222],
              "68": [0, 0.68333, 0, 0, 0.76389],
              "69": [0, 0.68333, 0, 0, 0.68056],
              "70": [0, 0.68333, 0, 0, 0.65278],
              "71": [0, 0.68333, 0, 0, 0.78472],
              "72": [0, 0.68333, 0, 0, 0.75],
              "73": [0, 0.68333, 0, 0, 0.36111],
              "74": [0, 0.68333, 0, 0, 0.51389],
              "75": [0, 0.68333, 0, 0, 0.77778],
              "76": [0, 0.68333, 0, 0, 0.625],
              "77": [0, 0.68333, 0, 0, 0.91667],
              "78": [0, 0.68333, 0, 0, 0.75],
              "79": [0, 0.68333, 0, 0, 0.77778],
              "80": [0, 0.68333, 0, 0, 0.68056],
              "81": [0.19444, 0.68333, 0, 0, 0.77778],
              "82": [0, 0.68333, 0, 0, 0.73611],
              "83": [0, 0.68333, 0, 0, 0.55556],
              "84": [0, 0.68333, 0, 0, 0.72222],
              "85": [0, 0.68333, 0, 0, 0.75],
              "86": [0, 0.68333, 0.01389, 0, 0.75],
              "87": [0, 0.68333, 0.01389, 0, 1.02778],
              "88": [0, 0.68333, 0, 0, 0.75],
              "89": [0, 0.68333, 0.025, 0, 0.75],
              "90": [0, 0.68333, 0, 0, 0.61111],
              "91": [0.25, 0.75, 0, 0, 0.27778],
              "92": [0.25, 0.75, 0, 0, 0.5],
              "93": [0.25, 0.75, 0, 0, 0.27778],
              "94": [0, 0.69444, 0, 0, 0.5],
              "95": [0.31, 0.12056, 0.02778, 0, 0.5],
              "97": [0, 0.43056, 0, 0, 0.5],
              "98": [0, 0.69444, 0, 0, 0.55556],
              "99": [0, 0.43056, 0, 0, 0.44445],
              "100": [0, 0.69444, 0, 0, 0.55556],
              "101": [0, 0.43056, 0, 0, 0.44445],
              "102": [0, 0.69444, 0.07778, 0, 0.30556],
              "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
              "104": [0, 0.69444, 0, 0, 0.55556],
              "105": [0, 0.66786, 0, 0, 0.27778],
              "106": [0.19444, 0.66786, 0, 0, 0.30556],
              "107": [0, 0.69444, 0, 0, 0.52778],
              "108": [0, 0.69444, 0, 0, 0.27778],
              "109": [0, 0.43056, 0, 0, 0.83334],
              "110": [0, 0.43056, 0, 0, 0.55556],
              "111": [0, 0.43056, 0, 0, 0.5],
              "112": [0.19444, 0.43056, 0, 0, 0.55556],
              "113": [0.19444, 0.43056, 0, 0, 0.52778],
              "114": [0, 0.43056, 0, 0, 0.39167],
              "115": [0, 0.43056, 0, 0, 0.39445],
              "116": [0, 0.61508, 0, 0, 0.38889],
              "117": [0, 0.43056, 0, 0, 0.55556],
              "118": [0, 0.43056, 0.01389, 0, 0.52778],
              "119": [0, 0.43056, 0.01389, 0, 0.72222],
              "120": [0, 0.43056, 0, 0, 0.52778],
              "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
              "122": [0, 0.43056, 0, 0, 0.44445],
              "123": [0.25, 0.75, 0, 0, 0.5],
              "124": [0.25, 0.75, 0, 0, 0.27778],
              "125": [0.25, 0.75, 0, 0, 0.5],
              "126": [0.35, 0.31786, 0, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "163": [0, 0.69444, 0, 0, 0.76909],
              "167": [0.19444, 0.69444, 0, 0, 0.44445],
              "168": [0, 0.66786, 0, 0, 0.5],
              "172": [0, 0.43056, 0, 0, 0.66667],
              "176": [0, 0.69444, 0, 0, 0.75],
              "177": [0.08333, 0.58333, 0, 0, 0.77778],
              "182": [0.19444, 0.69444, 0, 0, 0.61111],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "198": [0, 0.68333, 0, 0, 0.90278],
              "215": [0.08333, 0.58333, 0, 0, 0.77778],
              "216": [0.04861, 0.73194, 0, 0, 0.77778],
              "223": [0, 0.69444, 0, 0, 0.5],
              "230": [0, 0.43056, 0, 0, 0.72222],
              "247": [0.08333, 0.58333, 0, 0, 0.77778],
              "248": [0.09722, 0.52778, 0, 0, 0.5],
              "305": [0, 0.43056, 0, 0, 0.27778],
              "338": [0, 0.68333, 0, 0, 1.01389],
              "339": [0, 0.43056, 0, 0, 0.77778],
              "567": [0.19444, 0.43056, 0, 0, 0.30556],
              "710": [0, 0.69444, 0, 0, 0.5],
              "711": [0, 0.62847, 0, 0, 0.5],
              "713": [0, 0.56778, 0, 0, 0.5],
              "714": [0, 0.69444, 0, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0, 0, 0.5],
              "729": [0, 0.66786, 0, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.75],
              "732": [0, 0.66786, 0, 0, 0.5],
              "733": [0, 0.69444, 0, 0, 0.5],
              "915": [0, 0.68333, 0, 0, 0.625],
              "916": [0, 0.68333, 0, 0, 0.83334],
              "920": [0, 0.68333, 0, 0, 0.77778],
              "923": [0, 0.68333, 0, 0, 0.69445],
              "926": [0, 0.68333, 0, 0, 0.66667],
              "928": [0, 0.68333, 0, 0, 0.75],
              "931": [0, 0.68333, 0, 0, 0.72222],
              "933": [0, 0.68333, 0, 0, 0.77778],
              "934": [0, 0.68333, 0, 0, 0.72222],
              "936": [0, 0.68333, 0, 0, 0.77778],
              "937": [0, 0.68333, 0, 0, 0.72222],
              "8211": [0, 0.43056, 0.02778, 0, 0.5],
              "8212": [0, 0.43056, 0.02778, 0, 1],
              "8216": [0, 0.69444, 0, 0, 0.27778],
              "8217": [0, 0.69444, 0, 0, 0.27778],
              "8220": [0, 0.69444, 0, 0, 0.5],
              "8221": [0, 0.69444, 0, 0, 0.5],
              "8224": [0.19444, 0.69444, 0, 0, 0.44445],
              "8225": [0.19444, 0.69444, 0, 0, 0.44445],
              "8230": [0, 0.123, 0, 0, 1.172],
              "8242": [0, 0.55556, 0, 0, 0.275],
              "8407": [0, 0.71444, 0.15382, 0, 0.5],
              "8463": [0, 0.68889, 0, 0, 0.54028],
              "8465": [0, 0.69444, 0, 0, 0.72222],
              "8467": [0, 0.69444, 0, 0.11111, 0.41667],
              "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
              "8476": [0, 0.69444, 0, 0, 0.72222],
              "8501": [0, 0.69444, 0, 0, 0.61111],
              "8592": [-0.13313, 0.36687, 0, 0, 1],
              "8593": [0.19444, 0.69444, 0, 0, 0.5],
              "8594": [-0.13313, 0.36687, 0, 0, 1],
              "8595": [0.19444, 0.69444, 0, 0, 0.5],
              "8596": [-0.13313, 0.36687, 0, 0, 1],
              "8597": [0.25, 0.75, 0, 0, 0.5],
              "8598": [0.19444, 0.69444, 0, 0, 1],
              "8599": [0.19444, 0.69444, 0, 0, 1],
              "8600": [0.19444, 0.69444, 0, 0, 1],
              "8601": [0.19444, 0.69444, 0, 0, 1],
              "8614": [0.011, 0.511, 0, 0, 1],
              "8617": [0.011, 0.511, 0, 0, 1.126],
              "8618": [0.011, 0.511, 0, 0, 1.126],
              "8636": [-0.13313, 0.36687, 0, 0, 1],
              "8637": [-0.13313, 0.36687, 0, 0, 1],
              "8640": [-0.13313, 0.36687, 0, 0, 1],
              "8641": [-0.13313, 0.36687, 0, 0, 1],
              "8652": [0.011, 0.671, 0, 0, 1],
              "8656": [-0.13313, 0.36687, 0, 0, 1],
              "8657": [0.19444, 0.69444, 0, 0, 0.61111],
              "8658": [-0.13313, 0.36687, 0, 0, 1],
              "8659": [0.19444, 0.69444, 0, 0, 0.61111],
              "8660": [-0.13313, 0.36687, 0, 0, 1],
              "8661": [0.25, 0.75, 0, 0, 0.61111],
              "8704": [0, 0.69444, 0, 0, 0.55556],
              "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
              "8707": [0, 0.69444, 0, 0, 0.55556],
              "8709": [0.05556, 0.75, 0, 0, 0.5],
              "8711": [0, 0.68333, 0, 0, 0.83334],
              "8712": [0.0391, 0.5391, 0, 0, 0.66667],
              "8715": [0.0391, 0.5391, 0, 0, 0.66667],
              "8722": [0.08333, 0.58333, 0, 0, 0.77778],
              "8723": [0.08333, 0.58333, 0, 0, 0.77778],
              "8725": [0.25, 0.75, 0, 0, 0.5],
              "8726": [0.25, 0.75, 0, 0, 0.5],
              "8727": [-0.03472, 0.46528, 0, 0, 0.5],
              "8728": [-0.05555, 0.44445, 0, 0, 0.5],
              "8729": [-0.05555, 0.44445, 0, 0, 0.5],
              "8730": [0.2, 0.8, 0, 0, 0.83334],
              "8733": [0, 0.43056, 0, 0, 0.77778],
              "8734": [0, 0.43056, 0, 0, 1],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8739": [0.25, 0.75, 0, 0, 0.27778],
              "8741": [0.25, 0.75, 0, 0, 0.5],
              "8743": [0, 0.55556, 0, 0, 0.66667],
              "8744": [0, 0.55556, 0, 0, 0.66667],
              "8745": [0, 0.55556, 0, 0, 0.66667],
              "8746": [0, 0.55556, 0, 0, 0.66667],
              "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
              "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8768": [0.19444, 0.69444, 0, 0, 0.27778],
              "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8773": [-0.022, 0.589, 0, 0, 0.778],
              "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
              "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8784": [-0.133, 0.673, 0, 0, 0.778],
              "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8804": [0.13597, 0.63597, 0, 0, 0.77778],
              "8805": [0.13597, 0.63597, 0, 0, 0.77778],
              "8810": [0.0391, 0.5391, 0, 0, 1],
              "8811": [0.0391, 0.5391, 0, 0, 1],
              "8826": [0.0391, 0.5391, 0, 0, 0.77778],
              "8827": [0.0391, 0.5391, 0, 0, 0.77778],
              "8834": [0.0391, 0.5391, 0, 0, 0.77778],
              "8835": [0.0391, 0.5391, 0, 0, 0.77778],
              "8838": [0.13597, 0.63597, 0, 0, 0.77778],
              "8839": [0.13597, 0.63597, 0, 0, 0.77778],
              "8846": [0, 0.55556, 0, 0, 0.66667],
              "8849": [0.13597, 0.63597, 0, 0, 0.77778],
              "8850": [0.13597, 0.63597, 0, 0, 0.77778],
              "8851": [0, 0.55556, 0, 0, 0.66667],
              "8852": [0, 0.55556, 0, 0, 0.66667],
              "8853": [0.08333, 0.58333, 0, 0, 0.77778],
              "8854": [0.08333, 0.58333, 0, 0, 0.77778],
              "8855": [0.08333, 0.58333, 0, 0, 0.77778],
              "8856": [0.08333, 0.58333, 0, 0, 0.77778],
              "8857": [0.08333, 0.58333, 0, 0, 0.77778],
              "8866": [0, 0.69444, 0, 0, 0.61111],
              "8867": [0, 0.69444, 0, 0, 0.61111],
              "8868": [0, 0.69444, 0, 0, 0.77778],
              "8869": [0, 0.69444, 0, 0, 0.77778],
              "8872": [0.249, 0.75, 0, 0, 0.867],
              "8900": [-0.05555, 0.44445, 0, 0, 0.5],
              "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
              "8902": [-0.03472, 0.46528, 0, 0, 0.5],
              "8904": [5e-3, 0.505, 0, 0, 0.9],
              "8942": [0.03, 0.903, 0, 0, 0.278],
              "8943": [-0.19, 0.313, 0, 0, 1.172],
              "8945": [-0.1, 0.823, 0, 0, 1.282],
              "8968": [0.25, 0.75, 0, 0, 0.44445],
              "8969": [0.25, 0.75, 0, 0, 0.44445],
              "8970": [0.25, 0.75, 0, 0, 0.44445],
              "8971": [0.25, 0.75, 0, 0, 0.44445],
              "8994": [-0.14236, 0.35764, 0, 0, 1],
              "8995": [-0.14236, 0.35764, 0, 0, 1],
              "9136": [0.244, 0.744, 0, 0, 0.412],
              "9137": [0.244, 0.745, 0, 0, 0.412],
              "9651": [0.19444, 0.69444, 0, 0, 0.88889],
              "9657": [-0.03472, 0.46528, 0, 0, 0.5],
              "9661": [0.19444, 0.69444, 0, 0, 0.88889],
              "9667": [-0.03472, 0.46528, 0, 0, 0.5],
              "9711": [0.19444, 0.69444, 0, 0, 1],
              "9824": [0.12963, 0.69444, 0, 0, 0.77778],
              "9825": [0.12963, 0.69444, 0, 0, 0.77778],
              "9826": [0.12963, 0.69444, 0, 0, 0.77778],
              "9827": [0.12963, 0.69444, 0, 0, 0.77778],
              "9837": [0, 0.75, 0, 0, 0.38889],
              "9838": [0.19444, 0.69444, 0, 0, 0.38889],
              "9839": [0.19444, 0.69444, 0, 0, 0.38889],
              "10216": [0.25, 0.75, 0, 0, 0.38889],
              "10217": [0.25, 0.75, 0, 0, 0.38889],
              "10222": [0.244, 0.744, 0, 0, 0.412],
              "10223": [0.244, 0.745, 0, 0, 0.412],
              "10229": [0.011, 0.511, 0, 0, 1.609],
              "10230": [0.011, 0.511, 0, 0, 1.638],
              "10231": [0.011, 0.511, 0, 0, 1.859],
              "10232": [0.024, 0.525, 0, 0, 1.609],
              "10233": [0.024, 0.525, 0, 0, 1.638],
              "10234": [0.024, 0.525, 0, 0, 1.858],
              "10236": [0.011, 0.511, 0, 0, 1.638],
              "10815": [0, 0.68333, 0, 0, 0.75],
              "10927": [0.13597, 0.63597, 0, 0, 0.77778],
              "10928": [0.13597, 0.63597, 0, 0, 0.77778],
              "57376": [0.19444, 0.69444, 0, 0, 0]
            },
            "Math-BoldItalic": {
              "32": [0, 0, 0, 0, 0.25],
              "48": [0, 0.44444, 0, 0, 0.575],
              "49": [0, 0.44444, 0, 0, 0.575],
              "50": [0, 0.44444, 0, 0, 0.575],
              "51": [0.19444, 0.44444, 0, 0, 0.575],
              "52": [0.19444, 0.44444, 0, 0, 0.575],
              "53": [0.19444, 0.44444, 0, 0, 0.575],
              "54": [0, 0.64444, 0, 0, 0.575],
              "55": [0.19444, 0.44444, 0, 0, 0.575],
              "56": [0, 0.64444, 0, 0, 0.575],
              "57": [0.19444, 0.44444, 0, 0, 0.575],
              "65": [0, 0.68611, 0, 0, 0.86944],
              "66": [0, 0.68611, 0.04835, 0, 0.8664],
              "67": [0, 0.68611, 0.06979, 0, 0.81694],
              "68": [0, 0.68611, 0.03194, 0, 0.93812],
              "69": [0, 0.68611, 0.05451, 0, 0.81007],
              "70": [0, 0.68611, 0.15972, 0, 0.68889],
              "71": [0, 0.68611, 0, 0, 0.88673],
              "72": [0, 0.68611, 0.08229, 0, 0.98229],
              "73": [0, 0.68611, 0.07778, 0, 0.51111],
              "74": [0, 0.68611, 0.10069, 0, 0.63125],
              "75": [0, 0.68611, 0.06979, 0, 0.97118],
              "76": [0, 0.68611, 0, 0, 0.75555],
              "77": [0, 0.68611, 0.11424, 0, 1.14201],
              "78": [0, 0.68611, 0.11424, 0, 0.95034],
              "79": [0, 0.68611, 0.03194, 0, 0.83666],
              "80": [0, 0.68611, 0.15972, 0, 0.72309],
              "81": [0.19444, 0.68611, 0, 0, 0.86861],
              "82": [0, 0.68611, 421e-5, 0, 0.87235],
              "83": [0, 0.68611, 0.05382, 0, 0.69271],
              "84": [0, 0.68611, 0.15972, 0, 0.63663],
              "85": [0, 0.68611, 0.11424, 0, 0.80027],
              "86": [0, 0.68611, 0.25555, 0, 0.67778],
              "87": [0, 0.68611, 0.15972, 0, 1.09305],
              "88": [0, 0.68611, 0.07778, 0, 0.94722],
              "89": [0, 0.68611, 0.25555, 0, 0.67458],
              "90": [0, 0.68611, 0.06979, 0, 0.77257],
              "97": [0, 0.44444, 0, 0, 0.63287],
              "98": [0, 0.69444, 0, 0, 0.52083],
              "99": [0, 0.44444, 0, 0, 0.51342],
              "100": [0, 0.69444, 0, 0, 0.60972],
              "101": [0, 0.44444, 0, 0, 0.55361],
              "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
              "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
              "104": [0, 0.69444, 0, 0, 0.66759],
              "105": [0, 0.69326, 0, 0, 0.4048],
              "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
              "107": [0, 0.69444, 0.01852, 0, 0.6037],
              "108": [0, 0.69444, 88e-4, 0, 0.34815],
              "109": [0, 0.44444, 0, 0, 1.0324],
              "110": [0, 0.44444, 0, 0, 0.71296],
              "111": [0, 0.44444, 0, 0, 0.58472],
              "112": [0.19444, 0.44444, 0, 0, 0.60092],
              "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
              "114": [0, 0.44444, 0.03194, 0, 0.5287],
              "115": [0, 0.44444, 0, 0, 0.53125],
              "116": [0, 0.63492, 0, 0, 0.41528],
              "117": [0, 0.44444, 0, 0, 0.68102],
              "118": [0, 0.44444, 0.03704, 0, 0.56666],
              "119": [0, 0.44444, 0.02778, 0, 0.83148],
              "120": [0, 0.44444, 0, 0, 0.65903],
              "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
              "122": [0, 0.44444, 0.04213, 0, 0.55509],
              "160": [0, 0, 0, 0, 0.25],
              "915": [0, 0.68611, 0.15972, 0, 0.65694],
              "916": [0, 0.68611, 0, 0, 0.95833],
              "920": [0, 0.68611, 0.03194, 0, 0.86722],
              "923": [0, 0.68611, 0, 0, 0.80555],
              "926": [0, 0.68611, 0.07458, 0, 0.84125],
              "928": [0, 0.68611, 0.08229, 0, 0.98229],
              "931": [0, 0.68611, 0.05451, 0, 0.88507],
              "933": [0, 0.68611, 0.15972, 0, 0.67083],
              "934": [0, 0.68611, 0, 0, 0.76666],
              "936": [0, 0.68611, 0.11653, 0, 0.71402],
              "937": [0, 0.68611, 0.04835, 0, 0.8789],
              "945": [0, 0.44444, 0, 0, 0.76064],
              "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
              "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
              "948": [0, 0.69444, 0.03819, 0, 0.52222],
              "949": [0, 0.44444, 0, 0, 0.52882],
              "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
              "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
              "952": [0, 0.69444, 0.03194, 0, 0.5618],
              "953": [0, 0.44444, 0, 0, 0.41204],
              "954": [0, 0.44444, 0, 0, 0.66759],
              "955": [0, 0.69444, 0, 0, 0.67083],
              "956": [0.19444, 0.44444, 0, 0, 0.70787],
              "957": [0, 0.44444, 0.06898, 0, 0.57685],
              "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
              "959": [0, 0.44444, 0, 0, 0.58472],
              "960": [0, 0.44444, 0.03704, 0, 0.68241],
              "961": [0.19444, 0.44444, 0, 0, 0.6118],
              "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
              "963": [0, 0.44444, 0.03704, 0, 0.68588],
              "964": [0, 0.44444, 0.13472, 0, 0.52083],
              "965": [0, 0.44444, 0.03704, 0, 0.63055],
              "966": [0.19444, 0.44444, 0, 0, 0.74722],
              "967": [0.19444, 0.44444, 0, 0, 0.71805],
              "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
              "969": [0, 0.44444, 0.03704, 0, 0.71782],
              "977": [0, 0.69444, 0, 0, 0.69155],
              "981": [0.19444, 0.69444, 0, 0, 0.7125],
              "982": [0, 0.44444, 0.03194, 0, 0.975],
              "1009": [0.19444, 0.44444, 0, 0, 0.6118],
              "1013": [0, 0.44444, 0, 0, 0.48333],
              "57649": [0, 0.44444, 0, 0, 0.39352],
              "57911": [0.19444, 0.44444, 0, 0, 0.43889]
            },
            "Math-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "48": [0, 0.43056, 0, 0, 0.5],
              "49": [0, 0.43056, 0, 0, 0.5],
              "50": [0, 0.43056, 0, 0, 0.5],
              "51": [0.19444, 0.43056, 0, 0, 0.5],
              "52": [0.19444, 0.43056, 0, 0, 0.5],
              "53": [0.19444, 0.43056, 0, 0, 0.5],
              "54": [0, 0.64444, 0, 0, 0.5],
              "55": [0.19444, 0.43056, 0, 0, 0.5],
              "56": [0, 0.64444, 0, 0, 0.5],
              "57": [0.19444, 0.43056, 0, 0, 0.5],
              "65": [0, 0.68333, 0, 0.13889, 0.75],
              "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
              "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
              "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
              "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
              "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
              "71": [0, 0.68333, 0, 0.08334, 0.78625],
              "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
              "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
              "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
              "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
              "76": [0, 0.68333, 0, 0.02778, 0.68056],
              "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
              "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
              "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
              "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
              "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
              "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
              "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
              "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
              "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
              "86": [0, 0.68333, 0.22222, 0, 0.58333],
              "87": [0, 0.68333, 0.13889, 0, 0.94445],
              "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
              "89": [0, 0.68333, 0.22222, 0, 0.58056],
              "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
              "97": [0, 0.43056, 0, 0, 0.52859],
              "98": [0, 0.69444, 0, 0, 0.42917],
              "99": [0, 0.43056, 0, 0.05556, 0.43276],
              "100": [0, 0.69444, 0, 0.16667, 0.52049],
              "101": [0, 0.43056, 0, 0.05556, 0.46563],
              "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
              "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
              "104": [0, 0.69444, 0, 0, 0.57616],
              "105": [0, 0.65952, 0, 0, 0.34451],
              "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
              "107": [0, 0.69444, 0.03148, 0, 0.5206],
              "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
              "109": [0, 0.43056, 0, 0, 0.87801],
              "110": [0, 0.43056, 0, 0, 0.60023],
              "111": [0, 0.43056, 0, 0.05556, 0.48472],
              "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
              "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
              "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
              "115": [0, 0.43056, 0, 0.05556, 0.46875],
              "116": [0, 0.61508, 0, 0.08334, 0.36111],
              "117": [0, 0.43056, 0, 0.02778, 0.57246],
              "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
              "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
              "120": [0, 0.43056, 0, 0.02778, 0.57153],
              "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
              "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
              "160": [0, 0, 0, 0, 0.25],
              "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
              "916": [0, 0.68333, 0, 0.16667, 0.83334],
              "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
              "923": [0, 0.68333, 0, 0.16667, 0.69445],
              "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
              "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
              "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
              "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
              "934": [0, 0.68333, 0, 0.08334, 0.66667],
              "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
              "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
              "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
              "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
              "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
              "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
              "949": [0, 0.43056, 0, 0.08334, 0.46632],
              "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
              "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
              "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
              "953": [0, 0.43056, 0, 0.05556, 0.35394],
              "954": [0, 0.43056, 0, 0, 0.57616],
              "955": [0, 0.69444, 0, 0, 0.58334],
              "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
              "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
              "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
              "959": [0, 0.43056, 0, 0.05556, 0.48472],
              "960": [0, 0.43056, 0.03588, 0, 0.57003],
              "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
              "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
              "963": [0, 0.43056, 0.03588, 0, 0.57141],
              "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
              "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
              "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
              "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
              "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
              "969": [0, 0.43056, 0.03588, 0, 0.62245],
              "977": [0, 0.69444, 0, 0.08334, 0.59144],
              "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
              "982": [0, 0.43056, 0.02778, 0, 0.82813],
              "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
              "1013": [0, 0.43056, 0, 0.05556, 0.4059],
              "57649": [0, 0.43056, 0, 0.02778, 0.32246],
              "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
            },
            "SansSerif-Bold": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.36667],
              "34": [0, 0.69444, 0, 0, 0.55834],
              "35": [0.19444, 0.69444, 0, 0, 0.91667],
              "36": [0.05556, 0.75, 0, 0, 0.55],
              "37": [0.05556, 0.75, 0, 0, 1.02912],
              "38": [0, 0.69444, 0, 0, 0.83056],
              "39": [0, 0.69444, 0, 0, 0.30556],
              "40": [0.25, 0.75, 0, 0, 0.42778],
              "41": [0.25, 0.75, 0, 0, 0.42778],
              "42": [0, 0.75, 0, 0, 0.55],
              "43": [0.11667, 0.61667, 0, 0, 0.85556],
              "44": [0.10556, 0.13056, 0, 0, 0.30556],
              "45": [0, 0.45833, 0, 0, 0.36667],
              "46": [0, 0.13056, 0, 0, 0.30556],
              "47": [0.25, 0.75, 0, 0, 0.55],
              "48": [0, 0.69444, 0, 0, 0.55],
              "49": [0, 0.69444, 0, 0, 0.55],
              "50": [0, 0.69444, 0, 0, 0.55],
              "51": [0, 0.69444, 0, 0, 0.55],
              "52": [0, 0.69444, 0, 0, 0.55],
              "53": [0, 0.69444, 0, 0, 0.55],
              "54": [0, 0.69444, 0, 0, 0.55],
              "55": [0, 0.69444, 0, 0, 0.55],
              "56": [0, 0.69444, 0, 0, 0.55],
              "57": [0, 0.69444, 0, 0, 0.55],
              "58": [0, 0.45833, 0, 0, 0.30556],
              "59": [0.10556, 0.45833, 0, 0, 0.30556],
              "61": [-0.09375, 0.40625, 0, 0, 0.85556],
              "63": [0, 0.69444, 0, 0, 0.51945],
              "64": [0, 0.69444, 0, 0, 0.73334],
              "65": [0, 0.69444, 0, 0, 0.73334],
              "66": [0, 0.69444, 0, 0, 0.73334],
              "67": [0, 0.69444, 0, 0, 0.70278],
              "68": [0, 0.69444, 0, 0, 0.79445],
              "69": [0, 0.69444, 0, 0, 0.64167],
              "70": [0, 0.69444, 0, 0, 0.61111],
              "71": [0, 0.69444, 0, 0, 0.73334],
              "72": [0, 0.69444, 0, 0, 0.79445],
              "73": [0, 0.69444, 0, 0, 0.33056],
              "74": [0, 0.69444, 0, 0, 0.51945],
              "75": [0, 0.69444, 0, 0, 0.76389],
              "76": [0, 0.69444, 0, 0, 0.58056],
              "77": [0, 0.69444, 0, 0, 0.97778],
              "78": [0, 0.69444, 0, 0, 0.79445],
              "79": [0, 0.69444, 0, 0, 0.79445],
              "80": [0, 0.69444, 0, 0, 0.70278],
              "81": [0.10556, 0.69444, 0, 0, 0.79445],
              "82": [0, 0.69444, 0, 0, 0.70278],
              "83": [0, 0.69444, 0, 0, 0.61111],
              "84": [0, 0.69444, 0, 0, 0.73334],
              "85": [0, 0.69444, 0, 0, 0.76389],
              "86": [0, 0.69444, 0.01528, 0, 0.73334],
              "87": [0, 0.69444, 0.01528, 0, 1.03889],
              "88": [0, 0.69444, 0, 0, 0.73334],
              "89": [0, 0.69444, 0.0275, 0, 0.73334],
              "90": [0, 0.69444, 0, 0, 0.67223],
              "91": [0.25, 0.75, 0, 0, 0.34306],
              "93": [0.25, 0.75, 0, 0, 0.34306],
              "94": [0, 0.69444, 0, 0, 0.55],
              "95": [0.35, 0.10833, 0.03056, 0, 0.55],
              "97": [0, 0.45833, 0, 0, 0.525],
              "98": [0, 0.69444, 0, 0, 0.56111],
              "99": [0, 0.45833, 0, 0, 0.48889],
              "100": [0, 0.69444, 0, 0, 0.56111],
              "101": [0, 0.45833, 0, 0, 0.51111],
              "102": [0, 0.69444, 0.07639, 0, 0.33611],
              "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
              "104": [0, 0.69444, 0, 0, 0.56111],
              "105": [0, 0.69444, 0, 0, 0.25556],
              "106": [0.19444, 0.69444, 0, 0, 0.28611],
              "107": [0, 0.69444, 0, 0, 0.53056],
              "108": [0, 0.69444, 0, 0, 0.25556],
              "109": [0, 0.45833, 0, 0, 0.86667],
              "110": [0, 0.45833, 0, 0, 0.56111],
              "111": [0, 0.45833, 0, 0, 0.55],
              "112": [0.19444, 0.45833, 0, 0, 0.56111],
              "113": [0.19444, 0.45833, 0, 0, 0.56111],
              "114": [0, 0.45833, 0.01528, 0, 0.37222],
              "115": [0, 0.45833, 0, 0, 0.42167],
              "116": [0, 0.58929, 0, 0, 0.40417],
              "117": [0, 0.45833, 0, 0, 0.56111],
              "118": [0, 0.45833, 0.01528, 0, 0.5],
              "119": [0, 0.45833, 0.01528, 0, 0.74445],
              "120": [0, 0.45833, 0, 0, 0.5],
              "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
              "122": [0, 0.45833, 0, 0, 0.47639],
              "126": [0.35, 0.34444, 0, 0, 0.55],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.69444, 0, 0, 0.55],
              "176": [0, 0.69444, 0, 0, 0.73334],
              "180": [0, 0.69444, 0, 0, 0.55],
              "184": [0.17014, 0, 0, 0, 0.48889],
              "305": [0, 0.45833, 0, 0, 0.25556],
              "567": [0.19444, 0.45833, 0, 0, 0.28611],
              "710": [0, 0.69444, 0, 0, 0.55],
              "711": [0, 0.63542, 0, 0, 0.55],
              "713": [0, 0.63778, 0, 0, 0.55],
              "728": [0, 0.69444, 0, 0, 0.55],
              "729": [0, 0.69444, 0, 0, 0.30556],
              "730": [0, 0.69444, 0, 0, 0.73334],
              "732": [0, 0.69444, 0, 0, 0.55],
              "733": [0, 0.69444, 0, 0, 0.55],
              "915": [0, 0.69444, 0, 0, 0.58056],
              "916": [0, 0.69444, 0, 0, 0.91667],
              "920": [0, 0.69444, 0, 0, 0.85556],
              "923": [0, 0.69444, 0, 0, 0.67223],
              "926": [0, 0.69444, 0, 0, 0.73334],
              "928": [0, 0.69444, 0, 0, 0.79445],
              "931": [0, 0.69444, 0, 0, 0.79445],
              "933": [0, 0.69444, 0, 0, 0.85556],
              "934": [0, 0.69444, 0, 0, 0.79445],
              "936": [0, 0.69444, 0, 0, 0.85556],
              "937": [0, 0.69444, 0, 0, 0.79445],
              "8211": [0, 0.45833, 0.03056, 0, 0.55],
              "8212": [0, 0.45833, 0.03056, 0, 1.10001],
              "8216": [0, 0.69444, 0, 0, 0.30556],
              "8217": [0, 0.69444, 0, 0, 0.30556],
              "8220": [0, 0.69444, 0, 0, 0.55834],
              "8221": [0, 0.69444, 0, 0, 0.55834]
            },
            "SansSerif-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.05733, 0, 0.31945],
              "34": [0, 0.69444, 316e-5, 0, 0.5],
              "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
              "36": [0.05556, 0.75, 0.11156, 0, 0.5],
              "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
              "38": [0, 0.69444, 0.03058, 0, 0.75834],
              "39": [0, 0.69444, 0.07816, 0, 0.27778],
              "40": [0.25, 0.75, 0.13164, 0, 0.38889],
              "41": [0.25, 0.75, 0.02536, 0, 0.38889],
              "42": [0, 0.75, 0.11775, 0, 0.5],
              "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
              "44": [0.125, 0.08333, 0, 0, 0.27778],
              "45": [0, 0.44444, 0.01946, 0, 0.33333],
              "46": [0, 0.08333, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0.13164, 0, 0.5],
              "48": [0, 0.65556, 0.11156, 0, 0.5],
              "49": [0, 0.65556, 0.11156, 0, 0.5],
              "50": [0, 0.65556, 0.11156, 0, 0.5],
              "51": [0, 0.65556, 0.11156, 0, 0.5],
              "52": [0, 0.65556, 0.11156, 0, 0.5],
              "53": [0, 0.65556, 0.11156, 0, 0.5],
              "54": [0, 0.65556, 0.11156, 0, 0.5],
              "55": [0, 0.65556, 0.11156, 0, 0.5],
              "56": [0, 0.65556, 0.11156, 0, 0.5],
              "57": [0, 0.65556, 0.11156, 0, 0.5],
              "58": [0, 0.44444, 0.02502, 0, 0.27778],
              "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
              "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
              "63": [0, 0.69444, 0.11809, 0, 0.47222],
              "64": [0, 0.69444, 0.07555, 0, 0.66667],
              "65": [0, 0.69444, 0, 0, 0.66667],
              "66": [0, 0.69444, 0.08293, 0, 0.66667],
              "67": [0, 0.69444, 0.11983, 0, 0.63889],
              "68": [0, 0.69444, 0.07555, 0, 0.72223],
              "69": [0, 0.69444, 0.11983, 0, 0.59722],
              "70": [0, 0.69444, 0.13372, 0, 0.56945],
              "71": [0, 0.69444, 0.11983, 0, 0.66667],
              "72": [0, 0.69444, 0.08094, 0, 0.70834],
              "73": [0, 0.69444, 0.13372, 0, 0.27778],
              "74": [0, 0.69444, 0.08094, 0, 0.47222],
              "75": [0, 0.69444, 0.11983, 0, 0.69445],
              "76": [0, 0.69444, 0, 0, 0.54167],
              "77": [0, 0.69444, 0.08094, 0, 0.875],
              "78": [0, 0.69444, 0.08094, 0, 0.70834],
              "79": [0, 0.69444, 0.07555, 0, 0.73611],
              "80": [0, 0.69444, 0.08293, 0, 0.63889],
              "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
              "82": [0, 0.69444, 0.08293, 0, 0.64584],
              "83": [0, 0.69444, 0.09205, 0, 0.55556],
              "84": [0, 0.69444, 0.13372, 0, 0.68056],
              "85": [0, 0.69444, 0.08094, 0, 0.6875],
              "86": [0, 0.69444, 0.1615, 0, 0.66667],
              "87": [0, 0.69444, 0.1615, 0, 0.94445],
              "88": [0, 0.69444, 0.13372, 0, 0.66667],
              "89": [0, 0.69444, 0.17261, 0, 0.66667],
              "90": [0, 0.69444, 0.11983, 0, 0.61111],
              "91": [0.25, 0.75, 0.15942, 0, 0.28889],
              "93": [0.25, 0.75, 0.08719, 0, 0.28889],
              "94": [0, 0.69444, 0.0799, 0, 0.5],
              "95": [0.35, 0.09444, 0.08616, 0, 0.5],
              "97": [0, 0.44444, 981e-5, 0, 0.48056],
              "98": [0, 0.69444, 0.03057, 0, 0.51667],
              "99": [0, 0.44444, 0.08336, 0, 0.44445],
              "100": [0, 0.69444, 0.09483, 0, 0.51667],
              "101": [0, 0.44444, 0.06778, 0, 0.44445],
              "102": [0, 0.69444, 0.21705, 0, 0.30556],
              "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
              "104": [0, 0.69444, 0.01778, 0, 0.51667],
              "105": [0, 0.67937, 0.09718, 0, 0.23889],
              "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
              "107": [0, 0.69444, 0.08336, 0, 0.48889],
              "108": [0, 0.69444, 0.09483, 0, 0.23889],
              "109": [0, 0.44444, 0.01778, 0, 0.79445],
              "110": [0, 0.44444, 0.01778, 0, 0.51667],
              "111": [0, 0.44444, 0.06613, 0, 0.5],
              "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
              "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
              "114": [0, 0.44444, 0.10836, 0, 0.34167],
              "115": [0, 0.44444, 0.0778, 0, 0.38333],
              "116": [0, 0.57143, 0.07225, 0, 0.36111],
              "117": [0, 0.44444, 0.04169, 0, 0.51667],
              "118": [0, 0.44444, 0.10836, 0, 0.46111],
              "119": [0, 0.44444, 0.10836, 0, 0.68334],
              "120": [0, 0.44444, 0.09169, 0, 0.46111],
              "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
              "122": [0, 0.44444, 0.08752, 0, 0.43472],
              "126": [0.35, 0.32659, 0.08826, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.67937, 0.06385, 0, 0.5],
              "176": [0, 0.69444, 0, 0, 0.73752],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "305": [0, 0.44444, 0.04169, 0, 0.23889],
              "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
              "710": [0, 0.69444, 0.0799, 0, 0.5],
              "711": [0, 0.63194, 0.08432, 0, 0.5],
              "713": [0, 0.60889, 0.08776, 0, 0.5],
              "714": [0, 0.69444, 0.09205, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0.09483, 0, 0.5],
              "729": [0, 0.67937, 0.07774, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.73752],
              "732": [0, 0.67659, 0.08826, 0, 0.5],
              "733": [0, 0.69444, 0.09205, 0, 0.5],
              "915": [0, 0.69444, 0.13372, 0, 0.54167],
              "916": [0, 0.69444, 0, 0, 0.83334],
              "920": [0, 0.69444, 0.07555, 0, 0.77778],
              "923": [0, 0.69444, 0, 0, 0.61111],
              "926": [0, 0.69444, 0.12816, 0, 0.66667],
              "928": [0, 0.69444, 0.08094, 0, 0.70834],
              "931": [0, 0.69444, 0.11983, 0, 0.72222],
              "933": [0, 0.69444, 0.09031, 0, 0.77778],
              "934": [0, 0.69444, 0.04603, 0, 0.72222],
              "936": [0, 0.69444, 0.09031, 0, 0.77778],
              "937": [0, 0.69444, 0.08293, 0, 0.72222],
              "8211": [0, 0.44444, 0.08616, 0, 0.5],
              "8212": [0, 0.44444, 0.08616, 0, 1],
              "8216": [0, 0.69444, 0.07816, 0, 0.27778],
              "8217": [0, 0.69444, 0.07816, 0, 0.27778],
              "8220": [0, 0.69444, 0.14205, 0, 0.5],
              "8221": [0, 0.69444, 316e-5, 0, 0.5]
            },
            "SansSerif-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.31945],
              "34": [0, 0.69444, 0, 0, 0.5],
              "35": [0.19444, 0.69444, 0, 0, 0.83334],
              "36": [0.05556, 0.75, 0, 0, 0.5],
              "37": [0.05556, 0.75, 0, 0, 0.83334],
              "38": [0, 0.69444, 0, 0, 0.75834],
              "39": [0, 0.69444, 0, 0, 0.27778],
              "40": [0.25, 0.75, 0, 0, 0.38889],
              "41": [0.25, 0.75, 0, 0, 0.38889],
              "42": [0, 0.75, 0, 0, 0.5],
              "43": [0.08333, 0.58333, 0, 0, 0.77778],
              "44": [0.125, 0.08333, 0, 0, 0.27778],
              "45": [0, 0.44444, 0, 0, 0.33333],
              "46": [0, 0.08333, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0, 0, 0.5],
              "48": [0, 0.65556, 0, 0, 0.5],
              "49": [0, 0.65556, 0, 0, 0.5],
              "50": [0, 0.65556, 0, 0, 0.5],
              "51": [0, 0.65556, 0, 0, 0.5],
              "52": [0, 0.65556, 0, 0, 0.5],
              "53": [0, 0.65556, 0, 0, 0.5],
              "54": [0, 0.65556, 0, 0, 0.5],
              "55": [0, 0.65556, 0, 0, 0.5],
              "56": [0, 0.65556, 0, 0, 0.5],
              "57": [0, 0.65556, 0, 0, 0.5],
              "58": [0, 0.44444, 0, 0, 0.27778],
              "59": [0.125, 0.44444, 0, 0, 0.27778],
              "61": [-0.13, 0.37, 0, 0, 0.77778],
              "63": [0, 0.69444, 0, 0, 0.47222],
              "64": [0, 0.69444, 0, 0, 0.66667],
              "65": [0, 0.69444, 0, 0, 0.66667],
              "66": [0, 0.69444, 0, 0, 0.66667],
              "67": [0, 0.69444, 0, 0, 0.63889],
              "68": [0, 0.69444, 0, 0, 0.72223],
              "69": [0, 0.69444, 0, 0, 0.59722],
              "70": [0, 0.69444, 0, 0, 0.56945],
              "71": [0, 0.69444, 0, 0, 0.66667],
              "72": [0, 0.69444, 0, 0, 0.70834],
              "73": [0, 0.69444, 0, 0, 0.27778],
              "74": [0, 0.69444, 0, 0, 0.47222],
              "75": [0, 0.69444, 0, 0, 0.69445],
              "76": [0, 0.69444, 0, 0, 0.54167],
              "77": [0, 0.69444, 0, 0, 0.875],
              "78": [0, 0.69444, 0, 0, 0.70834],
              "79": [0, 0.69444, 0, 0, 0.73611],
              "80": [0, 0.69444, 0, 0, 0.63889],
              "81": [0.125, 0.69444, 0, 0, 0.73611],
              "82": [0, 0.69444, 0, 0, 0.64584],
              "83": [0, 0.69444, 0, 0, 0.55556],
              "84": [0, 0.69444, 0, 0, 0.68056],
              "85": [0, 0.69444, 0, 0, 0.6875],
              "86": [0, 0.69444, 0.01389, 0, 0.66667],
              "87": [0, 0.69444, 0.01389, 0, 0.94445],
              "88": [0, 0.69444, 0, 0, 0.66667],
              "89": [0, 0.69444, 0.025, 0, 0.66667],
              "90": [0, 0.69444, 0, 0, 0.61111],
              "91": [0.25, 0.75, 0, 0, 0.28889],
              "93": [0.25, 0.75, 0, 0, 0.28889],
              "94": [0, 0.69444, 0, 0, 0.5],
              "95": [0.35, 0.09444, 0.02778, 0, 0.5],
              "97": [0, 0.44444, 0, 0, 0.48056],
              "98": [0, 0.69444, 0, 0, 0.51667],
              "99": [0, 0.44444, 0, 0, 0.44445],
              "100": [0, 0.69444, 0, 0, 0.51667],
              "101": [0, 0.44444, 0, 0, 0.44445],
              "102": [0, 0.69444, 0.06944, 0, 0.30556],
              "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
              "104": [0, 0.69444, 0, 0, 0.51667],
              "105": [0, 0.67937, 0, 0, 0.23889],
              "106": [0.19444, 0.67937, 0, 0, 0.26667],
              "107": [0, 0.69444, 0, 0, 0.48889],
              "108": [0, 0.69444, 0, 0, 0.23889],
              "109": [0, 0.44444, 0, 0, 0.79445],
              "110": [0, 0.44444, 0, 0, 0.51667],
              "111": [0, 0.44444, 0, 0, 0.5],
              "112": [0.19444, 0.44444, 0, 0, 0.51667],
              "113": [0.19444, 0.44444, 0, 0, 0.51667],
              "114": [0, 0.44444, 0.01389, 0, 0.34167],
              "115": [0, 0.44444, 0, 0, 0.38333],
              "116": [0, 0.57143, 0, 0, 0.36111],
              "117": [0, 0.44444, 0, 0, 0.51667],
              "118": [0, 0.44444, 0.01389, 0, 0.46111],
              "119": [0, 0.44444, 0.01389, 0, 0.68334],
              "120": [0, 0.44444, 0, 0, 0.46111],
              "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
              "122": [0, 0.44444, 0, 0, 0.43472],
              "126": [0.35, 0.32659, 0, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.67937, 0, 0, 0.5],
              "176": [0, 0.69444, 0, 0, 0.66667],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "305": [0, 0.44444, 0, 0, 0.23889],
              "567": [0.19444, 0.44444, 0, 0, 0.26667],
              "710": [0, 0.69444, 0, 0, 0.5],
              "711": [0, 0.63194, 0, 0, 0.5],
              "713": [0, 0.60889, 0, 0, 0.5],
              "714": [0, 0.69444, 0, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0, 0, 0.5],
              "729": [0, 0.67937, 0, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.66667],
              "732": [0, 0.67659, 0, 0, 0.5],
              "733": [0, 0.69444, 0, 0, 0.5],
              "915": [0, 0.69444, 0, 0, 0.54167],
              "916": [0, 0.69444, 0, 0, 0.83334],
              "920": [0, 0.69444, 0, 0, 0.77778],
              "923": [0, 0.69444, 0, 0, 0.61111],
              "926": [0, 0.69444, 0, 0, 0.66667],
              "928": [0, 0.69444, 0, 0, 0.70834],
              "931": [0, 0.69444, 0, 0, 0.72222],
              "933": [0, 0.69444, 0, 0, 0.77778],
              "934": [0, 0.69444, 0, 0, 0.72222],
              "936": [0, 0.69444, 0, 0, 0.77778],
              "937": [0, 0.69444, 0, 0, 0.72222],
              "8211": [0, 0.44444, 0.02778, 0, 0.5],
              "8212": [0, 0.44444, 0.02778, 0, 1],
              "8216": [0, 0.69444, 0, 0, 0.27778],
              "8217": [0, 0.69444, 0, 0, 0.27778],
              "8220": [0, 0.69444, 0, 0, 0.5],
              "8221": [0, 0.69444, 0, 0, 0.5]
            },
            "Script-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.7, 0.22925, 0, 0.80253],
              "66": [0, 0.7, 0.04087, 0, 0.90757],
              "67": [0, 0.7, 0.1689, 0, 0.66619],
              "68": [0, 0.7, 0.09371, 0, 0.77443],
              "69": [0, 0.7, 0.18583, 0, 0.56162],
              "70": [0, 0.7, 0.13634, 0, 0.89544],
              "71": [0, 0.7, 0.17322, 0, 0.60961],
              "72": [0, 0.7, 0.29694, 0, 0.96919],
              "73": [0, 0.7, 0.19189, 0, 0.80907],
              "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
              "75": [0, 0.7, 0.31259, 0, 0.91364],
              "76": [0, 0.7, 0.19189, 0, 0.87373],
              "77": [0, 0.7, 0.15981, 0, 1.08031],
              "78": [0, 0.7, 0.3525, 0, 0.9015],
              "79": [0, 0.7, 0.08078, 0, 0.73787],
              "80": [0, 0.7, 0.08078, 0, 1.01262],
              "81": [0, 0.7, 0.03305, 0, 0.88282],
              "82": [0, 0.7, 0.06259, 0, 0.85],
              "83": [0, 0.7, 0.19189, 0, 0.86767],
              "84": [0, 0.7, 0.29087, 0, 0.74697],
              "85": [0, 0.7, 0.25815, 0, 0.79996],
              "86": [0, 0.7, 0.27523, 0, 0.62204],
              "87": [0, 0.7, 0.27523, 0, 0.80532],
              "88": [0, 0.7, 0.26006, 0, 0.94445],
              "89": [0, 0.7, 0.2939, 0, 0.70961],
              "90": [0, 0.7, 0.24037, 0, 0.8212],
              "160": [0, 0, 0, 0, 0.25]
            },
            "Size1-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.35001, 0.85, 0, 0, 0.45834],
              "41": [0.35001, 0.85, 0, 0, 0.45834],
              "47": [0.35001, 0.85, 0, 0, 0.57778],
              "91": [0.35001, 0.85, 0, 0, 0.41667],
              "92": [0.35001, 0.85, 0, 0, 0.57778],
              "93": [0.35001, 0.85, 0, 0, 0.41667],
              "123": [0.35001, 0.85, 0, 0, 0.58334],
              "125": [0.35001, 0.85, 0, 0, 0.58334],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.72222, 0, 0, 0.55556],
              "732": [0, 0.72222, 0, 0, 0.55556],
              "770": [0, 0.72222, 0, 0, 0.55556],
              "771": [0, 0.72222, 0, 0, 0.55556],
              "8214": [-99e-5, 0.601, 0, 0, 0.77778],
              "8593": [1e-5, 0.6, 0, 0, 0.66667],
              "8595": [1e-5, 0.6, 0, 0, 0.66667],
              "8657": [1e-5, 0.6, 0, 0, 0.77778],
              "8659": [1e-5, 0.6, 0, 0, 0.77778],
              "8719": [0.25001, 0.75, 0, 0, 0.94445],
              "8720": [0.25001, 0.75, 0, 0, 0.94445],
              "8721": [0.25001, 0.75, 0, 0, 1.05556],
              "8730": [0.35001, 0.85, 0, 0, 1],
              "8739": [-599e-5, 0.606, 0, 0, 0.33333],
              "8741": [-599e-5, 0.606, 0, 0, 0.55556],
              "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
              "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
              "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
              "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
              "8896": [0.25001, 0.75, 0, 0, 0.83334],
              "8897": [0.25001, 0.75, 0, 0, 0.83334],
              "8898": [0.25001, 0.75, 0, 0, 0.83334],
              "8899": [0.25001, 0.75, 0, 0, 0.83334],
              "8968": [0.35001, 0.85, 0, 0, 0.47222],
              "8969": [0.35001, 0.85, 0, 0, 0.47222],
              "8970": [0.35001, 0.85, 0, 0, 0.47222],
              "8971": [0.35001, 0.85, 0, 0, 0.47222],
              "9168": [-99e-5, 0.601, 0, 0, 0.66667],
              "10216": [0.35001, 0.85, 0, 0, 0.47222],
              "10217": [0.35001, 0.85, 0, 0, 0.47222],
              "10752": [0.25001, 0.75, 0, 0, 1.11111],
              "10753": [0.25001, 0.75, 0, 0, 1.11111],
              "10754": [0.25001, 0.75, 0, 0, 1.11111],
              "10756": [0.25001, 0.75, 0, 0, 0.83334],
              "10758": [0.25001, 0.75, 0, 0, 0.83334]
            },
            "Size2-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.65002, 1.15, 0, 0, 0.59722],
              "41": [0.65002, 1.15, 0, 0, 0.59722],
              "47": [0.65002, 1.15, 0, 0, 0.81111],
              "91": [0.65002, 1.15, 0, 0, 0.47222],
              "92": [0.65002, 1.15, 0, 0, 0.81111],
              "93": [0.65002, 1.15, 0, 0, 0.47222],
              "123": [0.65002, 1.15, 0, 0, 0.66667],
              "125": [0.65002, 1.15, 0, 0, 0.66667],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.75, 0, 0, 1],
              "732": [0, 0.75, 0, 0, 1],
              "770": [0, 0.75, 0, 0, 1],
              "771": [0, 0.75, 0, 0, 1],
              "8719": [0.55001, 1.05, 0, 0, 1.27778],
              "8720": [0.55001, 1.05, 0, 0, 1.27778],
              "8721": [0.55001, 1.05, 0, 0, 1.44445],
              "8730": [0.65002, 1.15, 0, 0, 1],
              "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
              "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
              "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
              "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
              "8896": [0.55001, 1.05, 0, 0, 1.11111],
              "8897": [0.55001, 1.05, 0, 0, 1.11111],
              "8898": [0.55001, 1.05, 0, 0, 1.11111],
              "8899": [0.55001, 1.05, 0, 0, 1.11111],
              "8968": [0.65002, 1.15, 0, 0, 0.52778],
              "8969": [0.65002, 1.15, 0, 0, 0.52778],
              "8970": [0.65002, 1.15, 0, 0, 0.52778],
              "8971": [0.65002, 1.15, 0, 0, 0.52778],
              "10216": [0.65002, 1.15, 0, 0, 0.61111],
              "10217": [0.65002, 1.15, 0, 0, 0.61111],
              "10752": [0.55001, 1.05, 0, 0, 1.51112],
              "10753": [0.55001, 1.05, 0, 0, 1.51112],
              "10754": [0.55001, 1.05, 0, 0, 1.51112],
              "10756": [0.55001, 1.05, 0, 0, 1.11111],
              "10758": [0.55001, 1.05, 0, 0, 1.11111]
            },
            "Size3-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.95003, 1.45, 0, 0, 0.73611],
              "41": [0.95003, 1.45, 0, 0, 0.73611],
              "47": [0.95003, 1.45, 0, 0, 1.04445],
              "91": [0.95003, 1.45, 0, 0, 0.52778],
              "92": [0.95003, 1.45, 0, 0, 1.04445],
              "93": [0.95003, 1.45, 0, 0, 0.52778],
              "123": [0.95003, 1.45, 0, 0, 0.75],
              "125": [0.95003, 1.45, 0, 0, 0.75],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.75, 0, 0, 1.44445],
              "732": [0, 0.75, 0, 0, 1.44445],
              "770": [0, 0.75, 0, 0, 1.44445],
              "771": [0, 0.75, 0, 0, 1.44445],
              "8730": [0.95003, 1.45, 0, 0, 1],
              "8968": [0.95003, 1.45, 0, 0, 0.58334],
              "8969": [0.95003, 1.45, 0, 0, 0.58334],
              "8970": [0.95003, 1.45, 0, 0, 0.58334],
              "8971": [0.95003, 1.45, 0, 0, 0.58334],
              "10216": [0.95003, 1.45, 0, 0, 0.75],
              "10217": [0.95003, 1.45, 0, 0, 0.75]
            },
            "Size4-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [1.25003, 1.75, 0, 0, 0.79167],
              "41": [1.25003, 1.75, 0, 0, 0.79167],
              "47": [1.25003, 1.75, 0, 0, 1.27778],
              "91": [1.25003, 1.75, 0, 0, 0.58334],
              "92": [1.25003, 1.75, 0, 0, 1.27778],
              "93": [1.25003, 1.75, 0, 0, 0.58334],
              "123": [1.25003, 1.75, 0, 0, 0.80556],
              "125": [1.25003, 1.75, 0, 0, 0.80556],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.825, 0, 0, 1.8889],
              "732": [0, 0.825, 0, 0, 1.8889],
              "770": [0, 0.825, 0, 0, 1.8889],
              "771": [0, 0.825, 0, 0, 1.8889],
              "8730": [1.25003, 1.75, 0, 0, 1],
              "8968": [1.25003, 1.75, 0, 0, 0.63889],
              "8969": [1.25003, 1.75, 0, 0, 0.63889],
              "8970": [1.25003, 1.75, 0, 0, 0.63889],
              "8971": [1.25003, 1.75, 0, 0, 0.63889],
              "9115": [0.64502, 1.155, 0, 0, 0.875],
              "9116": [1e-5, 0.6, 0, 0, 0.875],
              "9117": [0.64502, 1.155, 0, 0, 0.875],
              "9118": [0.64502, 1.155, 0, 0, 0.875],
              "9119": [1e-5, 0.6, 0, 0, 0.875],
              "9120": [0.64502, 1.155, 0, 0, 0.875],
              "9121": [0.64502, 1.155, 0, 0, 0.66667],
              "9122": [-99e-5, 0.601, 0, 0, 0.66667],
              "9123": [0.64502, 1.155, 0, 0, 0.66667],
              "9124": [0.64502, 1.155, 0, 0, 0.66667],
              "9125": [-99e-5, 0.601, 0, 0, 0.66667],
              "9126": [0.64502, 1.155, 0, 0, 0.66667],
              "9127": [1e-5, 0.9, 0, 0, 0.88889],
              "9128": [0.65002, 1.15, 0, 0, 0.88889],
              "9129": [0.90001, 0, 0, 0, 0.88889],
              "9130": [0, 0.3, 0, 0, 0.88889],
              "9131": [1e-5, 0.9, 0, 0, 0.88889],
              "9132": [0.65002, 1.15, 0, 0, 0.88889],
              "9133": [0.90001, 0, 0, 0, 0.88889],
              "9143": [0.88502, 0.915, 0, 0, 1.05556],
              "10216": [1.25003, 1.75, 0, 0, 0.80556],
              "10217": [1.25003, 1.75, 0, 0, 0.80556],
              "57344": [-499e-5, 0.605, 0, 0, 1.05556],
              "57345": [-499e-5, 0.605, 0, 0, 1.05556],
              "57680": [0, 0.12, 0, 0, 0.45],
              "57681": [0, 0.12, 0, 0, 0.45],
              "57682": [0, 0.12, 0, 0, 0.45],
              "57683": [0, 0.12, 0, 0, 0.45]
            },
            "Typewriter-Regular": {
              "32": [0, 0, 0, 0, 0.525],
              "33": [0, 0.61111, 0, 0, 0.525],
              "34": [0, 0.61111, 0, 0, 0.525],
              "35": [0, 0.61111, 0, 0, 0.525],
              "36": [0.08333, 0.69444, 0, 0, 0.525],
              "37": [0.08333, 0.69444, 0, 0, 0.525],
              "38": [0, 0.61111, 0, 0, 0.525],
              "39": [0, 0.61111, 0, 0, 0.525],
              "40": [0.08333, 0.69444, 0, 0, 0.525],
              "41": [0.08333, 0.69444, 0, 0, 0.525],
              "42": [0, 0.52083, 0, 0, 0.525],
              "43": [-0.08056, 0.53055, 0, 0, 0.525],
              "44": [0.13889, 0.125, 0, 0, 0.525],
              "45": [-0.08056, 0.53055, 0, 0, 0.525],
              "46": [0, 0.125, 0, 0, 0.525],
              "47": [0.08333, 0.69444, 0, 0, 0.525],
              "48": [0, 0.61111, 0, 0, 0.525],
              "49": [0, 0.61111, 0, 0, 0.525],
              "50": [0, 0.61111, 0, 0, 0.525],
              "51": [0, 0.61111, 0, 0, 0.525],
              "52": [0, 0.61111, 0, 0, 0.525],
              "53": [0, 0.61111, 0, 0, 0.525],
              "54": [0, 0.61111, 0, 0, 0.525],
              "55": [0, 0.61111, 0, 0, 0.525],
              "56": [0, 0.61111, 0, 0, 0.525],
              "57": [0, 0.61111, 0, 0, 0.525],
              "58": [0, 0.43056, 0, 0, 0.525],
              "59": [0.13889, 0.43056, 0, 0, 0.525],
              "60": [-0.05556, 0.55556, 0, 0, 0.525],
              "61": [-0.19549, 0.41562, 0, 0, 0.525],
              "62": [-0.05556, 0.55556, 0, 0, 0.525],
              "63": [0, 0.61111, 0, 0, 0.525],
              "64": [0, 0.61111, 0, 0, 0.525],
              "65": [0, 0.61111, 0, 0, 0.525],
              "66": [0, 0.61111, 0, 0, 0.525],
              "67": [0, 0.61111, 0, 0, 0.525],
              "68": [0, 0.61111, 0, 0, 0.525],
              "69": [0, 0.61111, 0, 0, 0.525],
              "70": [0, 0.61111, 0, 0, 0.525],
              "71": [0, 0.61111, 0, 0, 0.525],
              "72": [0, 0.61111, 0, 0, 0.525],
              "73": [0, 0.61111, 0, 0, 0.525],
              "74": [0, 0.61111, 0, 0, 0.525],
              "75": [0, 0.61111, 0, 0, 0.525],
              "76": [0, 0.61111, 0, 0, 0.525],
              "77": [0, 0.61111, 0, 0, 0.525],
              "78": [0, 0.61111, 0, 0, 0.525],
              "79": [0, 0.61111, 0, 0, 0.525],
              "80": [0, 0.61111, 0, 0, 0.525],
              "81": [0.13889, 0.61111, 0, 0, 0.525],
              "82": [0, 0.61111, 0, 0, 0.525],
              "83": [0, 0.61111, 0, 0, 0.525],
              "84": [0, 0.61111, 0, 0, 0.525],
              "85": [0, 0.61111, 0, 0, 0.525],
              "86": [0, 0.61111, 0, 0, 0.525],
              "87": [0, 0.61111, 0, 0, 0.525],
              "88": [0, 0.61111, 0, 0, 0.525],
              "89": [0, 0.61111, 0, 0, 0.525],
              "90": [0, 0.61111, 0, 0, 0.525],
              "91": [0.08333, 0.69444, 0, 0, 0.525],
              "92": [0.08333, 0.69444, 0, 0, 0.525],
              "93": [0.08333, 0.69444, 0, 0, 0.525],
              "94": [0, 0.61111, 0, 0, 0.525],
              "95": [0.09514, 0, 0, 0, 0.525],
              "96": [0, 0.61111, 0, 0, 0.525],
              "97": [0, 0.43056, 0, 0, 0.525],
              "98": [0, 0.61111, 0, 0, 0.525],
              "99": [0, 0.43056, 0, 0, 0.525],
              "100": [0, 0.61111, 0, 0, 0.525],
              "101": [0, 0.43056, 0, 0, 0.525],
              "102": [0, 0.61111, 0, 0, 0.525],
              "103": [0.22222, 0.43056, 0, 0, 0.525],
              "104": [0, 0.61111, 0, 0, 0.525],
              "105": [0, 0.61111, 0, 0, 0.525],
              "106": [0.22222, 0.61111, 0, 0, 0.525],
              "107": [0, 0.61111, 0, 0, 0.525],
              "108": [0, 0.61111, 0, 0, 0.525],
              "109": [0, 0.43056, 0, 0, 0.525],
              "110": [0, 0.43056, 0, 0, 0.525],
              "111": [0, 0.43056, 0, 0, 0.525],
              "112": [0.22222, 0.43056, 0, 0, 0.525],
              "113": [0.22222, 0.43056, 0, 0, 0.525],
              "114": [0, 0.43056, 0, 0, 0.525],
              "115": [0, 0.43056, 0, 0, 0.525],
              "116": [0, 0.55358, 0, 0, 0.525],
              "117": [0, 0.43056, 0, 0, 0.525],
              "118": [0, 0.43056, 0, 0, 0.525],
              "119": [0, 0.43056, 0, 0, 0.525],
              "120": [0, 0.43056, 0, 0, 0.525],
              "121": [0.22222, 0.43056, 0, 0, 0.525],
              "122": [0, 0.43056, 0, 0, 0.525],
              "123": [0.08333, 0.69444, 0, 0, 0.525],
              "124": [0.08333, 0.69444, 0, 0, 0.525],
              "125": [0.08333, 0.69444, 0, 0, 0.525],
              "126": [0, 0.61111, 0, 0, 0.525],
              "127": [0, 0.61111, 0, 0, 0.525],
              "160": [0, 0, 0, 0, 0.525],
              "176": [0, 0.61111, 0, 0, 0.525],
              "184": [0.19445, 0, 0, 0, 0.525],
              "305": [0, 0.43056, 0, 0, 0.525],
              "567": [0.22222, 0.43056, 0, 0, 0.525],
              "711": [0, 0.56597, 0, 0, 0.525],
              "713": [0, 0.56555, 0, 0, 0.525],
              "714": [0, 0.61111, 0, 0, 0.525],
              "715": [0, 0.61111, 0, 0, 0.525],
              "728": [0, 0.61111, 0, 0, 0.525],
              "730": [0, 0.61111, 0, 0, 0.525],
              "770": [0, 0.61111, 0, 0, 0.525],
              "771": [0, 0.61111, 0, 0, 0.525],
              "776": [0, 0.61111, 0, 0, 0.525],
              "915": [0, 0.61111, 0, 0, 0.525],
              "916": [0, 0.61111, 0, 0, 0.525],
              "920": [0, 0.61111, 0, 0, 0.525],
              "923": [0, 0.61111, 0, 0, 0.525],
              "926": [0, 0.61111, 0, 0, 0.525],
              "928": [0, 0.61111, 0, 0, 0.525],
              "931": [0, 0.61111, 0, 0, 0.525],
              "933": [0, 0.61111, 0, 0, 0.525],
              "934": [0, 0.61111, 0, 0, 0.525],
              "936": [0, 0.61111, 0, 0, 0.525],
              "937": [0, 0.61111, 0, 0, 0.525],
              "8216": [0, 0.61111, 0, 0, 0.525],
              "8217": [0, 0.61111, 0, 0, 0.525],
              "8242": [0, 0.61111, 0, 0, 0.525],
              "9251": [0.11111, 0.21944, 0, 0, 0.525]
            }
          };
          const sigmasAndXis2 = {
            slant: [0.25, 0.25, 0.25],
            // sigma1
            space: [0, 0, 0],
            // sigma2
            stretch: [0, 0, 0],
            // sigma3
            shrink: [0, 0, 0],
            // sigma4
            xHeight: [0.431, 0.431, 0.431],
            // sigma5
            quad: [1, 1.171, 1.472],
            // sigma6
            extraSpace: [0, 0, 0],
            // sigma7
            num1: [0.677, 0.732, 0.925],
            // sigma8
            num2: [0.394, 0.384, 0.387],
            // sigma9
            num3: [0.444, 0.471, 0.504],
            // sigma10
            denom1: [0.686, 0.752, 1.025],
            // sigma11
            denom2: [0.345, 0.344, 0.532],
            // sigma12
            sup1: [0.413, 0.503, 0.504],
            // sigma13
            sup2: [0.363, 0.431, 0.404],
            // sigma14
            sup3: [0.289, 0.286, 0.294],
            // sigma15
            sub1: [0.15, 0.143, 0.2],
            // sigma16
            sub2: [0.247, 0.286, 0.4],
            // sigma17
            supDrop: [0.386, 0.353, 0.494],
            // sigma18
            subDrop: [0.05, 0.071, 0.1],
            // sigma19
            delim1: [2.39, 1.7, 1.98],
            // sigma20
            delim2: [1.01, 1.157, 1.42],
            // sigma21
            axisHeight: [0.25, 0.25, 0.25],
            // sigma22
            // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
            // they correspond to the font parameters of the extension fonts (family 3).
            // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
            // match cmex7, we'd use cmex7.tfm values for script and scriptscript
            // values.
            defaultRuleThickness: [0.04, 0.049, 0.049],
            // xi8; cmex7: 0.049
            bigOpSpacing1: [0.111, 0.111, 0.111],
            // xi9
            bigOpSpacing2: [0.166, 0.166, 0.166],
            // xi10
            bigOpSpacing3: [0.2, 0.2, 0.2],
            // xi11
            bigOpSpacing4: [0.6, 0.611, 0.611],
            // xi12; cmex7: 0.611
            bigOpSpacing5: [0.1, 0.143, 0.143],
            // xi13; cmex7: 0.143
            // The \sqrt rule width is taken from the height of the surd character.
            // Since we use the same font at all sizes, this thickness doesn't scale.
            sqrtRuleThickness: [0.04, 0.04, 0.04],
            // This value determines how large a pt is, for metrics which are defined
            // in terms of pts.
            // This value is also used in katex.scss; if you change it make sure the
            // values match.
            ptPerEm: [10, 10, 10],
            // The space between adjacent `|` columns in an array definition. From
            // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
            doubleRuleSep: [0.2, 0.2, 0.2],
            // The width of separator lines in {array} environments. From
            // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
            arrayRuleWidth: [0.04, 0.04, 0.04],
            // Two values from LaTeX source2e:
            fboxsep: [0.3, 0.3, 0.3],
            //        3 pt / ptPerEm
            fboxrule: [0.04, 0.04, 0.04]
            // 0.4 pt / ptPerEm
          };
          const extraCharacterMap2 = {
            // Latin-1
            "": "A",
            "": "D",
            "": "o",
            "": "a",
            "": "d",
            "": "o",
            // Cyrillic
            "": "A",
            "": "B",
            "": "B",
            "": "F",
            "": "A",
            "": "E",
            "": "K",
            "": "3",
            "": "N",
            "": "N",
            "": "K",
            "": "N",
            "": "M",
            "": "H",
            "": "O",
            "": "N",
            "": "P",
            "": "C",
            "": "T",
            "": "y",
            "": "O",
            "": "X",
            "": "U",
            "": "h",
            "": "W",
            "": "W",
            "": "B",
            "": "X",
            "": "B",
            "": "3",
            "": "X",
            "": "R",
            "": "a",
            "": "b",
            "": "a",
            "": "r",
            "": "y",
            "": "e",
            "": "m",
            "": "e",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "m",
            "": "n",
            "": "o",
            "": "n",
            "": "p",
            "": "c",
            "": "o",
            "": "y",
            "": "b",
            "": "x",
            "": "n",
            "": "n",
            "": "w",
            "": "w",
            "": "a",
            "": "m",
            "": "a",
            "": "e",
            "": "m",
            "": "r"
          };
          function setFontMetrics2(fontName, metrics) {
            fontMetricsData2[fontName] = metrics;
          }
          function getCharacterMetrics2(character, font, mode) {
            if (!fontMetricsData2[font]) {
              throw new Error("Font metrics not found for font: " + font + ".");
            }
            let ch = character.charCodeAt(0);
            let metrics = fontMetricsData2[font][ch];
            if (!metrics && character[0] in extraCharacterMap2) {
              ch = extraCharacterMap2[character[0]].charCodeAt(0);
              metrics = fontMetricsData2[font][ch];
            }
            if (!metrics && mode === "text") {
              if (supportedCodepoint2(ch)) {
                metrics = fontMetricsData2[font][77];
              }
            }
            if (metrics) {
              return {
                depth: metrics[0],
                height: metrics[1],
                italic: metrics[2],
                skew: metrics[3],
                width: metrics[4]
              };
            }
          }
          const fontMetricsBySizeIndex2 = {};
          function getGlobalMetrics2(size) {
            let sizeIndex;
            if (size >= 5) {
              sizeIndex = 0;
            } else if (size >= 3) {
              sizeIndex = 1;
            } else {
              sizeIndex = 2;
            }
            if (!fontMetricsBySizeIndex2[sizeIndex]) {
              const metrics = fontMetricsBySizeIndex2[sizeIndex] = {
                cssEmPerMu: sigmasAndXis2.quad[sizeIndex] / 18
              };
              for (const key in sigmasAndXis2) {
                if (sigmasAndXis2.hasOwnProperty(key)) {
                  metrics[key] = sigmasAndXis2[key][sizeIndex];
                }
              }
            }
            return fontMetricsBySizeIndex2[sizeIndex];
          }
          const sizeStyleMap2 = [
            // Each element contains [textsize, scriptsize, scriptscriptsize].
            // The size mappings are taken from TeX with \normalsize=10pt.
            [1, 1, 1],
            // size1: [5, 5, 5]              \tiny
            [2, 1, 1],
            // size2: [6, 5, 5]
            [3, 1, 1],
            // size3: [7, 5, 5]              \scriptsize
            [4, 2, 1],
            // size4: [8, 6, 5]              \footnotesize
            [5, 2, 1],
            // size5: [9, 6, 5]              \small
            [6, 3, 1],
            // size6: [10, 7, 5]             \normalsize
            [7, 4, 2],
            // size7: [12, 8, 6]             \large
            [8, 6, 3],
            // size8: [14.4, 10, 7]          \Large
            [9, 7, 6],
            // size9: [17.28, 12, 10]        \LARGE
            [10, 8, 7],
            // size10: [20.74, 14.4, 12]     \huge
            [11, 10, 9]
            // size11: [24.88, 20.74, 17.28] \HUGE
          ];
          const sizeMultipliers2 = [
            // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
            // you change size indexes, change that function.
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1,
            1.2,
            1.44,
            1.728,
            2.074,
            2.488
          ];
          const sizeAtStyle3 = function(size, style) {
            return style.size < 2 ? size : sizeStyleMap2[size - 1][style.size - 1];
          };
          class Options2 {
            // A font family applies to a group of fonts (i.e. SansSerif), while a font
            // represents a specific font (i.e. SansSerif Bold).
            // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
            /**
             * The base size index.
             */
            constructor(data) {
              this.style = void 0;
              this.color = void 0;
              this.size = void 0;
              this.textSize = void 0;
              this.phantom = void 0;
              this.font = void 0;
              this.fontFamily = void 0;
              this.fontWeight = void 0;
              this.fontShape = void 0;
              this.sizeMultiplier = void 0;
              this.maxSize = void 0;
              this.minRuleThickness = void 0;
              this._fontMetrics = void 0;
              this.style = data.style;
              this.color = data.color;
              this.size = data.size || Options2.BASESIZE;
              this.textSize = data.textSize || this.size;
              this.phantom = !!data.phantom;
              this.font = data.font || "";
              this.fontFamily = data.fontFamily || "";
              this.fontWeight = data.fontWeight || "";
              this.fontShape = data.fontShape || "";
              this.sizeMultiplier = sizeMultipliers2[this.size - 1];
              this.maxSize = data.maxSize;
              this.minRuleThickness = data.minRuleThickness;
              this._fontMetrics = void 0;
            }
            /**
             * Returns a new options object with the same properties as "this".  Properties
             * from "extension" will be copied to the new options object.
             */
            extend(extension) {
              const data = {
                style: this.style,
                size: this.size,
                textSize: this.textSize,
                color: this.color,
                phantom: this.phantom,
                font: this.font,
                fontFamily: this.fontFamily,
                fontWeight: this.fontWeight,
                fontShape: this.fontShape,
                maxSize: this.maxSize,
                minRuleThickness: this.minRuleThickness
              };
              for (const key in extension) {
                if (extension.hasOwnProperty(key)) {
                  data[key] = extension[key];
                }
              }
              return new Options2(data);
            }
            /**
             * Return an options object with the given style. If `this.style === style`,
             * returns `this`.
             */
            havingStyle(style) {
              if (this.style === style) {
                return this;
              } else {
                return this.extend({
                  style,
                  size: sizeAtStyle3(this.textSize, style)
                });
              }
            }
            /**
             * Return an options object with a cramped version of the current style. If
             * the current style is cramped, returns `this`.
             */
            havingCrampedStyle() {
              return this.havingStyle(this.style.cramp());
            }
            /**
             * Return an options object with the given size and in at least `\textstyle`.
             * Returns `this` if appropriate.
             */
            havingSize(size) {
              if (this.size === size && this.textSize === size) {
                return this;
              } else {
                return this.extend({
                  style: this.style.text(),
                  size,
                  textSize: size,
                  sizeMultiplier: sizeMultipliers2[size - 1]
                });
              }
            }
            /**
             * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
             * changes to at least `\textstyle`.
             */
            havingBaseStyle(style) {
              style = style || this.style.text();
              const wantSize = sizeAtStyle3(Options2.BASESIZE, style);
              if (this.size === wantSize && this.textSize === Options2.BASESIZE && this.style === style) {
                return this;
              } else {
                return this.extend({
                  style,
                  size: wantSize
                });
              }
            }
            /**
             * Remove the effect of sizing changes such as \Huge.
             * Keep the effect of the current style, such as \scriptstyle.
             */
            havingBaseSizing() {
              let size;
              switch (this.style.id) {
                case 4:
                case 5:
                  size = 3;
                  break;
                case 6:
                case 7:
                  size = 1;
                  break;
                default:
                  size = 6;
              }
              return this.extend({
                style: this.style.text(),
                size
              });
            }
            /**
             * Create a new options object with the given color.
             */
            withColor(color2) {
              return this.extend({
                color: color2
              });
            }
            /**
             * Create a new options object with "phantom" set to true.
             */
            withPhantom() {
              return this.extend({
                phantom: true
              });
            }
            /**
             * Creates a new options object with the given math font or old text font.
             * @type {[type]}
             */
            withFont(font) {
              return this.extend({
                font
              });
            }
            /**
             * Create a new options objects with the given fontFamily.
             */
            withTextFontFamily(fontFamily) {
              return this.extend({
                fontFamily,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontWeight(fontWeight) {
              return this.extend({
                fontWeight,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontShape(fontShape) {
              return this.extend({
                fontShape,
                font: ""
              });
            }
            /**
             * Return the CSS sizing classes required to switch from enclosing options
             * `oldOptions` to `this`. Returns an array of classes.
             */
            sizingClasses(oldOptions) {
              if (oldOptions.size !== this.size) {
                return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
              } else {
                return [];
              }
            }
            /**
             * Return the CSS sizing classes required to switch to the base size. Like
             * `this.havingSize(BASESIZE).sizingClasses(this)`.
             */
            baseSizingClasses() {
              if (this.size !== Options2.BASESIZE) {
                return ["sizing", "reset-size" + this.size, "size" + Options2.BASESIZE];
              } else {
                return [];
              }
            }
            /**
             * Return the font metrics for this size.
             */
            fontMetrics() {
              if (!this._fontMetrics) {
                this._fontMetrics = getGlobalMetrics2(this.size);
              }
              return this._fontMetrics;
            }
            /**
             * Gets the CSS color of the current options object
             */
            getColor() {
              if (this.phantom) {
                return "transparent";
              } else {
                return this.color;
              }
            }
          }
          Options2.BASESIZE = 6;
          var src_Options = Options2;
          const ptPerUnit2 = {
            // https://en.wikibooks.org/wiki/LaTeX/Lengths and
            // https://tex.stackexchange.com/a/8263
            "pt": 1,
            // TeX point
            "mm": 7227 / 2540,
            // millimeter
            "cm": 7227 / 254,
            // centimeter
            "in": 72.27,
            // inch
            "bp": 803 / 800,
            // big (PostScript) points
            "pc": 12,
            // pica
            "dd": 1238 / 1157,
            // didot
            "cc": 14856 / 1157,
            // cicero (12 didot)
            "nd": 685 / 642,
            // new didot
            "nc": 1370 / 107,
            // new cicero (12 new didot)
            "sp": 1 / 65536,
            // scaled point (TeX's internal smallest unit)
            // https://tex.stackexchange.com/a/41371
            "px": 803 / 800
            // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
          };
          const relativeUnit2 = {
            "ex": true,
            "em": true,
            "mu": true
          };
          const validUnit3 = function(unit2) {
            if (typeof unit2 !== "string") {
              unit2 = unit2.unit;
            }
            return unit2 in ptPerUnit2 || unit2 in relativeUnit2 || unit2 === "ex";
          };
          const calculateSize3 = function(sizeValue, options) {
            let scale;
            if (sizeValue.unit in ptPerUnit2) {
              scale = ptPerUnit2[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
            } else if (sizeValue.unit === "mu") {
              scale = options.fontMetrics().cssEmPerMu;
            } else {
              let unitOptions;
              if (options.style.isTight()) {
                unitOptions = options.havingStyle(options.style.text());
              } else {
                unitOptions = options;
              }
              if (sizeValue.unit === "ex") {
                scale = unitOptions.fontMetrics().xHeight;
              } else if (sizeValue.unit === "em") {
                scale = unitOptions.fontMetrics().quad;
              } else {
                throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
              }
              if (unitOptions !== options) {
                scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            return Math.min(sizeValue.number * scale, options.maxSize);
          };
          const makeEm3 = function(n) {
            return +n.toFixed(4) + "em";
          };
          const createClass3 = function(classes) {
            return classes.filter((cls) => cls).join(" ");
          };
          const initNode3 = function(classes, options, style) {
            this.classes = classes || [];
            this.attributes = {};
            this.height = 0;
            this.depth = 0;
            this.maxFontSize = 0;
            this.style = style || {};
            if (options) {
              if (options.style.isTight()) {
                this.classes.push("mtight");
              }
              const color2 = options.getColor();
              if (color2) {
                this.style.color = color2;
              }
            }
          };
          const toNode3 = function(tagName) {
            const node = document.createElement(tagName);
            node.className = createClass3(this.classes);
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                node.style[style] = this.style[style];
              }
            }
            for (const attr in this.attributes) {
              if (this.attributes.hasOwnProperty(attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            for (let i = 0; i < this.children.length; i++) {
              node.appendChild(this.children[i].toNode());
            }
            return node;
          };
          const invalidAttributeNameRegex2 = /[\s"'>/=\x00-\x1f]/;
          const toMarkup3 = function(tagName) {
            let markup = "<" + tagName;
            if (this.classes.length) {
              markup += ' class="' + utils2.escape(createClass3(this.classes)) + '"';
            }
            let styles3 = "";
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles3) {
              markup += ' style="' + utils2.escape(styles3) + '"';
            }
            for (const attr in this.attributes) {
              if (this.attributes.hasOwnProperty(attr)) {
                if (invalidAttributeNameRegex2.test(attr)) {
                  throw new src_ParseError("Invalid attribute name '" + attr + "'");
                }
                markup += " " + attr + '="' + utils2.escape(this.attributes[attr]) + '"';
              }
            }
            markup += ">";
            for (let i = 0; i < this.children.length; i++) {
              markup += this.children[i].toMarkup();
            }
            markup += "</" + tagName + ">";
            return markup;
          };
          class Span2 {
            constructor(classes, children, options, style) {
              this.children = void 0;
              this.attributes = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.width = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              initNode3.call(this, classes, options, style);
              this.children = children || [];
            }
            /**
             * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
             * all browsers support attributes the same, and having too many custom
             * attributes is probably bad.
             */
            setAttribute(attribute2, value) {
              this.attributes[attribute2] = value;
            }
            hasClass(className) {
              return this.classes.includes(className);
            }
            toNode() {
              return toNode3.call(this, "span");
            }
            toMarkup() {
              return toMarkup3.call(this, "span");
            }
          }
          class Anchor2 {
            constructor(href, classes, children, options) {
              this.children = void 0;
              this.attributes = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              initNode3.call(this, classes, options);
              this.children = children || [];
              this.setAttribute("href", href);
            }
            setAttribute(attribute2, value) {
              this.attributes[attribute2] = value;
            }
            hasClass(className) {
              return this.classes.includes(className);
            }
            toNode() {
              return toNode3.call(this, "a");
            }
            toMarkup() {
              return toMarkup3.call(this, "a");
            }
          }
          class Img2 {
            constructor(src, alt, style) {
              this.src = void 0;
              this.alt = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              this.alt = alt;
              this.src = src;
              this.classes = ["mord"];
              this.style = style;
            }
            hasClass(className) {
              return this.classes.includes(className);
            }
            toNode() {
              const node = document.createElement("img");
              node.src = this.src;
              node.alt = this.alt;
              node.className = "mord";
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  node.style[style] = this.style[style];
                }
              }
              return node;
            }
            toMarkup() {
              let markup = '<img src="' + utils2.escape(this.src) + '"' + (' alt="' + utils2.escape(this.alt) + '"');
              let styles3 = "";
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles3) {
                markup += ' style="' + utils2.escape(styles3) + '"';
              }
              markup += "'/>";
              return markup;
            }
          }
          const iCombinations2 = {
            "": "",
            "": "",
            "": "",
            // '': '\u0131\u0304', // enable when we add Extended Latin
            "": ""
          };
          class SymbolNode2 {
            constructor(text2, height, depth, italic, skew2, width, classes, style) {
              this.text = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.italic = void 0;
              this.skew = void 0;
              this.width = void 0;
              this.maxFontSize = void 0;
              this.classes = void 0;
              this.style = void 0;
              this.text = text2;
              this.height = height || 0;
              this.depth = depth || 0;
              this.italic = italic || 0;
              this.skew = skew2 || 0;
              this.width = width || 0;
              this.classes = classes || [];
              this.style = style || {};
              this.maxFontSize = 0;
              const script = scriptFromCodepoint2(this.text.charCodeAt(0));
              if (script) {
                this.classes.push(script + "_fallback");
              }
              if (/[]/.test(this.text)) {
                this.text = iCombinations2[this.text];
              }
            }
            hasClass(className) {
              return this.classes.includes(className);
            }
            /**
             * Creates a text node or span from a symbol node. Note that a span is only
             * created if it is needed.
             */
            toNode() {
              const node = document.createTextNode(this.text);
              let span = null;
              if (this.italic > 0) {
                span = document.createElement("span");
                span.style.marginRight = makeEm3(this.italic);
              }
              if (this.classes.length > 0) {
                span = span || document.createElement("span");
                span.className = createClass3(this.classes);
              }
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  span = span || document.createElement("span");
                  span.style[style] = this.style[style];
                }
              }
              if (span) {
                span.appendChild(node);
                return span;
              } else {
                return node;
              }
            }
            /**
             * Creates markup for a symbol node.
             */
            toMarkup() {
              let needsSpan = false;
              let markup = "<span";
              if (this.classes.length) {
                needsSpan = true;
                markup += ' class="';
                markup += utils2.escape(createClass3(this.classes));
                markup += '"';
              }
              let styles3 = "";
              if (this.italic > 0) {
                styles3 += "margin-right:" + this.italic + "em;";
              }
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles3 += utils2.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles3) {
                needsSpan = true;
                markup += ' style="' + utils2.escape(styles3) + '"';
              }
              const escaped = utils2.escape(this.text);
              if (needsSpan) {
                markup += ">";
                markup += escaped;
                markup += "</span>";
                return markup;
              } else {
                return escaped;
              }
            }
          }
          class SvgNode2 {
            constructor(children, attributes) {
              this.children = void 0;
              this.attributes = void 0;
              this.children = children || [];
              this.attributes = attributes || {};
            }
            toNode() {
              const svgNS = "http://www.w3.org/2000/svg";
              const node = document.createElementNS(svgNS, "svg");
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  node.setAttribute(attr, this.attributes[attr]);
                }
              }
              for (let i = 0; i < this.children.length; i++) {
                node.appendChild(this.children[i].toNode());
              }
              return node;
            }
            toMarkup() {
              let markup = '<svg xmlns="http://www.w3.org/2000/svg"';
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  markup += " " + attr + '="' + utils2.escape(this.attributes[attr]) + '"';
                }
              }
              markup += ">";
              for (let i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              markup += "</svg>";
              return markup;
            }
          }
          class PathNode2 {
            constructor(pathName, alternate) {
              this.pathName = void 0;
              this.alternate = void 0;
              this.pathName = pathName;
              this.alternate = alternate;
            }
            toNode() {
              const svgNS = "http://www.w3.org/2000/svg";
              const node = document.createElementNS(svgNS, "path");
              if (this.alternate) {
                node.setAttribute("d", this.alternate);
              } else {
                node.setAttribute("d", path2[this.pathName]);
              }
              return node;
            }
            toMarkup() {
              if (this.alternate) {
                return '<path d="' + utils2.escape(this.alternate) + '"/>';
              } else {
                return '<path d="' + utils2.escape(path2[this.pathName]) + '"/>';
              }
            }
          }
          class LineNode2 {
            constructor(attributes) {
              this.attributes = void 0;
              this.attributes = attributes || {};
            }
            toNode() {
              const svgNS = "http://www.w3.org/2000/svg";
              const node = document.createElementNS(svgNS, "line");
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  node.setAttribute(attr, this.attributes[attr]);
                }
              }
              return node;
            }
            toMarkup() {
              let markup = "<line";
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  markup += " " + attr + '="' + utils2.escape(this.attributes[attr]) + '"';
                }
              }
              markup += "/>";
              return markup;
            }
          }
          function assertSymbolDomNode2(group) {
            if (group instanceof SymbolNode2) {
              return group;
            } else {
              throw new Error("Expected symbolNode but got " + String(group) + ".");
            }
          }
          function assertSpan2(group) {
            if (group instanceof Span2) {
              return group;
            } else {
              throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
            }
          }
          const ATOMS2 = {
            "bin": 1,
            "close": 1,
            "inner": 1,
            "open": 1,
            "punct": 1,
            "rel": 1
          };
          const NON_ATOMS2 = {
            "accent-token": 1,
            "mathord": 1,
            "op-token": 1,
            "spacing": 1,
            "textord": 1
          };
          const symbols2 = {
            "math": {},
            "text": {}
          };
          var src_symbols = symbols2;
          function defineSymbol2(mode, font, group, replace2, name, acceptUnicodeChar) {
            symbols2[mode][name] = {
              font,
              group,
              replace: replace2
            };
            if (acceptUnicodeChar && replace2) {
              symbols2[mode][replace2] = symbols2[mode][name];
            }
          }
          const math2 = "math";
          const symbols_text = "text";
          const main2 = "main";
          const ams2 = "ams";
          const accent2 = "accent-token";
          const bin2 = "bin";
          const symbols_close = "close";
          const inner2 = "inner";
          const mathord2 = "mathord";
          const op2 = "op-token";
          const symbols_open = "open";
          const punct2 = "punct";
          const rel2 = "rel";
          const spacing2 = "spacing";
          const textord2 = "textord";
          defineSymbol2(math2, main2, rel2, "", "\\equiv", true);
          defineSymbol2(math2, main2, rel2, "", "\\prec", true);
          defineSymbol2(math2, main2, rel2, "", "\\succ", true);
          defineSymbol2(math2, main2, rel2, "", "\\sim", true);
          defineSymbol2(math2, main2, rel2, "", "\\perp");
          defineSymbol2(math2, main2, rel2, "", "\\preceq", true);
          defineSymbol2(math2, main2, rel2, "", "\\succeq", true);
          defineSymbol2(math2, main2, rel2, "", "\\simeq", true);
          defineSymbol2(math2, main2, rel2, "", "\\mid", true);
          defineSymbol2(math2, main2, rel2, "", "\\ll", true);
          defineSymbol2(math2, main2, rel2, "", "\\gg", true);
          defineSymbol2(math2, main2, rel2, "", "\\asymp", true);
          defineSymbol2(math2, main2, rel2, "", "\\parallel");
          defineSymbol2(math2, main2, rel2, "", "\\bowtie", true);
          defineSymbol2(math2, main2, rel2, "", "\\smile", true);
          defineSymbol2(math2, main2, rel2, "", "\\sqsubseteq", true);
          defineSymbol2(math2, main2, rel2, "", "\\sqsupseteq", true);
          defineSymbol2(math2, main2, rel2, "", "\\doteq", true);
          defineSymbol2(math2, main2, rel2, "", "\\frown", true);
          defineSymbol2(math2, main2, rel2, "", "\\ni", true);
          defineSymbol2(math2, main2, rel2, "", "\\propto", true);
          defineSymbol2(math2, main2, rel2, "", "\\vdash", true);
          defineSymbol2(math2, main2, rel2, "", "\\dashv", true);
          defineSymbol2(math2, main2, rel2, "", "\\owns");
          defineSymbol2(math2, main2, punct2, ".", "\\ldotp");
          defineSymbol2(math2, main2, punct2, "", "\\cdotp");
          defineSymbol2(math2, main2, textord2, "#", "\\#");
          defineSymbol2(symbols_text, main2, textord2, "#", "\\#");
          defineSymbol2(math2, main2, textord2, "&", "\\&");
          defineSymbol2(symbols_text, main2, textord2, "&", "\\&");
          defineSymbol2(math2, main2, textord2, "", "\\aleph", true);
          defineSymbol2(math2, main2, textord2, "", "\\forall", true);
          defineSymbol2(math2, main2, textord2, "", "\\hbar", true);
          defineSymbol2(math2, main2, textord2, "", "\\exists", true);
          defineSymbol2(math2, main2, textord2, "", "\\nabla", true);
          defineSymbol2(math2, main2, textord2, "", "\\flat", true);
          defineSymbol2(math2, main2, textord2, "", "\\ell", true);
          defineSymbol2(math2, main2, textord2, "", "\\natural", true);
          defineSymbol2(math2, main2, textord2, "", "\\clubsuit", true);
          defineSymbol2(math2, main2, textord2, "", "\\wp", true);
          defineSymbol2(math2, main2, textord2, "", "\\sharp", true);
          defineSymbol2(math2, main2, textord2, "", "\\diamondsuit", true);
          defineSymbol2(math2, main2, textord2, "", "\\Re", true);
          defineSymbol2(math2, main2, textord2, "", "\\heartsuit", true);
          defineSymbol2(math2, main2, textord2, "", "\\Im", true);
          defineSymbol2(math2, main2, textord2, "", "\\spadesuit", true);
          defineSymbol2(math2, main2, textord2, "", "\\S", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\S");
          defineSymbol2(math2, main2, textord2, "", "\\P", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\P");
          defineSymbol2(math2, main2, textord2, "", "\\dag");
          defineSymbol2(symbols_text, main2, textord2, "", "\\dag");
          defineSymbol2(symbols_text, main2, textord2, "", "\\textdagger");
          defineSymbol2(math2, main2, textord2, "", "\\ddag");
          defineSymbol2(symbols_text, main2, textord2, "", "\\ddag");
          defineSymbol2(symbols_text, main2, textord2, "", "\\textdaggerdbl");
          defineSymbol2(math2, main2, symbols_close, "", "\\rmoustache", true);
          defineSymbol2(math2, main2, symbols_open, "", "\\lmoustache", true);
          defineSymbol2(math2, main2, symbols_close, "", "\\rgroup", true);
          defineSymbol2(math2, main2, symbols_open, "", "\\lgroup", true);
          defineSymbol2(math2, main2, bin2, "", "\\mp", true);
          defineSymbol2(math2, main2, bin2, "", "\\ominus", true);
          defineSymbol2(math2, main2, bin2, "", "\\uplus", true);
          defineSymbol2(math2, main2, bin2, "", "\\sqcap", true);
          defineSymbol2(math2, main2, bin2, "", "\\ast");
          defineSymbol2(math2, main2, bin2, "", "\\sqcup", true);
          defineSymbol2(math2, main2, bin2, "", "\\bigcirc", true);
          defineSymbol2(math2, main2, bin2, "", "\\bullet", true);
          defineSymbol2(math2, main2, bin2, "", "\\ddagger");
          defineSymbol2(math2, main2, bin2, "", "\\wr", true);
          defineSymbol2(math2, main2, bin2, "", "\\amalg");
          defineSymbol2(math2, main2, bin2, "&", "\\And");
          defineSymbol2(math2, main2, rel2, "", "\\longleftarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Leftarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Longleftarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\longrightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Rightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Longrightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\leftrightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\longleftrightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Leftrightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Longleftrightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\mapsto", true);
          defineSymbol2(math2, main2, rel2, "", "\\longmapsto", true);
          defineSymbol2(math2, main2, rel2, "", "\\nearrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\hookleftarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\hookrightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\searrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\leftharpoonup", true);
          defineSymbol2(math2, main2, rel2, "", "\\rightharpoonup", true);
          defineSymbol2(math2, main2, rel2, "", "\\swarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\leftharpoondown", true);
          defineSymbol2(math2, main2, rel2, "", "\\rightharpoondown", true);
          defineSymbol2(math2, main2, rel2, "", "\\nwarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\rightleftharpoons", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nless", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@nleqslant");
          defineSymbol2(math2, ams2, rel2, "", "\\@nleqq");
          defineSymbol2(math2, ams2, rel2, "", "\\lneq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\lneqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@lvertneqq");
          defineSymbol2(math2, ams2, rel2, "", "\\lnsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\lnapprox", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nprec", true);
          defineSymbol2(math2, ams2, rel2, "", "\\npreceq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\precnsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\precnapprox", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@nshortmid");
          defineSymbol2(math2, ams2, rel2, "", "\\nmid", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nvdash", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nvDash", true);
          defineSymbol2(math2, ams2, rel2, "", "\\ntriangleleft");
          defineSymbol2(math2, ams2, rel2, "", "\\ntrianglelefteq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\subsetneq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@varsubsetneq");
          defineSymbol2(math2, ams2, rel2, "", "\\subsetneqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@varsubsetneqq");
          defineSymbol2(math2, ams2, rel2, "", "\\ngtr", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@ngeqslant");
          defineSymbol2(math2, ams2, rel2, "", "\\@ngeqq");
          defineSymbol2(math2, ams2, rel2, "", "\\gneq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\gneqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@gvertneqq");
          defineSymbol2(math2, ams2, rel2, "", "\\gnsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\gnapprox", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nsucc", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nsucceq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\succnsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\succnapprox", true);
          defineSymbol2(math2, ams2, rel2, "", "\\ncong", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@nshortparallel");
          defineSymbol2(math2, ams2, rel2, "", "\\nparallel", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nVDash", true);
          defineSymbol2(math2, ams2, rel2, "", "\\ntriangleright");
          defineSymbol2(math2, ams2, rel2, "", "\\ntrianglerighteq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@nsupseteqq");
          defineSymbol2(math2, ams2, rel2, "", "\\supsetneq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@varsupsetneq");
          defineSymbol2(math2, ams2, rel2, "", "\\supsetneqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@varsupsetneqq");
          defineSymbol2(math2, ams2, rel2, "", "\\nVdash", true);
          defineSymbol2(math2, ams2, rel2, "", "\\precneqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\succneqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\@nsubseteqq");
          defineSymbol2(math2, ams2, bin2, "", "\\unlhd");
          defineSymbol2(math2, ams2, bin2, "", "\\unrhd");
          defineSymbol2(math2, ams2, rel2, "", "\\nleftarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nrightarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nLeftarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nRightarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nleftrightarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nLeftrightarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\vartriangle");
          defineSymbol2(math2, ams2, textord2, "", "\\hslash");
          defineSymbol2(math2, ams2, textord2, "", "\\triangledown");
          defineSymbol2(math2, ams2, textord2, "", "\\lozenge");
          defineSymbol2(math2, ams2, textord2, "", "\\circledS");
          defineSymbol2(math2, ams2, textord2, "", "\\circledR");
          defineSymbol2(symbols_text, ams2, textord2, "", "\\circledR");
          defineSymbol2(math2, ams2, textord2, "", "\\measuredangle", true);
          defineSymbol2(math2, ams2, textord2, "", "\\nexists");
          defineSymbol2(math2, ams2, textord2, "", "\\mho");
          defineSymbol2(math2, ams2, textord2, "", "\\Finv", true);
          defineSymbol2(math2, ams2, textord2, "", "\\Game", true);
          defineSymbol2(math2, ams2, textord2, "", "\\backprime");
          defineSymbol2(math2, ams2, textord2, "", "\\blacktriangle");
          defineSymbol2(math2, ams2, textord2, "", "\\blacktriangledown");
          defineSymbol2(math2, ams2, textord2, "", "\\blacksquare");
          defineSymbol2(math2, ams2, textord2, "", "\\blacklozenge");
          defineSymbol2(math2, ams2, textord2, "", "\\bigstar");
          defineSymbol2(math2, ams2, textord2, "", "\\sphericalangle", true);
          defineSymbol2(math2, ams2, textord2, "", "\\complement", true);
          defineSymbol2(math2, ams2, textord2, "", "\\eth", true);
          defineSymbol2(symbols_text, main2, textord2, "", "");
          defineSymbol2(math2, ams2, textord2, "", "\\diagup");
          defineSymbol2(math2, ams2, textord2, "", "\\diagdown");
          defineSymbol2(math2, ams2, textord2, "", "\\square");
          defineSymbol2(math2, ams2, textord2, "", "\\Box");
          defineSymbol2(math2, ams2, textord2, "", "\\Diamond");
          defineSymbol2(math2, ams2, textord2, "", "\\yen", true);
          defineSymbol2(symbols_text, ams2, textord2, "", "\\yen", true);
          defineSymbol2(math2, ams2, textord2, "", "\\checkmark", true);
          defineSymbol2(symbols_text, ams2, textord2, "", "\\checkmark");
          defineSymbol2(math2, ams2, textord2, "", "\\beth", true);
          defineSymbol2(math2, ams2, textord2, "", "\\daleth", true);
          defineSymbol2(math2, ams2, textord2, "", "\\gimel", true);
          defineSymbol2(math2, ams2, textord2, "", "\\digamma", true);
          defineSymbol2(math2, ams2, textord2, "", "\\varkappa");
          defineSymbol2(math2, ams2, symbols_open, "", "\\@ulcorner", true);
          defineSymbol2(math2, ams2, symbols_close, "", "\\@urcorner", true);
          defineSymbol2(math2, ams2, symbols_open, "", "\\@llcorner", true);
          defineSymbol2(math2, ams2, symbols_close, "", "\\@lrcorner", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leqslant", true);
          defineSymbol2(math2, ams2, rel2, "", "\\eqslantless", true);
          defineSymbol2(math2, ams2, rel2, "", "\\lesssim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\lessapprox", true);
          defineSymbol2(math2, ams2, rel2, "", "\\approxeq", true);
          defineSymbol2(math2, ams2, bin2, "", "\\lessdot");
          defineSymbol2(math2, ams2, rel2, "", "\\lll", true);
          defineSymbol2(math2, ams2, rel2, "", "\\lessgtr", true);
          defineSymbol2(math2, ams2, rel2, "", "\\lesseqgtr", true);
          defineSymbol2(math2, ams2, rel2, "", "\\lesseqqgtr", true);
          defineSymbol2(math2, ams2, rel2, "", "\\doteqdot");
          defineSymbol2(math2, ams2, rel2, "", "\\risingdotseq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\fallingdotseq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\backsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\backsimeq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\subseteqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\Subset", true);
          defineSymbol2(math2, ams2, rel2, "", "\\sqsubset", true);
          defineSymbol2(math2, ams2, rel2, "", "\\preccurlyeq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\curlyeqprec", true);
          defineSymbol2(math2, ams2, rel2, "", "\\precsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\precapprox", true);
          defineSymbol2(math2, ams2, rel2, "", "\\vartriangleleft");
          defineSymbol2(math2, ams2, rel2, "", "\\trianglelefteq");
          defineSymbol2(math2, ams2, rel2, "", "\\vDash", true);
          defineSymbol2(math2, ams2, rel2, "", "\\Vvdash", true);
          defineSymbol2(math2, ams2, rel2, "", "\\smallsmile");
          defineSymbol2(math2, ams2, rel2, "", "\\smallfrown");
          defineSymbol2(math2, ams2, rel2, "", "\\bumpeq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\Bumpeq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\geqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\geqslant", true);
          defineSymbol2(math2, ams2, rel2, "", "\\eqslantgtr", true);
          defineSymbol2(math2, ams2, rel2, "", "\\gtrsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\gtrapprox", true);
          defineSymbol2(math2, ams2, bin2, "", "\\gtrdot");
          defineSymbol2(math2, ams2, rel2, "", "\\ggg", true);
          defineSymbol2(math2, ams2, rel2, "", "\\gtrless", true);
          defineSymbol2(math2, ams2, rel2, "", "\\gtreqless", true);
          defineSymbol2(math2, ams2, rel2, "", "\\gtreqqless", true);
          defineSymbol2(math2, ams2, rel2, "", "\\eqcirc", true);
          defineSymbol2(math2, ams2, rel2, "", "\\circeq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\triangleq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\thicksim");
          defineSymbol2(math2, ams2, rel2, "", "\\thickapprox");
          defineSymbol2(math2, ams2, rel2, "", "\\supseteqq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\Supset", true);
          defineSymbol2(math2, ams2, rel2, "", "\\sqsupset", true);
          defineSymbol2(math2, ams2, rel2, "", "\\succcurlyeq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\curlyeqsucc", true);
          defineSymbol2(math2, ams2, rel2, "", "\\succsim", true);
          defineSymbol2(math2, ams2, rel2, "", "\\succapprox", true);
          defineSymbol2(math2, ams2, rel2, "", "\\vartriangleright");
          defineSymbol2(math2, ams2, rel2, "", "\\trianglerighteq");
          defineSymbol2(math2, ams2, rel2, "", "\\Vdash", true);
          defineSymbol2(math2, ams2, rel2, "", "\\shortmid");
          defineSymbol2(math2, ams2, rel2, "", "\\shortparallel");
          defineSymbol2(math2, ams2, rel2, "", "\\between", true);
          defineSymbol2(math2, ams2, rel2, "", "\\pitchfork", true);
          defineSymbol2(math2, ams2, rel2, "", "\\varpropto");
          defineSymbol2(math2, ams2, rel2, "", "\\blacktriangleleft");
          defineSymbol2(math2, ams2, rel2, "", "\\therefore", true);
          defineSymbol2(math2, ams2, rel2, "", "\\backepsilon");
          defineSymbol2(math2, ams2, rel2, "", "\\blacktriangleright");
          defineSymbol2(math2, ams2, rel2, "", "\\because", true);
          defineSymbol2(math2, ams2, rel2, "", "\\llless");
          defineSymbol2(math2, ams2, rel2, "", "\\gggtr");
          defineSymbol2(math2, ams2, bin2, "", "\\lhd");
          defineSymbol2(math2, ams2, bin2, "", "\\rhd");
          defineSymbol2(math2, ams2, rel2, "", "\\eqsim", true);
          defineSymbol2(math2, main2, rel2, "", "\\Join");
          defineSymbol2(math2, ams2, rel2, "", "\\Doteq", true);
          defineSymbol2(math2, ams2, bin2, "", "\\dotplus", true);
          defineSymbol2(math2, ams2, bin2, "", "\\smallsetminus");
          defineSymbol2(math2, ams2, bin2, "", "\\Cap", true);
          defineSymbol2(math2, ams2, bin2, "", "\\Cup", true);
          defineSymbol2(math2, ams2, bin2, "", "\\doublebarwedge", true);
          defineSymbol2(math2, ams2, bin2, "", "\\boxminus", true);
          defineSymbol2(math2, ams2, bin2, "", "\\boxplus", true);
          defineSymbol2(math2, ams2, bin2, "", "\\divideontimes", true);
          defineSymbol2(math2, ams2, bin2, "", "\\ltimes", true);
          defineSymbol2(math2, ams2, bin2, "", "\\rtimes", true);
          defineSymbol2(math2, ams2, bin2, "", "\\leftthreetimes", true);
          defineSymbol2(math2, ams2, bin2, "", "\\rightthreetimes", true);
          defineSymbol2(math2, ams2, bin2, "", "\\curlywedge", true);
          defineSymbol2(math2, ams2, bin2, "", "\\curlyvee", true);
          defineSymbol2(math2, ams2, bin2, "", "\\circleddash", true);
          defineSymbol2(math2, ams2, bin2, "", "\\circledast", true);
          defineSymbol2(math2, ams2, bin2, "", "\\centerdot");
          defineSymbol2(math2, ams2, bin2, "", "\\intercal", true);
          defineSymbol2(math2, ams2, bin2, "", "\\doublecap");
          defineSymbol2(math2, ams2, bin2, "", "\\doublecup");
          defineSymbol2(math2, ams2, bin2, "", "\\boxtimes", true);
          defineSymbol2(math2, ams2, rel2, "", "\\dashrightarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\dashleftarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leftleftarrows", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leftrightarrows", true);
          defineSymbol2(math2, ams2, rel2, "", "\\Lleftarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\twoheadleftarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leftarrowtail", true);
          defineSymbol2(math2, ams2, rel2, "", "\\looparrowleft", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leftrightharpoons", true);
          defineSymbol2(math2, ams2, rel2, "", "\\curvearrowleft", true);
          defineSymbol2(math2, ams2, rel2, "", "\\circlearrowleft", true);
          defineSymbol2(math2, ams2, rel2, "", "\\Lsh", true);
          defineSymbol2(math2, ams2, rel2, "", "\\upuparrows", true);
          defineSymbol2(math2, ams2, rel2, "", "\\upharpoonleft", true);
          defineSymbol2(math2, ams2, rel2, "", "\\downharpoonleft", true);
          defineSymbol2(math2, main2, rel2, "", "\\origof", true);
          defineSymbol2(math2, main2, rel2, "", "\\imageof", true);
          defineSymbol2(math2, ams2, rel2, "", "\\multimap", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leftrightsquigarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\rightrightarrows", true);
          defineSymbol2(math2, ams2, rel2, "", "\\rightleftarrows", true);
          defineSymbol2(math2, ams2, rel2, "", "\\twoheadrightarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\rightarrowtail", true);
          defineSymbol2(math2, ams2, rel2, "", "\\looparrowright", true);
          defineSymbol2(math2, ams2, rel2, "", "\\curvearrowright", true);
          defineSymbol2(math2, ams2, rel2, "", "\\circlearrowright", true);
          defineSymbol2(math2, ams2, rel2, "", "\\Rsh", true);
          defineSymbol2(math2, ams2, rel2, "", "\\downdownarrows", true);
          defineSymbol2(math2, ams2, rel2, "", "\\upharpoonright", true);
          defineSymbol2(math2, ams2, rel2, "", "\\downharpoonright", true);
          defineSymbol2(math2, ams2, rel2, "", "\\rightsquigarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\leadsto");
          defineSymbol2(math2, ams2, rel2, "", "\\Rrightarrow", true);
          defineSymbol2(math2, ams2, rel2, "", "\\restriction");
          defineSymbol2(math2, main2, textord2, "", "`");
          defineSymbol2(math2, main2, textord2, "$", "\\$");
          defineSymbol2(symbols_text, main2, textord2, "$", "\\$");
          defineSymbol2(symbols_text, main2, textord2, "$", "\\textdollar");
          defineSymbol2(math2, main2, textord2, "%", "\\%");
          defineSymbol2(symbols_text, main2, textord2, "%", "\\%");
          defineSymbol2(math2, main2, textord2, "_", "\\_");
          defineSymbol2(symbols_text, main2, textord2, "_", "\\_");
          defineSymbol2(symbols_text, main2, textord2, "_", "\\textunderscore");
          defineSymbol2(math2, main2, textord2, "", "\\angle", true);
          defineSymbol2(math2, main2, textord2, "", "\\infty", true);
          defineSymbol2(math2, main2, textord2, "", "\\prime");
          defineSymbol2(math2, main2, textord2, "", "\\triangle");
          defineSymbol2(math2, main2, textord2, "", "\\Gamma", true);
          defineSymbol2(math2, main2, textord2, "", "\\Delta", true);
          defineSymbol2(math2, main2, textord2, "", "\\Theta", true);
          defineSymbol2(math2, main2, textord2, "", "\\Lambda", true);
          defineSymbol2(math2, main2, textord2, "", "\\Xi", true);
          defineSymbol2(math2, main2, textord2, "", "\\Pi", true);
          defineSymbol2(math2, main2, textord2, "", "\\Sigma", true);
          defineSymbol2(math2, main2, textord2, "", "\\Upsilon", true);
          defineSymbol2(math2, main2, textord2, "", "\\Phi", true);
          defineSymbol2(math2, main2, textord2, "", "\\Psi", true);
          defineSymbol2(math2, main2, textord2, "", "\\Omega", true);
          defineSymbol2(math2, main2, textord2, "A", "");
          defineSymbol2(math2, main2, textord2, "B", "");
          defineSymbol2(math2, main2, textord2, "E", "");
          defineSymbol2(math2, main2, textord2, "Z", "");
          defineSymbol2(math2, main2, textord2, "H", "");
          defineSymbol2(math2, main2, textord2, "I", "");
          defineSymbol2(math2, main2, textord2, "K", "");
          defineSymbol2(math2, main2, textord2, "M", "");
          defineSymbol2(math2, main2, textord2, "N", "");
          defineSymbol2(math2, main2, textord2, "O", "");
          defineSymbol2(math2, main2, textord2, "P", "");
          defineSymbol2(math2, main2, textord2, "T", "");
          defineSymbol2(math2, main2, textord2, "X", "");
          defineSymbol2(math2, main2, textord2, "", "\\neg", true);
          defineSymbol2(math2, main2, textord2, "", "\\lnot");
          defineSymbol2(math2, main2, textord2, "", "\\top");
          defineSymbol2(math2, main2, textord2, "", "\\bot");
          defineSymbol2(math2, main2, textord2, "", "\\emptyset");
          defineSymbol2(math2, ams2, textord2, "", "\\varnothing");
          defineSymbol2(math2, main2, mathord2, "", "\\alpha", true);
          defineSymbol2(math2, main2, mathord2, "", "\\beta", true);
          defineSymbol2(math2, main2, mathord2, "", "\\gamma", true);
          defineSymbol2(math2, main2, mathord2, "", "\\delta", true);
          defineSymbol2(math2, main2, mathord2, "", "\\epsilon", true);
          defineSymbol2(math2, main2, mathord2, "", "\\zeta", true);
          defineSymbol2(math2, main2, mathord2, "", "\\eta", true);
          defineSymbol2(math2, main2, mathord2, "", "\\theta", true);
          defineSymbol2(math2, main2, mathord2, "", "\\iota", true);
          defineSymbol2(math2, main2, mathord2, "", "\\kappa", true);
          defineSymbol2(math2, main2, mathord2, "", "\\lambda", true);
          defineSymbol2(math2, main2, mathord2, "", "\\mu", true);
          defineSymbol2(math2, main2, mathord2, "", "\\nu", true);
          defineSymbol2(math2, main2, mathord2, "", "\\xi", true);
          defineSymbol2(math2, main2, mathord2, "", "\\omicron", true);
          defineSymbol2(math2, main2, mathord2, "", "\\pi", true);
          defineSymbol2(math2, main2, mathord2, "", "\\rho", true);
          defineSymbol2(math2, main2, mathord2, "", "\\sigma", true);
          defineSymbol2(math2, main2, mathord2, "", "\\tau", true);
          defineSymbol2(math2, main2, mathord2, "", "\\upsilon", true);
          defineSymbol2(math2, main2, mathord2, "", "\\phi", true);
          defineSymbol2(math2, main2, mathord2, "", "\\chi", true);
          defineSymbol2(math2, main2, mathord2, "", "\\psi", true);
          defineSymbol2(math2, main2, mathord2, "", "\\omega", true);
          defineSymbol2(math2, main2, mathord2, "", "\\varepsilon", true);
          defineSymbol2(math2, main2, mathord2, "", "\\vartheta", true);
          defineSymbol2(math2, main2, mathord2, "", "\\varpi", true);
          defineSymbol2(math2, main2, mathord2, "", "\\varrho", true);
          defineSymbol2(math2, main2, mathord2, "", "\\varsigma", true);
          defineSymbol2(math2, main2, mathord2, "", "\\varphi", true);
          defineSymbol2(math2, main2, bin2, "", "*", true);
          defineSymbol2(math2, main2, bin2, "+", "+");
          defineSymbol2(math2, main2, bin2, "", "-", true);
          defineSymbol2(math2, main2, bin2, "", "\\cdot", true);
          defineSymbol2(math2, main2, bin2, "", "\\circ", true);
          defineSymbol2(math2, main2, bin2, "", "\\div", true);
          defineSymbol2(math2, main2, bin2, "", "\\pm", true);
          defineSymbol2(math2, main2, bin2, "", "\\times", true);
          defineSymbol2(math2, main2, bin2, "", "\\cap", true);
          defineSymbol2(math2, main2, bin2, "", "\\cup", true);
          defineSymbol2(math2, main2, bin2, "", "\\setminus", true);
          defineSymbol2(math2, main2, bin2, "", "\\land");
          defineSymbol2(math2, main2, bin2, "", "\\lor");
          defineSymbol2(math2, main2, bin2, "", "\\wedge", true);
          defineSymbol2(math2, main2, bin2, "", "\\vee", true);
          defineSymbol2(math2, main2, textord2, "", "\\surd");
          defineSymbol2(math2, main2, symbols_open, "", "\\langle", true);
          defineSymbol2(math2, main2, symbols_open, "", "\\lvert");
          defineSymbol2(math2, main2, symbols_open, "", "\\lVert");
          defineSymbol2(math2, main2, symbols_close, "?", "?");
          defineSymbol2(math2, main2, symbols_close, "!", "!");
          defineSymbol2(math2, main2, symbols_close, "", "\\rangle", true);
          defineSymbol2(math2, main2, symbols_close, "", "\\rvert");
          defineSymbol2(math2, main2, symbols_close, "", "\\rVert");
          defineSymbol2(math2, main2, rel2, "=", "=");
          defineSymbol2(math2, main2, rel2, ":", ":");
          defineSymbol2(math2, main2, rel2, "", "\\approx", true);
          defineSymbol2(math2, main2, rel2, "", "\\cong", true);
          defineSymbol2(math2, main2, rel2, "", "\\ge");
          defineSymbol2(math2, main2, rel2, "", "\\geq", true);
          defineSymbol2(math2, main2, rel2, "", "\\gets");
          defineSymbol2(math2, main2, rel2, ">", "\\gt", true);
          defineSymbol2(math2, main2, rel2, "", "\\in", true);
          defineSymbol2(math2, main2, rel2, "", "\\@not");
          defineSymbol2(math2, main2, rel2, "", "\\subset", true);
          defineSymbol2(math2, main2, rel2, "", "\\supset", true);
          defineSymbol2(math2, main2, rel2, "", "\\subseteq", true);
          defineSymbol2(math2, main2, rel2, "", "\\supseteq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nsubseteq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nsupseteq", true);
          defineSymbol2(math2, main2, rel2, "", "\\models");
          defineSymbol2(math2, main2, rel2, "", "\\leftarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\le");
          defineSymbol2(math2, main2, rel2, "", "\\leq", true);
          defineSymbol2(math2, main2, rel2, "<", "\\lt", true);
          defineSymbol2(math2, main2, rel2, "", "\\rightarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\to");
          defineSymbol2(math2, ams2, rel2, "", "\\ngeq", true);
          defineSymbol2(math2, ams2, rel2, "", "\\nleq", true);
          defineSymbol2(math2, main2, spacing2, "", "\\ ");
          defineSymbol2(math2, main2, spacing2, "", "\\space");
          defineSymbol2(math2, main2, spacing2, "", "\\nobreakspace");
          defineSymbol2(symbols_text, main2, spacing2, "", "\\ ");
          defineSymbol2(symbols_text, main2, spacing2, "", " ");
          defineSymbol2(symbols_text, main2, spacing2, "", "\\space");
          defineSymbol2(symbols_text, main2, spacing2, "", "\\nobreakspace");
          defineSymbol2(math2, main2, spacing2, null, "\\nobreak");
          defineSymbol2(math2, main2, spacing2, null, "\\allowbreak");
          defineSymbol2(math2, main2, punct2, ",", ",");
          defineSymbol2(math2, main2, punct2, ";", ";");
          defineSymbol2(math2, ams2, bin2, "", "\\barwedge", true);
          defineSymbol2(math2, ams2, bin2, "", "\\veebar", true);
          defineSymbol2(math2, main2, bin2, "", "\\odot", true);
          defineSymbol2(math2, main2, bin2, "", "\\oplus", true);
          defineSymbol2(math2, main2, bin2, "", "\\otimes", true);
          defineSymbol2(math2, main2, textord2, "", "\\partial", true);
          defineSymbol2(math2, main2, bin2, "", "\\oslash", true);
          defineSymbol2(math2, ams2, bin2, "", "\\circledcirc", true);
          defineSymbol2(math2, ams2, bin2, "", "\\boxdot", true);
          defineSymbol2(math2, main2, bin2, "", "\\bigtriangleup");
          defineSymbol2(math2, main2, bin2, "", "\\bigtriangledown");
          defineSymbol2(math2, main2, bin2, "", "\\dagger");
          defineSymbol2(math2, main2, bin2, "", "\\diamond");
          defineSymbol2(math2, main2, bin2, "", "\\star");
          defineSymbol2(math2, main2, bin2, "", "\\triangleleft");
          defineSymbol2(math2, main2, bin2, "", "\\triangleright");
          defineSymbol2(math2, main2, symbols_open, "{", "\\{");
          defineSymbol2(symbols_text, main2, textord2, "{", "\\{");
          defineSymbol2(symbols_text, main2, textord2, "{", "\\textbraceleft");
          defineSymbol2(math2, main2, symbols_close, "}", "\\}");
          defineSymbol2(symbols_text, main2, textord2, "}", "\\}");
          defineSymbol2(symbols_text, main2, textord2, "}", "\\textbraceright");
          defineSymbol2(math2, main2, symbols_open, "{", "\\lbrace");
          defineSymbol2(math2, main2, symbols_close, "}", "\\rbrace");
          defineSymbol2(math2, main2, symbols_open, "[", "\\lbrack", true);
          defineSymbol2(symbols_text, main2, textord2, "[", "\\lbrack", true);
          defineSymbol2(math2, main2, symbols_close, "]", "\\rbrack", true);
          defineSymbol2(symbols_text, main2, textord2, "]", "\\rbrack", true);
          defineSymbol2(math2, main2, symbols_open, "(", "\\lparen", true);
          defineSymbol2(math2, main2, symbols_close, ")", "\\rparen", true);
          defineSymbol2(symbols_text, main2, textord2, "<", "\\textless", true);
          defineSymbol2(symbols_text, main2, textord2, ">", "\\textgreater", true);
          defineSymbol2(math2, main2, symbols_open, "", "\\lfloor", true);
          defineSymbol2(math2, main2, symbols_close, "", "\\rfloor", true);
          defineSymbol2(math2, main2, symbols_open, "", "\\lceil", true);
          defineSymbol2(math2, main2, symbols_close, "", "\\rceil", true);
          defineSymbol2(math2, main2, textord2, "\\", "\\backslash");
          defineSymbol2(math2, main2, textord2, "", "|");
          defineSymbol2(math2, main2, textord2, "", "\\vert");
          defineSymbol2(symbols_text, main2, textord2, "|", "\\textbar", true);
          defineSymbol2(math2, main2, textord2, "", "\\|");
          defineSymbol2(math2, main2, textord2, "", "\\Vert");
          defineSymbol2(symbols_text, main2, textord2, "", "\\textbardbl");
          defineSymbol2(symbols_text, main2, textord2, "~", "\\textasciitilde");
          defineSymbol2(symbols_text, main2, textord2, "\\", "\\textbackslash");
          defineSymbol2(symbols_text, main2, textord2, "^", "\\textasciicircum");
          defineSymbol2(math2, main2, rel2, "", "\\uparrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Uparrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\downarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Downarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\updownarrow", true);
          defineSymbol2(math2, main2, rel2, "", "\\Updownarrow", true);
          defineSymbol2(math2, main2, op2, "", "\\coprod");
          defineSymbol2(math2, main2, op2, "", "\\bigvee");
          defineSymbol2(math2, main2, op2, "", "\\bigwedge");
          defineSymbol2(math2, main2, op2, "", "\\biguplus");
          defineSymbol2(math2, main2, op2, "", "\\bigcap");
          defineSymbol2(math2, main2, op2, "", "\\bigcup");
          defineSymbol2(math2, main2, op2, "", "\\int");
          defineSymbol2(math2, main2, op2, "", "\\intop");
          defineSymbol2(math2, main2, op2, "", "\\iint");
          defineSymbol2(math2, main2, op2, "", "\\iiint");
          defineSymbol2(math2, main2, op2, "", "\\prod");
          defineSymbol2(math2, main2, op2, "", "\\sum");
          defineSymbol2(math2, main2, op2, "", "\\bigotimes");
          defineSymbol2(math2, main2, op2, "", "\\bigoplus");
          defineSymbol2(math2, main2, op2, "", "\\bigodot");
          defineSymbol2(math2, main2, op2, "", "\\oint");
          defineSymbol2(math2, main2, op2, "", "\\oiint");
          defineSymbol2(math2, main2, op2, "", "\\oiiint");
          defineSymbol2(math2, main2, op2, "", "\\bigsqcup");
          defineSymbol2(math2, main2, op2, "", "\\smallint");
          defineSymbol2(symbols_text, main2, inner2, "", "\\textellipsis");
          defineSymbol2(math2, main2, inner2, "", "\\mathellipsis");
          defineSymbol2(symbols_text, main2, inner2, "", "\\ldots", true);
          defineSymbol2(math2, main2, inner2, "", "\\ldots", true);
          defineSymbol2(math2, main2, inner2, "", "\\@cdots", true);
          defineSymbol2(math2, main2, inner2, "", "\\ddots", true);
          defineSymbol2(math2, main2, textord2, "", "\\varvdots");
          defineSymbol2(symbols_text, main2, textord2, "", "\\varvdots");
          defineSymbol2(math2, main2, accent2, "", "\\acute");
          defineSymbol2(math2, main2, accent2, "", "\\grave");
          defineSymbol2(math2, main2, accent2, "", "\\ddot");
          defineSymbol2(math2, main2, accent2, "~", "\\tilde");
          defineSymbol2(math2, main2, accent2, "", "\\bar");
          defineSymbol2(math2, main2, accent2, "", "\\breve");
          defineSymbol2(math2, main2, accent2, "", "\\check");
          defineSymbol2(math2, main2, accent2, "^", "\\hat");
          defineSymbol2(math2, main2, accent2, "", "\\vec");
          defineSymbol2(math2, main2, accent2, "", "\\dot");
          defineSymbol2(math2, main2, accent2, "", "\\mathring");
          defineSymbol2(math2, main2, mathord2, "", "\\@imath");
          defineSymbol2(math2, main2, mathord2, "", "\\@jmath");
          defineSymbol2(math2, main2, textord2, "", "");
          defineSymbol2(math2, main2, textord2, "", "");
          defineSymbol2(symbols_text, main2, textord2, "", "\\i", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\j", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\ss", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\ae", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\oe", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\o", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\AE", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\OE", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\O", true);
          defineSymbol2(symbols_text, main2, accent2, "", "\\'");
          defineSymbol2(symbols_text, main2, accent2, "", "\\`");
          defineSymbol2(symbols_text, main2, accent2, "", "\\^");
          defineSymbol2(symbols_text, main2, accent2, "", "\\~");
          defineSymbol2(symbols_text, main2, accent2, "", "\\=");
          defineSymbol2(symbols_text, main2, accent2, "", "\\u");
          defineSymbol2(symbols_text, main2, accent2, "", "\\.");
          defineSymbol2(symbols_text, main2, accent2, "", "\\c");
          defineSymbol2(symbols_text, main2, accent2, "", "\\r");
          defineSymbol2(symbols_text, main2, accent2, "", "\\v");
          defineSymbol2(symbols_text, main2, accent2, "", '\\"');
          defineSymbol2(symbols_text, main2, accent2, "", "\\H");
          defineSymbol2(symbols_text, main2, accent2, "", "\\textcircled");
          const ligatures2 = {
            "--": true,
            "---": true,
            "``": true,
            "''": true
          };
          defineSymbol2(symbols_text, main2, textord2, "", "--", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\textendash");
          defineSymbol2(symbols_text, main2, textord2, "", "---", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\textemdash");
          defineSymbol2(symbols_text, main2, textord2, "", "`", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\textquoteleft");
          defineSymbol2(symbols_text, main2, textord2, "", "'", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\textquoteright");
          defineSymbol2(symbols_text, main2, textord2, "", "``", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\textquotedblleft");
          defineSymbol2(symbols_text, main2, textord2, "", "''", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\textquotedblright");
          defineSymbol2(math2, main2, textord2, "", "\\degree", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\degree");
          defineSymbol2(symbols_text, main2, textord2, "", "\\textdegree", true);
          defineSymbol2(math2, main2, textord2, "", "\\pounds");
          defineSymbol2(math2, main2, textord2, "", "\\mathsterling", true);
          defineSymbol2(symbols_text, main2, textord2, "", "\\pounds");
          defineSymbol2(symbols_text, main2, textord2, "", "\\textsterling", true);
          defineSymbol2(math2, ams2, textord2, "", "\\maltese");
          defineSymbol2(symbols_text, ams2, textord2, "", "\\maltese");
          const mathTextSymbols2 = '0123456789/@."';
          for (let i = 0; i < mathTextSymbols2.length; i++) {
            const ch = mathTextSymbols2.charAt(i);
            defineSymbol2(math2, main2, textord2, ch, ch);
          }
          const textSymbols2 = '0123456789!@*()-=+";:?/.,';
          for (let i = 0; i < textSymbols2.length; i++) {
            const ch = textSymbols2.charAt(i);
            defineSymbol2(symbols_text, main2, textord2, ch, ch);
          }
          const letters2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          for (let i = 0; i < letters2.length; i++) {
            const ch = letters2.charAt(i);
            defineSymbol2(math2, main2, mathord2, ch, ch);
            defineSymbol2(symbols_text, main2, textord2, ch, ch);
          }
          defineSymbol2(math2, ams2, textord2, "C", "");
          defineSymbol2(symbols_text, ams2, textord2, "C", "");
          defineSymbol2(math2, ams2, textord2, "H", "");
          defineSymbol2(symbols_text, ams2, textord2, "H", "");
          defineSymbol2(math2, ams2, textord2, "N", "");
          defineSymbol2(symbols_text, ams2, textord2, "N", "");
          defineSymbol2(math2, ams2, textord2, "P", "");
          defineSymbol2(symbols_text, ams2, textord2, "P", "");
          defineSymbol2(math2, ams2, textord2, "Q", "");
          defineSymbol2(symbols_text, ams2, textord2, "Q", "");
          defineSymbol2(math2, ams2, textord2, "R", "");
          defineSymbol2(symbols_text, ams2, textord2, "R", "");
          defineSymbol2(math2, ams2, textord2, "Z", "");
          defineSymbol2(symbols_text, ams2, textord2, "Z", "");
          defineSymbol2(math2, main2, mathord2, "h", "");
          defineSymbol2(symbols_text, main2, mathord2, "h", "");
          let wideChar2 = "";
          for (let i = 0; i < letters2.length; i++) {
            const ch = letters2.charAt(i);
            wideChar2 = String.fromCharCode(55349, 56320 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56372 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56424 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56580 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56684 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56736 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56788 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56840 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 56944 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            if (i < 26) {
              wideChar2 = String.fromCharCode(55349, 56632 + i);
              defineSymbol2(math2, main2, mathord2, ch, wideChar2);
              defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
              wideChar2 = String.fromCharCode(55349, 56476 + i);
              defineSymbol2(math2, main2, mathord2, ch, wideChar2);
              defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            }
          }
          wideChar2 = String.fromCharCode(55349, 56668);
          defineSymbol2(math2, main2, mathord2, "k", wideChar2);
          defineSymbol2(symbols_text, main2, textord2, "k", wideChar2);
          for (let i = 0; i < 10; i++) {
            const ch = i.toString();
            wideChar2 = String.fromCharCode(55349, 57294 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 57314 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 57324 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
            wideChar2 = String.fromCharCode(55349, 57334 + i);
            defineSymbol2(math2, main2, mathord2, ch, wideChar2);
            defineSymbol2(symbols_text, main2, textord2, ch, wideChar2);
          }
          const extraLatin2 = "";
          for (let i = 0; i < extraLatin2.length; i++) {
            const ch = extraLatin2.charAt(i);
            defineSymbol2(math2, main2, mathord2, ch, ch);
            defineSymbol2(symbols_text, main2, textord2, ch, ch);
          }
          const wideLatinLetterData2 = [
            ["mathbf", "textbf", "Main-Bold"],
            // A-Z bold upright
            ["mathbf", "textbf", "Main-Bold"],
            // a-z bold upright
            ["mathnormal", "textit", "Math-Italic"],
            // A-Z italic
            ["mathnormal", "textit", "Math-Italic"],
            // a-z italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // A-Z bold italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // a-z bold italic
            // Map fancy A-Z letters to script, not calligraphic.
            // This aligns with unicode-math and math fonts (except Cambria Math).
            ["mathscr", "textscr", "Script-Regular"],
            // A-Z script
            ["", "", ""],
            // a-z script.  No font
            ["", "", ""],
            // A-Z bold script. No font
            ["", "", ""],
            // a-z bold script. No font
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // A-Z Fraktur
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // a-z Fraktur
            ["mathbb", "textbb", "AMS-Regular"],
            // A-Z double-struck
            ["mathbb", "textbb", "AMS-Regular"],
            // k double-struck
            // Note that we are using a bold font, but font metrics for regular Fraktur.
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // A-Z bold Fraktur
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // a-z bold Fraktur
            ["mathsf", "textsf", "SansSerif-Regular"],
            // A-Z sans-serif
            ["mathsf", "textsf", "SansSerif-Regular"],
            // a-z sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // A-Z bold sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // a-z bold sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // A-Z italic sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // a-z italic sans-serif
            ["", "", ""],
            // A-Z bold italic sans. No font
            ["", "", ""],
            // a-z bold italic sans. No font
            ["mathtt", "texttt", "Typewriter-Regular"],
            // A-Z monospace
            ["mathtt", "texttt", "Typewriter-Regular"]
            // a-z monospace
          ];
          const wideNumeralData2 = [
            ["mathbf", "textbf", "Main-Bold"],
            // 0-9 bold
            ["", "", ""],
            // 0-9 double-struck. No KaTeX font.
            ["mathsf", "textsf", "SansSerif-Regular"],
            // 0-9 sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // 0-9 bold sans-serif
            ["mathtt", "texttt", "Typewriter-Regular"]
            // 0-9 monospace
          ];
          const wideCharacterFont3 = function(wideChar3, mode) {
            const H = wideChar3.charCodeAt(0);
            const L = wideChar3.charCodeAt(1);
            const codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
            const j = mode === "math" ? 0 : 1;
            if (119808 <= codePoint && codePoint < 120484) {
              const i = Math.floor((codePoint - 119808) / 26);
              return [wideLatinLetterData2[i][2], wideLatinLetterData2[i][j]];
            } else if (120782 <= codePoint && codePoint <= 120831) {
              const i = Math.floor((codePoint - 120782) / 10);
              return [wideNumeralData2[i][2], wideNumeralData2[i][j]];
            } else if (codePoint === 120485 || codePoint === 120486) {
              return [wideLatinLetterData2[0][2], wideLatinLetterData2[0][j]];
            } else if (120486 < codePoint && codePoint < 120782) {
              return ["", ""];
            } else {
              throw new src_ParseError("Unsupported character: " + wideChar3);
            }
          };
          class DocumentFragment2 {
            // Never used; needed for satisfying interface.
            constructor(children) {
              this.children = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              this.children = children;
              this.classes = [];
              this.height = 0;
              this.depth = 0;
              this.maxFontSize = 0;
              this.style = {};
            }
            hasClass(className) {
              return this.classes.includes(className);
            }
            /** Convert the fragment into a node. */
            toNode() {
              const frag = document.createDocumentFragment();
              for (let i = 0; i < this.children.length; i++) {
                frag.appendChild(this.children[i].toNode());
              }
              return frag;
            }
            /** Convert the fragment into HTML markup. */
            toMarkup() {
              let markup = "";
              for (let i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              return markup;
            }
            /**
             * Converts the math node into a string, similar to innerText. Applies to
             * MathDomNode's only.
             */
            toText() {
              const toText = (child) => child.toText();
              return this.children.map(toText).join("");
            }
          }
          const lookupSymbol3 = function(value, fontName, mode) {
            if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
              value = src_symbols[mode][value].replace;
            }
            return {
              value,
              metrics: getCharacterMetrics2(value, fontName, mode)
            };
          };
          const makeSymbol3 = function(value, fontName, mode, options, classes) {
            const lookup = lookupSymbol3(value, fontName, mode);
            const metrics = lookup.metrics;
            value = lookup.value;
            let symbolNode;
            if (metrics) {
              let italic = metrics.italic;
              if (mode === "text" || options && options.font === "mathit") {
                italic = 0;
              }
              symbolNode = new SymbolNode2(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
            } else {
              typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
              symbolNode = new SymbolNode2(value, 0, 0, 0, 0, 0, classes);
            }
            if (options) {
              symbolNode.maxFontSize = options.sizeMultiplier;
              if (options.style.isTight()) {
                symbolNode.classes.push("mtight");
              }
              const color2 = options.getColor();
              if (color2) {
                symbolNode.style.color = color2;
              }
            }
            return symbolNode;
          };
          const mathsym3 = function(value, mode, options, classes) {
            if (classes === void 0) {
              classes = [];
            }
            if (options.font === "boldsymbol" && lookupSymbol3(value, "Main-Bold", mode).metrics) {
              return makeSymbol3(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
            } else if (value === "\\" || src_symbols[mode][value].font === "main") {
              return makeSymbol3(value, "Main-Regular", mode, options, classes);
            } else {
              return makeSymbol3(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
            }
          };
          const boldsymbol3 = function(value, mode, options, classes, type) {
            if (type !== "textord" && lookupSymbol3(value, "Math-BoldItalic", mode).metrics) {
              return {
                fontName: "Math-BoldItalic",
                fontClass: "boldsymbol"
              };
            } else {
              return {
                fontName: "Main-Bold",
                fontClass: "mathbf"
              };
            }
          };
          const makeOrd3 = function(group, options, type) {
            const mode = group.mode;
            const text2 = group.text;
            const classes = ["mord"];
            const isFont = mode === "math" || mode === "text" && options.font;
            const fontOrFamily = isFont ? options.font : options.fontFamily;
            let wideFontName = "";
            let wideFontClass = "";
            if (text2.charCodeAt(0) === 55349) {
              [wideFontName, wideFontClass] = wideCharacterFont3(text2, mode);
            }
            if (wideFontName.length > 0) {
              return makeSymbol3(text2, wideFontName, mode, options, classes.concat(wideFontClass));
            } else if (fontOrFamily) {
              let fontName;
              let fontClasses;
              if (fontOrFamily === "boldsymbol") {
                const fontData = boldsymbol3(text2, mode, options, classes, type);
                fontName = fontData.fontName;
                fontClasses = [fontData.fontClass];
              } else if (isFont) {
                fontName = fontMap2[fontOrFamily].fontName;
                fontClasses = [fontOrFamily];
              } else {
                fontName = retrieveTextFontName3(fontOrFamily, options.fontWeight, options.fontShape);
                fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
              }
              if (lookupSymbol3(text2, fontName, mode).metrics) {
                return makeSymbol3(text2, fontName, mode, options, classes.concat(fontClasses));
              } else if (ligatures2.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
                const parts = [];
                for (let i = 0; i < text2.length; i++) {
                  parts.push(makeSymbol3(text2[i], fontName, mode, options, classes.concat(fontClasses)));
                }
                return makeFragment3(parts);
              }
            }
            if (type === "mathord") {
              return makeSymbol3(text2, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
            } else if (type === "textord") {
              const font = src_symbols[mode][text2] && src_symbols[mode][text2].font;
              if (font === "ams") {
                const fontName = retrieveTextFontName3("amsrm", options.fontWeight, options.fontShape);
                return makeSymbol3(text2, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
              } else if (font === "main" || !font) {
                const fontName = retrieveTextFontName3("textrm", options.fontWeight, options.fontShape);
                return makeSymbol3(text2, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
              } else {
                const fontName = retrieveTextFontName3(font, options.fontWeight, options.fontShape);
                return makeSymbol3(text2, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
              }
            } else {
              throw new Error("unexpected type: " + type + " in makeOrd");
            }
          };
          const canCombine2 = (prev, next) => {
            if (createClass3(prev.classes) !== createClass3(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
              return false;
            }
            if (prev.classes.length === 1) {
              const cls = prev.classes[0];
              if (cls === "mbin" || cls === "mord") {
                return false;
              }
            }
            for (const style in prev.style) {
              if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
                return false;
              }
            }
            for (const style in next.style) {
              if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
                return false;
              }
            }
            return true;
          };
          const tryCombineChars2 = (chars) => {
            for (let i = 0; i < chars.length - 1; i++) {
              const prev = chars[i];
              const next = chars[i + 1];
              if (prev instanceof SymbolNode2 && next instanceof SymbolNode2 && canCombine2(prev, next)) {
                prev.text += next.text;
                prev.height = Math.max(prev.height, next.height);
                prev.depth = Math.max(prev.depth, next.depth);
                prev.italic = next.italic;
                chars.splice(i + 1, 1);
                i--;
              }
            }
            return chars;
          };
          const sizeElementFromChildren3 = function(elem) {
            let height = 0;
            let depth = 0;
            let maxFontSize = 0;
            for (let i = 0; i < elem.children.length; i++) {
              const child = elem.children[i];
              if (child.height > height) {
                height = child.height;
              }
              if (child.depth > depth) {
                depth = child.depth;
              }
              if (child.maxFontSize > maxFontSize) {
                maxFontSize = child.maxFontSize;
              }
            }
            elem.height = height;
            elem.depth = depth;
            elem.maxFontSize = maxFontSize;
          };
          const makeSpan3 = function(classes, children, options, style) {
            const span = new Span2(classes, children, options, style);
            sizeElementFromChildren3(span);
            return span;
          };
          const makeSvgSpan2 = (classes, children, options, style) => new Span2(classes, children, options, style);
          const makeLineSpan3 = function(className, options, thickness) {
            const line = makeSpan3([className], [], options);
            line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
            line.style.borderBottomWidth = makeEm3(line.height);
            line.maxFontSize = 1;
            return line;
          };
          const makeAnchor3 = function(href, classes, children, options) {
            const anchor = new Anchor2(href, classes, children, options);
            sizeElementFromChildren3(anchor);
            return anchor;
          };
          const makeFragment3 = function(children) {
            const fragment = new DocumentFragment2(children);
            sizeElementFromChildren3(fragment);
            return fragment;
          };
          const wrapFragment3 = function(group, options) {
            if (group instanceof DocumentFragment2) {
              return makeSpan3([], [group], options);
            }
            return group;
          };
          const getVListChildrenAndDepth3 = function(params) {
            if (params.positionType === "individualShift") {
              const oldChildren = params.children;
              const children = [oldChildren[0]];
              const depth2 = -oldChildren[0].shift - oldChildren[0].elem.depth;
              let currPos = depth2;
              for (let i = 1; i < oldChildren.length; i++) {
                const diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
                const size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
                currPos = currPos + diff;
                children.push({
                  type: "kern",
                  size
                });
                children.push(oldChildren[i]);
              }
              return {
                children,
                depth: depth2
              };
            }
            let depth;
            if (params.positionType === "top") {
              let bottom = params.positionData;
              for (let i = 0; i < params.children.length; i++) {
                const child = params.children[i];
                bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
              }
              depth = bottom;
            } else if (params.positionType === "bottom") {
              depth = -params.positionData;
            } else {
              const firstChild = params.children[0];
              if (firstChild.type !== "elem") {
                throw new Error('First child must have type "elem".');
              }
              if (params.positionType === "shift") {
                depth = -firstChild.elem.depth - params.positionData;
              } else if (params.positionType === "firstBaseline") {
                depth = -firstChild.elem.depth;
              } else {
                throw new Error("Invalid positionType " + params.positionType + ".");
              }
            }
            return {
              children: params.children,
              depth
            };
          };
          const makeVList3 = function(params, options) {
            const {
              children,
              depth
            } = getVListChildrenAndDepth3(params);
            let pstrutSize = 0;
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.type === "elem") {
                const elem = child.elem;
                pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
              }
            }
            pstrutSize += 2;
            const pstrut = makeSpan3(["pstrut"], []);
            pstrut.style.height = makeEm3(pstrutSize);
            const realChildren = [];
            let minPos = depth;
            let maxPos = depth;
            let currPos = depth;
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.type === "kern") {
                currPos += child.size;
              } else {
                const elem = child.elem;
                const classes = child.wrapperClasses || [];
                const style = child.wrapperStyle || {};
                const childWrap = makeSpan3(classes, [pstrut, elem], void 0, style);
                childWrap.style.top = makeEm3(-pstrutSize - currPos - elem.depth);
                if (child.marginLeft) {
                  childWrap.style.marginLeft = child.marginLeft;
                }
                if (child.marginRight) {
                  childWrap.style.marginRight = child.marginRight;
                }
                realChildren.push(childWrap);
                currPos += elem.height + elem.depth;
              }
              minPos = Math.min(minPos, currPos);
              maxPos = Math.max(maxPos, currPos);
            }
            const vlist = makeSpan3(["vlist"], realChildren);
            vlist.style.height = makeEm3(maxPos);
            let rows;
            if (minPos < 0) {
              const emptySpan = makeSpan3([], []);
              const depthStrut = makeSpan3(["vlist"], [emptySpan]);
              depthStrut.style.height = makeEm3(-minPos);
              const topStrut = makeSpan3(["vlist-s"], [new SymbolNode2("")]);
              rows = [makeSpan3(["vlist-r"], [vlist, topStrut]), makeSpan3(["vlist-r"], [depthStrut])];
            } else {
              rows = [makeSpan3(["vlist-r"], [vlist])];
            }
            const vtable = makeSpan3(["vlist-t"], rows);
            if (rows.length === 2) {
              vtable.classes.push("vlist-t2");
            }
            vtable.height = maxPos;
            vtable.depth = -minPos;
            return vtable;
          };
          const makeGlue2 = (measurement, options) => {
            const rule = makeSpan3(["mspace"], [], options);
            const size = calculateSize3(measurement, options);
            rule.style.marginRight = makeEm3(size);
            return rule;
          };
          const retrieveTextFontName3 = function(fontFamily, fontWeight, fontShape) {
            let baseFontName = "";
            switch (fontFamily) {
              case "amsrm":
                baseFontName = "AMS";
                break;
              case "textrm":
                baseFontName = "Main";
                break;
              case "textsf":
                baseFontName = "SansSerif";
                break;
              case "texttt":
                baseFontName = "Typewriter";
                break;
              default:
                baseFontName = fontFamily;
            }
            let fontStylesName;
            if (fontWeight === "textbf" && fontShape === "textit") {
              fontStylesName = "BoldItalic";
            } else if (fontWeight === "textbf") {
              fontStylesName = "Bold";
            } else if (fontWeight === "textit") {
              fontStylesName = "Italic";
            } else {
              fontStylesName = "Regular";
            }
            return baseFontName + "-" + fontStylesName;
          };
          const fontMap2 = {
            // styles
            "mathbf": {
              variant: "bold",
              fontName: "Main-Bold"
            },
            "mathrm": {
              variant: "normal",
              fontName: "Main-Regular"
            },
            "textit": {
              variant: "italic",
              fontName: "Main-Italic"
            },
            "mathit": {
              variant: "italic",
              fontName: "Main-Italic"
            },
            "mathnormal": {
              variant: "italic",
              fontName: "Math-Italic"
            },
            "mathsfit": {
              variant: "sans-serif-italic",
              fontName: "SansSerif-Italic"
            },
            // "boldsymbol" is missing because they require the use of multiple fonts:
            // Math-BoldItalic and Main-Bold.  This is handled by a special case in
            // makeOrd which ends up calling boldsymbol.
            // families
            "mathbb": {
              variant: "double-struck",
              fontName: "AMS-Regular"
            },
            "mathcal": {
              variant: "script",
              fontName: "Caligraphic-Regular"
            },
            "mathfrak": {
              variant: "fraktur",
              fontName: "Fraktur-Regular"
            },
            "mathscr": {
              variant: "script",
              fontName: "Script-Regular"
            },
            "mathsf": {
              variant: "sans-serif",
              fontName: "SansSerif-Regular"
            },
            "mathtt": {
              variant: "monospace",
              fontName: "Typewriter-Regular"
            }
          };
          const svgData2 = {
            //   path, width, height
            vec: ["vec", 0.471, 0.714],
            // values from the font glyph
            oiintSize1: ["oiintSize1", 0.957, 0.499],
            // oval to overlay the integrand
            oiintSize2: ["oiintSize2", 1.472, 0.659],
            oiiintSize1: ["oiiintSize1", 1.304, 0.499],
            oiiintSize2: ["oiiintSize2", 1.98, 0.659]
          };
          const staticSvg3 = function(value, options) {
            const [pathName, width, height] = svgData2[value];
            const path3 = new PathNode2(pathName);
            const svgNode = new SvgNode2([path3], {
              "width": makeEm3(width),
              "height": makeEm3(height),
              // Override CSS rule `.katex svg { width: 100% }`
              "style": "width:" + makeEm3(width),
              "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
              "preserveAspectRatio": "xMinYMin"
            });
            const span = makeSvgSpan2(["overlay"], [svgNode], options);
            span.height = height;
            span.style.height = makeEm3(height);
            span.style.width = makeEm3(width);
            return span;
          };
          var buildCommon2 = {
            fontMap: fontMap2,
            makeSymbol: makeSymbol3,
            mathsym: mathsym3,
            makeSpan: makeSpan3,
            makeSvgSpan: makeSvgSpan2,
            makeLineSpan: makeLineSpan3,
            makeAnchor: makeAnchor3,
            makeFragment: makeFragment3,
            wrapFragment: wrapFragment3,
            makeVList: makeVList3,
            makeOrd: makeOrd3,
            makeGlue: makeGlue2,
            staticSvg: staticSvg3,
            svgData: svgData2,
            tryCombineChars: tryCombineChars2
          };
          const thinspace2 = {
            number: 3,
            unit: "mu"
          };
          const mediumspace2 = {
            number: 4,
            unit: "mu"
          };
          const thickspace2 = {
            number: 5,
            unit: "mu"
          };
          const spacings2 = {
            mord: {
              mop: thinspace2,
              mbin: mediumspace2,
              mrel: thickspace2,
              minner: thinspace2
            },
            mop: {
              mord: thinspace2,
              mop: thinspace2,
              mrel: thickspace2,
              minner: thinspace2
            },
            mbin: {
              mord: mediumspace2,
              mop: mediumspace2,
              mopen: mediumspace2,
              minner: mediumspace2
            },
            mrel: {
              mord: thickspace2,
              mop: thickspace2,
              mopen: thickspace2,
              minner: thickspace2
            },
            mopen: {},
            mclose: {
              mop: thinspace2,
              mbin: mediumspace2,
              mrel: thickspace2,
              minner: thinspace2
            },
            mpunct: {
              mord: thinspace2,
              mop: thinspace2,
              mrel: thickspace2,
              mopen: thinspace2,
              mclose: thinspace2,
              mpunct: thinspace2,
              minner: thinspace2
            },
            minner: {
              mord: thinspace2,
              mop: thinspace2,
              mbin: mediumspace2,
              mrel: thickspace2,
              mopen: thinspace2,
              mpunct: thinspace2,
              minner: thinspace2
            }
          };
          const tightSpacings2 = {
            mord: {
              mop: thinspace2
            },
            mop: {
              mord: thinspace2,
              mop: thinspace2
            },
            mbin: {},
            mrel: {},
            mopen: {},
            mclose: {
              mop: thinspace2
            },
            mpunct: {},
            minner: {
              mop: thinspace2
            }
          };
          const _functions2 = {};
          const _htmlGroupBuilders2 = {};
          const _mathmlGroupBuilders2 = {};
          function defineFunction2(_ref) {
            let {
              type,
              names,
              props,
              handler,
              htmlBuilder: htmlBuilder4,
              mathmlBuilder: mathmlBuilder4
            } = _ref;
            const data = {
              type,
              numArgs: props.numArgs,
              argTypes: props.argTypes,
              allowedInArgument: !!props.allowedInArgument,
              allowedInText: !!props.allowedInText,
              allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
              numOptionalArgs: props.numOptionalArgs || 0,
              infix: !!props.infix,
              primitive: !!props.primitive,
              handler
            };
            for (let i = 0; i < names.length; ++i) {
              _functions2[names[i]] = data;
            }
            if (type) {
              if (htmlBuilder4) {
                _htmlGroupBuilders2[type] = htmlBuilder4;
              }
              if (mathmlBuilder4) {
                _mathmlGroupBuilders2[type] = mathmlBuilder4;
              }
            }
          }
          function defineFunctionBuilders2(_ref2) {
            let {
              type,
              htmlBuilder: htmlBuilder4,
              mathmlBuilder: mathmlBuilder4
            } = _ref2;
            defineFunction2({
              type,
              names: [],
              props: {
                numArgs: 0
              },
              handler() {
                throw new Error("Should never be called.");
              },
              htmlBuilder: htmlBuilder4,
              mathmlBuilder: mathmlBuilder4
            });
          }
          const normalizeArgument3 = function(arg) {
            return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
          };
          const ordargument3 = function(arg) {
            return arg.type === "ordgroup" ? arg.body : [arg];
          };
          const buildHTML_makeSpan = buildCommon2.makeSpan;
          const binLeftCanceller2 = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
          const binRightCanceller2 = ["rightmost", "mrel", "mclose", "mpunct"];
          const styleMap2 = {
            "display": src_Style.DISPLAY,
            "text": src_Style.TEXT,
            "script": src_Style.SCRIPT,
            "scriptscript": src_Style.SCRIPTSCRIPT
          };
          const DomEnum2 = {
            mord: "mord",
            mop: "mop",
            mbin: "mbin",
            mrel: "mrel",
            mopen: "mopen",
            mclose: "mclose",
            mpunct: "mpunct",
            minner: "minner"
          };
          const buildExpression4 = function(expression, options, isRealGroup, surrounding) {
            if (surrounding === void 0) {
              surrounding = [null, null];
            }
            const groups = [];
            for (let i = 0; i < expression.length; i++) {
              const output = buildGroup4(expression[i], options);
              if (output instanceof DocumentFragment2) {
                const children = output.children;
                groups.push(...children);
              } else {
                groups.push(output);
              }
            }
            buildCommon2.tryCombineChars(groups);
            if (!isRealGroup) {
              return groups;
            }
            let glueOptions = options;
            if (expression.length === 1) {
              const node = expression[0];
              if (node.type === "sizing") {
                glueOptions = options.havingSize(node.size);
              } else if (node.type === "styling") {
                glueOptions = options.havingStyle(styleMap2[node.style]);
              }
            }
            const dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
            const dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
            const isRoot = isRealGroup === "root";
            traverseNonSpaceNodes3(groups, (node, prev) => {
              const prevType = prev.classes[0];
              const type = node.classes[0];
              if (prevType === "mbin" && binRightCanceller2.includes(type)) {
                prev.classes[0] = "mord";
              } else if (type === "mbin" && binLeftCanceller2.includes(prevType)) {
                node.classes[0] = "mord";
              }
            }, {
              node: dummyPrev
            }, dummyNext, isRoot);
            traverseNonSpaceNodes3(groups, (node, prev) => {
              const prevType = getTypeOfDomTree3(prev);
              const type = getTypeOfDomTree3(node);
              const space = prevType && type ? node.hasClass("mtight") ? tightSpacings2[prevType][type] : spacings2[prevType][type] : null;
              if (space) {
                return buildCommon2.makeGlue(space, glueOptions);
              }
            }, {
              node: dummyPrev
            }, dummyNext, isRoot);
            return groups;
          };
          const traverseNonSpaceNodes3 = function(nodes, callback, prev, next, isRoot) {
            if (next) {
              nodes.push(next);
            }
            let i = 0;
            for (; i < nodes.length; i++) {
              const node = nodes[i];
              const partialGroup = checkPartialGroup3(node);
              if (partialGroup) {
                traverseNonSpaceNodes3(partialGroup.children, callback, prev, null, isRoot);
                continue;
              }
              const nonspace = !node.hasClass("mspace");
              if (nonspace) {
                const result = callback(node, prev.node);
                if (result) {
                  if (prev.insertAfter) {
                    prev.insertAfter(result);
                  } else {
                    nodes.unshift(result);
                    i++;
                  }
                }
              }
              if (nonspace) {
                prev.node = node;
              } else if (isRoot && node.hasClass("newline")) {
                prev.node = buildHTML_makeSpan(["leftmost"]);
              }
              prev.insertAfter = /* @__PURE__ */ ((index) => (n) => {
                nodes.splice(index + 1, 0, n);
                i++;
              })(i);
            }
            if (next) {
              nodes.pop();
            }
          };
          const checkPartialGroup3 = function(node) {
            if (node instanceof DocumentFragment2 || node instanceof Anchor2 || node instanceof Span2 && node.hasClass("enclosing")) {
              return node;
            }
            return null;
          };
          const getOutermostNode3 = function(node, side) {
            const partialGroup = checkPartialGroup3(node);
            if (partialGroup) {
              const children = partialGroup.children;
              if (children.length) {
                if (side === "right") {
                  return getOutermostNode3(children[children.length - 1], "right");
                } else if (side === "left") {
                  return getOutermostNode3(children[0], "left");
                }
              }
            }
            return node;
          };
          const getTypeOfDomTree3 = function(node, side) {
            if (!node) {
              return null;
            }
            if (side) {
              node = getOutermostNode3(node, side);
            }
            return DomEnum2[node.classes[0]] || null;
          };
          const makeNullDelimiter3 = function(options, classes) {
            const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
            return buildHTML_makeSpan(classes.concat(moreClasses));
          };
          const buildGroup4 = function(group, options, baseOptions) {
            if (!group) {
              return buildHTML_makeSpan();
            }
            if (_htmlGroupBuilders2[group.type]) {
              let groupNode = _htmlGroupBuilders2[group.type](group, options);
              if (baseOptions && options.size !== baseOptions.size) {
                groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
                const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
                groupNode.height *= multiplier;
                groupNode.depth *= multiplier;
              }
              return groupNode;
            } else {
              throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
            }
          };
          function buildHTMLUnbreakable2(children, options) {
            const body = buildHTML_makeSpan(["base"], children, options);
            const strut = buildHTML_makeSpan(["strut"]);
            strut.style.height = makeEm3(body.height + body.depth);
            if (body.depth) {
              strut.style.verticalAlign = makeEm3(-body.depth);
            }
            body.children.unshift(strut);
            return body;
          }
          function buildHTML2(tree, options) {
            let tag = null;
            if (tree.length === 1 && tree[0].type === "tag") {
              tag = tree[0].tag;
              tree = tree[0].body;
            }
            const expression = buildExpression4(tree, options, "root");
            let eqnNum;
            if (expression.length === 2 && expression[1].hasClass("tag")) {
              eqnNum = expression.pop();
            }
            const children = [];
            let parts = [];
            for (let i = 0; i < expression.length; i++) {
              parts.push(expression[i]);
              if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
                let nobreak = false;
                while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                  i++;
                  parts.push(expression[i]);
                  if (expression[i].hasClass("nobreak")) {
                    nobreak = true;
                  }
                }
                if (!nobreak) {
                  children.push(buildHTMLUnbreakable2(parts, options));
                  parts = [];
                }
              } else if (expression[i].hasClass("newline")) {
                parts.pop();
                if (parts.length > 0) {
                  children.push(buildHTMLUnbreakable2(parts, options));
                  parts = [];
                }
                children.push(expression[i]);
              }
            }
            if (parts.length > 0) {
              children.push(buildHTMLUnbreakable2(parts, options));
            }
            let tagChild;
            if (tag) {
              tagChild = buildHTMLUnbreakable2(buildExpression4(tag, options, true));
              tagChild.classes = ["tag"];
              children.push(tagChild);
            } else if (eqnNum) {
              children.push(eqnNum);
            }
            const htmlNode = buildHTML_makeSpan(["katex-html"], children);
            htmlNode.setAttribute("aria-hidden", "true");
            if (tagChild) {
              const strut = tagChild.children[0];
              strut.style.height = makeEm3(htmlNode.height + htmlNode.depth);
              if (htmlNode.depth) {
                strut.style.verticalAlign = makeEm3(-htmlNode.depth);
              }
            }
            return htmlNode;
          }
          function newDocumentFragment2(children) {
            return new DocumentFragment2(children);
          }
          class MathNode2 {
            constructor(type, children, classes) {
              this.type = void 0;
              this.attributes = void 0;
              this.children = void 0;
              this.classes = void 0;
              this.type = type;
              this.attributes = {};
              this.children = children || [];
              this.classes = classes || [];
            }
            /**
             * Sets an attribute on a MathML node. MathML depends on attributes to convey a
             * semantic content, so this is used heavily.
             */
            setAttribute(name, value) {
              this.attributes[name] = value;
            }
            /**
             * Gets an attribute on a MathML node.
             */
            getAttribute(name) {
              return this.attributes[name];
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  node.setAttribute(attr, this.attributes[attr]);
                }
              }
              if (this.classes.length > 0) {
                node.className = createClass3(this.classes);
              }
              for (let i = 0; i < this.children.length; i++) {
                if (this.children[i] instanceof TextNode2 && this.children[i + 1] instanceof TextNode2) {
                  let text2 = this.children[i].toText() + this.children[++i].toText();
                  while (this.children[i + 1] instanceof TextNode2) {
                    text2 += this.children[++i].toText();
                  }
                  node.appendChild(new TextNode2(text2).toNode());
                } else {
                  node.appendChild(this.children[i].toNode());
                }
              }
              return node;
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              let markup = "<" + this.type;
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  markup += " " + attr + '="';
                  markup += utils2.escape(this.attributes[attr]);
                  markup += '"';
                }
              }
              if (this.classes.length > 0) {
                markup += ' class ="' + utils2.escape(createClass3(this.classes)) + '"';
              }
              markup += ">";
              for (let i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              markup += "</" + this.type + ">";
              return markup;
            }
            /**
             * Converts the math node into a string, similar to innerText, but escaped.
             */
            toText() {
              return this.children.map((child) => child.toText()).join("");
            }
          }
          class TextNode2 {
            constructor(text2) {
              this.text = void 0;
              this.text = text2;
            }
            /**
             * Converts the text node into a DOM text node.
             */
            toNode() {
              return document.createTextNode(this.text);
            }
            /**
             * Converts the text node into escaped HTML markup
             * (representing the text itself).
             */
            toMarkup() {
              return utils2.escape(this.toText());
            }
            /**
             * Converts the text node into a string
             * (representing the text itself).
             */
            toText() {
              return this.text;
            }
          }
          class SpaceNode2 {
            /**
             * Create a Space node with width given in CSS ems.
             */
            constructor(width) {
              this.width = void 0;
              this.character = void 0;
              this.width = width;
              if (width >= 0.05555 && width <= 0.05556) {
                this.character = "";
              } else if (width >= 0.1666 && width <= 0.1667) {
                this.character = "";
              } else if (width >= 0.2222 && width <= 0.2223) {
                this.character = "";
              } else if (width >= 0.2777 && width <= 0.2778) {
                this.character = "";
              } else if (width >= -0.05556 && width <= -0.05555) {
                this.character = "";
              } else if (width >= -0.1667 && width <= -0.1666) {
                this.character = "";
              } else if (width >= -0.2223 && width <= -0.2222) {
                this.character = "";
              } else if (width >= -0.2778 && width <= -0.2777) {
                this.character = "";
              } else {
                this.character = null;
              }
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              if (this.character) {
                return document.createTextNode(this.character);
              } else {
                const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                node.setAttribute("width", makeEm3(this.width));
                return node;
              }
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              if (this.character) {
                return "<mtext>" + this.character + "</mtext>";
              } else {
                return '<mspace width="' + makeEm3(this.width) + '"/>';
              }
            }
            /**
             * Converts the math node into a string, similar to innerText.
             */
            toText() {
              if (this.character) {
                return this.character;
              } else {
                return " ";
              }
            }
          }
          var mathMLTree2 = {
            MathNode: MathNode2,
            TextNode: TextNode2,
            SpaceNode: SpaceNode2,
            newDocumentFragment: newDocumentFragment2
          };
          const makeText3 = function(text2, mode, options) {
            if (src_symbols[mode][text2] && src_symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures2.hasOwnProperty(text2) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
              text2 = src_symbols[mode][text2].replace;
            }
            return new mathMLTree2.TextNode(text2);
          };
          const makeRow3 = function(body) {
            if (body.length === 1) {
              return body[0];
            } else {
              return new mathMLTree2.MathNode("mrow", body);
            }
          };
          const getVariant3 = function(group, options) {
            if (options.fontFamily === "texttt") {
              return "monospace";
            } else if (options.fontFamily === "textsf") {
              if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                return "sans-serif-bold-italic";
              } else if (options.fontShape === "textit") {
                return "sans-serif-italic";
              } else if (options.fontWeight === "textbf") {
                return "bold-sans-serif";
              } else {
                return "sans-serif";
              }
            } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
              return "bold-italic";
            } else if (options.fontShape === "textit") {
              return "italic";
            } else if (options.fontWeight === "textbf") {
              return "bold";
            }
            const font = options.font;
            if (!font || font === "mathnormal") {
              return null;
            }
            const mode = group.mode;
            if (font === "mathit") {
              return "italic";
            } else if (font === "boldsymbol") {
              return group.type === "textord" ? "bold" : "bold-italic";
            } else if (font === "mathbf") {
              return "bold";
            } else if (font === "mathbb") {
              return "double-struck";
            } else if (font === "mathsfit") {
              return "sans-serif-italic";
            } else if (font === "mathfrak") {
              return "fraktur";
            } else if (font === "mathscr" || font === "mathcal") {
              return "script";
            } else if (font === "mathsf") {
              return "sans-serif";
            } else if (font === "mathtt") {
              return "monospace";
            }
            let text2 = group.text;
            if (["\\imath", "\\jmath"].includes(text2)) {
              return null;
            }
            if (src_symbols[mode][text2] && src_symbols[mode][text2].replace) {
              text2 = src_symbols[mode][text2].replace;
            }
            const fontName = buildCommon2.fontMap[font].fontName;
            if (getCharacterMetrics2(text2, fontName, mode)) {
              return buildCommon2.fontMap[font].variant;
            }
            return null;
          };
          function isNumberPunctuation2(group) {
            if (!group) {
              return false;
            }
            if (group.type === "mi" && group.children.length === 1) {
              const child = group.children[0];
              return child instanceof TextNode2 && child.text === ".";
            } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
              const child = group.children[0];
              return child instanceof TextNode2 && child.text === ",";
            } else {
              return false;
            }
          }
          const buildMathML_buildExpression = function(expression, options, isOrdgroup) {
            if (expression.length === 1) {
              const group = buildMathML_buildGroup(expression[0], options);
              if (isOrdgroup && group instanceof MathNode2 && group.type === "mo") {
                group.setAttribute("lspace", "0em");
                group.setAttribute("rspace", "0em");
              }
              return [group];
            }
            const groups = [];
            let lastGroup;
            for (let i = 0; i < expression.length; i++) {
              const group = buildMathML_buildGroup(expression[i], options);
              if (group instanceof MathNode2 && lastGroup instanceof MathNode2) {
                if (group.type === "mtext" && lastGroup.type === "mtext" && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                  lastGroup.children.push(...group.children);
                  continue;
                } else if (group.type === "mn" && lastGroup.type === "mn") {
                  lastGroup.children.push(...group.children);
                  continue;
                } else if (isNumberPunctuation2(group) && lastGroup.type === "mn") {
                  lastGroup.children.push(...group.children);
                  continue;
                } else if (group.type === "mn" && isNumberPunctuation2(lastGroup)) {
                  group.children = [...lastGroup.children, ...group.children];
                  groups.pop();
                } else if ((group.type === "msup" || group.type === "msub") && group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation2(lastGroup))) {
                  const base2 = group.children[0];
                  if (base2 instanceof MathNode2 && base2.type === "mn") {
                    base2.children = [...lastGroup.children, ...base2.children];
                    groups.pop();
                  }
                } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                  const lastChild = lastGroup.children[0];
                  if (lastChild instanceof TextNode2 && lastChild.text === "" && (group.type === "mo" || group.type === "mi" || group.type === "mn")) {
                    const child = group.children[0];
                    if (child instanceof TextNode2 && child.text.length > 0) {
                      child.text = child.text.slice(0, 1) + "" + child.text.slice(1);
                      groups.pop();
                    }
                  }
                }
              }
              groups.push(group);
              lastGroup = group;
            }
            return groups;
          };
          const buildExpressionRow3 = function(expression, options, isOrdgroup) {
            return makeRow3(buildMathML_buildExpression(expression, options, isOrdgroup));
          };
          const buildMathML_buildGroup = function(group, options) {
            if (!group) {
              return new mathMLTree2.MathNode("mrow");
            }
            if (_mathmlGroupBuilders2[group.type]) {
              const result = _mathmlGroupBuilders2[group.type](group, options);
              return result;
            } else {
              throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
            }
          };
          function buildMathML2(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
            const expression = buildMathML_buildExpression(tree, options);
            let wrapper;
            if (expression.length === 1 && expression[0] instanceof MathNode2 && ["mrow", "mtable"].includes(expression[0].type)) {
              wrapper = expression[0];
            } else {
              wrapper = new mathMLTree2.MathNode("mrow", expression);
            }
            const annotation = new mathMLTree2.MathNode("annotation", [new mathMLTree2.TextNode(texExpression)]);
            annotation.setAttribute("encoding", "application/x-tex");
            const semantics = new mathMLTree2.MathNode("semantics", [wrapper, annotation]);
            const math3 = new mathMLTree2.MathNode("math", [semantics]);
            math3.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
            if (isDisplayMode) {
              math3.setAttribute("display", "block");
            }
            const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
            return buildCommon2.makeSpan([wrapperClass], [math3]);
          }
          const optionsFromSettings3 = function(settings) {
            return new src_Options({
              style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
              maxSize: settings.maxSize,
              minRuleThickness: settings.minRuleThickness
            });
          };
          const displayWrap3 = function(node, settings) {
            if (settings.displayMode) {
              const classes = ["katex-display"];
              if (settings.leqno) {
                classes.push("leqno");
              }
              if (settings.fleqn) {
                classes.push("fleqn");
              }
              node = buildCommon2.makeSpan(classes, [node]);
            }
            return node;
          };
          const buildTree3 = function(tree, expression, settings) {
            const options = optionsFromSettings3(settings);
            let katexNode;
            if (settings.output === "mathml") {
              return buildMathML2(tree, expression, options, settings.displayMode, true);
            } else if (settings.output === "html") {
              const htmlNode = buildHTML2(tree, options);
              katexNode = buildCommon2.makeSpan(["katex"], [htmlNode]);
            } else {
              const mathMLNode = buildMathML2(tree, expression, options, settings.displayMode, false);
              const htmlNode = buildHTML2(tree, options);
              katexNode = buildCommon2.makeSpan(["katex"], [mathMLNode, htmlNode]);
            }
            return displayWrap3(katexNode, settings);
          };
          const buildHTMLTree3 = function(tree, expression, settings) {
            const options = optionsFromSettings3(settings);
            const htmlNode = buildHTML2(tree, options);
            const katexNode = buildCommon2.makeSpan(["katex"], [htmlNode]);
            return displayWrap3(katexNode, settings);
          };
          const stretchyCodePoint2 = {
            widehat: "^",
            widecheck: "",
            widetilde: "~",
            utilde: "~",
            overleftarrow: "",
            underleftarrow: "",
            xleftarrow: "",
            overrightarrow: "",
            underrightarrow: "",
            xrightarrow: "",
            underbrace: "",
            overbrace: "",
            overgroup: "",
            undergroup: "",
            overleftrightarrow: "",
            underleftrightarrow: "",
            xleftrightarrow: "",
            Overrightarrow: "",
            xRightarrow: "",
            overleftharpoon: "",
            xleftharpoonup: "",
            overrightharpoon: "",
            xrightharpoonup: "",
            xLeftarrow: "",
            xLeftrightarrow: "",
            xhookleftarrow: "",
            xhookrightarrow: "",
            xmapsto: "",
            xrightharpoondown: "",
            xleftharpoondown: "",
            xrightleftharpoons: "",
            xleftrightharpoons: "",
            xtwoheadleftarrow: "",
            xtwoheadrightarrow: "",
            xlongequal: "=",
            xtofrom: "",
            xrightleftarrows: "",
            xrightequilibrium: "",
            // Not a perfect match.
            xleftequilibrium: "",
            // None better available.
            "\\cdrightarrow": "",
            "\\cdleftarrow": "",
            "\\cdlongequal": "="
          };
          const mathMLnode3 = function(label) {
            const node = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode(stretchyCodePoint2[label.replace(/^\\/, "")])]);
            node.setAttribute("stretchy", "true");
            return node;
          };
          const katexImagesData2 = {
            //   path(s), minWidth, height, align
            overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
            "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
            // CD minwwidth2.5pc
            xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
            "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
            Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
            xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
            xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
            overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
            overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
            xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
            "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
            xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
            xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
            overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
            underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
            underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
            xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
            xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
            xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
            xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
            xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
            overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
            undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
            xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
            xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
            // The next three arrows are from the mhchem package.
            // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
            // document as \xrightarrow or \xrightleftharpoons. Those have
            // min-length = 1.75em, so we set min-length on these next three to match.
            xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
            xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
            xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
          };
          const groupLength3 = function(arg) {
            if (arg.type === "ordgroup") {
              return arg.body.length;
            } else {
              return 1;
            }
          };
          const svgSpan3 = function(group, options) {
            function buildSvgSpan_() {
              let viewBoxWidth = 4e5;
              const label = group.label.slice(1);
              if (["widehat", "widecheck", "widetilde", "utilde"].includes(label)) {
                const grp = group;
                const numChars = groupLength3(grp.base);
                let viewBoxHeight;
                let pathName;
                let height2;
                if (numChars > 5) {
                  if (label === "widehat" || label === "widecheck") {
                    viewBoxHeight = 420;
                    viewBoxWidth = 2364;
                    height2 = 0.42;
                    pathName = label + "4";
                  } else {
                    viewBoxHeight = 312;
                    viewBoxWidth = 2340;
                    height2 = 0.34;
                    pathName = "tilde4";
                  }
                } else {
                  const imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                  if (label === "widehat" || label === "widecheck") {
                    viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                    viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                    height2 = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                    pathName = label + imgIndex;
                  } else {
                    viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                    viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                    height2 = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                    pathName = "tilde" + imgIndex;
                  }
                }
                const path3 = new PathNode2(pathName);
                const svgNode = new SvgNode2([path3], {
                  "width": "100%",
                  "height": makeEm3(height2),
                  "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                  "preserveAspectRatio": "none"
                });
                return {
                  span: buildCommon2.makeSvgSpan([], [svgNode], options),
                  minWidth: 0,
                  height: height2
                };
              } else {
                const spans = [];
                const data = katexImagesData2[label];
                const [paths, minWidth2, viewBoxHeight] = data;
                const height2 = viewBoxHeight / 1e3;
                const numSvgChildren = paths.length;
                let widthClasses;
                let aligns;
                if (numSvgChildren === 1) {
                  const align1 = data[3];
                  widthClasses = ["hide-tail"];
                  aligns = [align1];
                } else if (numSvgChildren === 2) {
                  widthClasses = ["halfarrow-left", "halfarrow-right"];
                  aligns = ["xMinYMin", "xMaxYMin"];
                } else if (numSvgChildren === 3) {
                  widthClasses = ["brace-left", "brace-center", "brace-right"];
                  aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                } else {
                  throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
                }
                for (let i = 0; i < numSvgChildren; i++) {
                  const path3 = new PathNode2(paths[i]);
                  const svgNode = new SvgNode2([path3], {
                    "width": "400em",
                    "height": makeEm3(height2),
                    "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                    "preserveAspectRatio": aligns[i] + " slice"
                  });
                  const span2 = buildCommon2.makeSvgSpan([widthClasses[i]], [svgNode], options);
                  if (numSvgChildren === 1) {
                    return {
                      span: span2,
                      minWidth: minWidth2,
                      height: height2
                    };
                  } else {
                    span2.style.height = makeEm3(height2);
                    spans.push(span2);
                  }
                }
                return {
                  span: buildCommon2.makeSpan(["stretchy"], spans, options),
                  minWidth: minWidth2,
                  height: height2
                };
              }
            }
            const {
              span,
              minWidth,
              height
            } = buildSvgSpan_();
            span.height = height;
            span.style.height = makeEm3(height);
            if (minWidth > 0) {
              span.style.minWidth = makeEm3(minWidth);
            }
            return span;
          };
          const encloseSpan3 = function(inner3, label, topPad, bottomPad, options) {
            let img;
            const totalHeight = inner3.height + inner3.depth + topPad + bottomPad;
            if (/fbox|color|angl/.test(label)) {
              img = buildCommon2.makeSpan(["stretchy", label], [], options);
              if (label === "fbox") {
                const color2 = options.color && options.getColor();
                if (color2) {
                  img.style.borderColor = color2;
                }
              }
            } else {
              const lines = [];
              if (/^[bx]cancel$/.test(label)) {
                lines.push(new LineNode2({
                  "x1": "0",
                  "y1": "0",
                  "x2": "100%",
                  "y2": "100%",
                  "stroke-width": "0.046em"
                }));
              }
              if (/^x?cancel$/.test(label)) {
                lines.push(new LineNode2({
                  "x1": "0",
                  "y1": "100%",
                  "x2": "100%",
                  "y2": "0",
                  "stroke-width": "0.046em"
                }));
              }
              const svgNode = new SvgNode2(lines, {
                "width": "100%",
                "height": makeEm3(totalHeight)
              });
              img = buildCommon2.makeSvgSpan([], [svgNode], options);
            }
            img.height = totalHeight;
            img.style.height = makeEm3(totalHeight);
            return img;
          };
          var stretchy2 = {
            encloseSpan: encloseSpan3,
            mathMLnode: mathMLnode3,
            svgSpan: svgSpan3
          };
          function assertNodeType2(node, type) {
            if (!node || node.type !== type) {
              throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
            }
            return node;
          }
          function assertSymbolNodeType2(node) {
            const typedNode = checkSymbolNodeType2(node);
            if (!typedNode) {
              throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
            }
            return typedNode;
          }
          function checkSymbolNodeType2(node) {
            if (node && (node.type === "atom" || NON_ATOMS2.hasOwnProperty(node.type))) {
              return node;
            }
            return null;
          }
          const htmlBuilder3 = (grp, options) => {
            let base2;
            let group;
            let supSubGroup;
            if (grp && grp.type === "supsub") {
              group = assertNodeType2(grp.base, "accent");
              base2 = group.base;
              grp.base = base2;
              supSubGroup = assertSpan2(buildGroup4(grp, options));
              grp.base = group;
            } else {
              group = assertNodeType2(grp, "accent");
              base2 = group.base;
            }
            const body = buildGroup4(base2, options.havingCrampedStyle());
            const mustShift = group.isShifty && utils2.isCharacterBox(base2);
            let skew2 = 0;
            if (mustShift) {
              const baseChar = utils2.getBaseElem(base2);
              const baseGroup = buildGroup4(baseChar, options.havingCrampedStyle());
              skew2 = assertSymbolDomNode2(baseGroup).skew;
            }
            const accentBelow = group.label === "\\c";
            let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
            let accentBody;
            if (!group.isStretchy) {
              let accent3;
              let width;
              if (group.label === "\\vec") {
                accent3 = buildCommon2.staticSvg("vec", options);
                width = buildCommon2.svgData.vec[1];
              } else {
                accent3 = buildCommon2.makeOrd({
                  mode: group.mode,
                  text: group.label
                }, options, "textord");
                accent3 = assertSymbolDomNode2(accent3);
                accent3.italic = 0;
                width = accent3.width;
                if (accentBelow) {
                  clearance += accent3.depth;
                }
              }
              accentBody = buildCommon2.makeSpan(["accent-body"], [accent3]);
              const accentFull = group.label === "\\textcircled";
              if (accentFull) {
                accentBody.classes.push("accent-full");
                clearance = body.height;
              }
              let left = skew2;
              if (!accentFull) {
                left -= width / 2;
              }
              accentBody.style.left = makeEm3(left);
              if (group.label === "\\textcircled") {
                accentBody.style.top = ".2em";
              }
              accentBody = buildCommon2.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "kern",
                  size: -clearance
                }, {
                  type: "elem",
                  elem: accentBody
                }]
              }, options);
            } else {
              accentBody = stretchy2.svgSpan(group, options);
              accentBody = buildCommon2.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "elem",
                  elem: accentBody,
                  wrapperClasses: ["svg-align"],
                  wrapperStyle: skew2 > 0 ? {
                    width: "calc(100% - " + makeEm3(2 * skew2) + ")",
                    marginLeft: makeEm3(2 * skew2)
                  } : void 0
                }]
              }, options);
            }
            const accentWrap = buildCommon2.makeSpan(["mord", "accent"], [accentBody], options);
            if (supSubGroup) {
              supSubGroup.children[0] = accentWrap;
              supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
              supSubGroup.classes[0] = "mord";
              return supSubGroup;
            } else {
              return accentWrap;
            }
          };
          const mathmlBuilder3 = (group, options) => {
            const accentNode = group.isStretchy ? stretchy2.mathMLnode(group.label) : new mathMLTree2.MathNode("mo", [makeText3(group.label, group.mode)]);
            const node = new mathMLTree2.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
            node.setAttribute("accent", "true");
            return node;
          };
          const NON_STRETCHY_ACCENT_REGEX2 = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent3) => "\\" + accent3).join("|"));
          defineFunction2({
            type: "accent",
            names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
            props: {
              numArgs: 1
            },
            handler: (context, args) => {
              const base2 = normalizeArgument3(args[0]);
              const isStretchy = !NON_STRETCHY_ACCENT_REGEX2.test(context.funcName);
              const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
              return {
                type: "accent",
                mode: context.parser.mode,
                label: context.funcName,
                isStretchy,
                isShifty,
                base: base2
              };
            },
            htmlBuilder: htmlBuilder3,
            mathmlBuilder: mathmlBuilder3
          });
          defineFunction2({
            type: "accent",
            names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
            props: {
              numArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              // unless in strict mode
              argTypes: ["primitive"]
            },
            handler: (context, args) => {
              const base2 = args[0];
              let mode = context.parser.mode;
              if (mode === "math") {
                context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
                mode = "text";
              }
              return {
                type: "accent",
                mode,
                label: context.funcName,
                isStretchy: false,
                isShifty: true,
                base: base2
              };
            },
            htmlBuilder: htmlBuilder3,
            mathmlBuilder: mathmlBuilder3
          });
          defineFunction2({
            type: "accentUnder",
            names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
            props: {
              numArgs: 1
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const base2 = args[0];
              return {
                type: "accentUnder",
                mode: parser.mode,
                label: funcName,
                base: base2
              };
            },
            htmlBuilder: (group, options) => {
              const innerGroup = buildGroup4(group.base, options);
              const accentBody = stretchy2.svgSpan(group, options);
              const kern = group.label === "\\utilde" ? 0.12 : 0;
              const vlist = buildCommon2.makeVList({
                positionType: "top",
                positionData: innerGroup.height,
                children: [{
                  type: "elem",
                  elem: accentBody,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: kern
                }, {
                  type: "elem",
                  elem: innerGroup
                }]
              }, options);
              return buildCommon2.makeSpan(["mord", "accentunder"], [vlist], options);
            },
            mathmlBuilder: (group, options) => {
              const accentNode = stretchy2.mathMLnode(group.label);
              const node = new mathMLTree2.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
              node.setAttribute("accentunder", "true");
              return node;
            }
          });
          const paddedNode2 = (group) => {
            const node = new mathMLTree2.MathNode("mpadded", group ? [group] : []);
            node.setAttribute("width", "+0.6em");
            node.setAttribute("lspace", "0.3em");
            return node;
          };
          defineFunction2({
            type: "xArrow",
            names: [
              "\\xleftarrow",
              "\\xrightarrow",
              "\\xLeftarrow",
              "\\xRightarrow",
              "\\xleftrightarrow",
              "\\xLeftrightarrow",
              "\\xhookleftarrow",
              "\\xhookrightarrow",
              "\\xmapsto",
              "\\xrightharpoondown",
              "\\xrightharpoonup",
              "\\xleftharpoondown",
              "\\xleftharpoonup",
              "\\xrightleftharpoons",
              "\\xleftrightharpoons",
              "\\xlongequal",
              "\\xtwoheadrightarrow",
              "\\xtwoheadleftarrow",
              "\\xtofrom",
              // The next 3 functions are here to support the mhchem extension.
              // Direct use of these functions is discouraged and may break someday.
              "\\xrightleftarrows",
              "\\xrightequilibrium",
              "\\xleftequilibrium",
              // The next 3 functions are here only to support the {CD} environment.
              "\\\\cdrightarrow",
              "\\\\cdleftarrow",
              "\\\\cdlongequal"
            ],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(_ref, args, optArgs) {
              let {
                parser,
                funcName
              } = _ref;
              return {
                type: "xArrow",
                mode: parser.mode,
                label: funcName,
                body: args[0],
                below: optArgs[0]
              };
            },
            // Flow is unable to correctly infer the type of `group`, even though it's
            // unambiguously determined from the passed-in `type` above.
            htmlBuilder(group, options) {
              const style = options.style;
              let newOptions = options.havingStyle(style.sup());
              const upperGroup = buildCommon2.wrapFragment(buildGroup4(group.body, newOptions, options), options);
              const arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
              upperGroup.classes.push(arrowPrefix + "-arrow-pad");
              let lowerGroup;
              if (group.below) {
                newOptions = options.havingStyle(style.sub());
                lowerGroup = buildCommon2.wrapFragment(buildGroup4(group.below, newOptions, options), options);
                lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
              }
              const arrowBody = stretchy2.svgSpan(group, options);
              const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
              let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
              if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
                upperShift -= upperGroup.depth;
              }
              let vlist;
              if (lowerGroup) {
                const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
                vlist = buildCommon2.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: upperGroup,
                    shift: upperShift
                  }, {
                    type: "elem",
                    elem: arrowBody,
                    shift: arrowShift
                  }, {
                    type: "elem",
                    elem: lowerGroup,
                    shift: lowerShift
                  }]
                }, options);
              } else {
                vlist = buildCommon2.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: upperGroup,
                    shift: upperShift
                  }, {
                    type: "elem",
                    elem: arrowBody,
                    shift: arrowShift
                  }]
                }, options);
              }
              vlist.children[0].children[0].children[1].classes.push("svg-align");
              return buildCommon2.makeSpan(["mrel", "x-arrow"], [vlist], options);
            },
            mathmlBuilder(group, options) {
              const arrowNode = stretchy2.mathMLnode(group.label);
              arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
              let node;
              if (group.body) {
                const upperNode = paddedNode2(buildMathML_buildGroup(group.body, options));
                if (group.below) {
                  const lowerNode = paddedNode2(buildMathML_buildGroup(group.below, options));
                  node = new mathMLTree2.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
                } else {
                  node = new mathMLTree2.MathNode("mover", [arrowNode, upperNode]);
                }
              } else if (group.below) {
                const lowerNode = paddedNode2(buildMathML_buildGroup(group.below, options));
                node = new mathMLTree2.MathNode("munder", [arrowNode, lowerNode]);
              } else {
                node = paddedNode2();
                node = new mathMLTree2.MathNode("mover", [arrowNode, node]);
              }
              return node;
            }
          });
          const mclass_makeSpan = buildCommon2.makeSpan;
          function mclass_htmlBuilder(group, options) {
            const elements = buildExpression4(group.body, options, true);
            return mclass_makeSpan([group.mclass], elements, options);
          }
          function mclass_mathmlBuilder(group, options) {
            let node;
            const inner3 = buildMathML_buildExpression(group.body, options);
            if (group.mclass === "minner") {
              node = new mathMLTree2.MathNode("mpadded", inner3);
            } else if (group.mclass === "mord") {
              if (group.isCharacterBox) {
                node = inner3[0];
                node.type = "mi";
              } else {
                node = new mathMLTree2.MathNode("mi", inner3);
              }
            } else {
              if (group.isCharacterBox) {
                node = inner3[0];
                node.type = "mo";
              } else {
                node = new mathMLTree2.MathNode("mo", inner3);
              }
              if (group.mclass === "mbin") {
                node.attributes.lspace = "0.22em";
                node.attributes.rspace = "0.22em";
              } else if (group.mclass === "mpunct") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0.17em";
              } else if (group.mclass === "mopen" || group.mclass === "mclose") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0em";
              } else if (group.mclass === "minner") {
                node.attributes.lspace = "0.0556em";
                node.attributes.width = "+0.1111em";
              }
            }
            return node;
          }
          defineFunction2({
            type: "mclass",
            names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: "m" + funcName.slice(5),
                // TODO(kevinb): don't prefix with 'm'
                body: ordargument3(body),
                isCharacterBox: utils2.isCharacterBox(body)
              };
            },
            htmlBuilder: mclass_htmlBuilder,
            mathmlBuilder: mclass_mathmlBuilder
          });
          const binrelClass2 = (arg) => {
            const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
            if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
              return "m" + atom.family;
            } else {
              return "mord";
            }
          };
          defineFunction2({
            type: "mclass",
            names: ["\\@binrel"],
            props: {
              numArgs: 2
            },
            handler(_ref2, args) {
              let {
                parser
              } = _ref2;
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: binrelClass2(args[0]),
                body: ordargument3(args[1]),
                isCharacterBox: utils2.isCharacterBox(args[1])
              };
            }
          });
          defineFunction2({
            type: "mclass",
            names: ["\\stackrel", "\\overset", "\\underset"],
            props: {
              numArgs: 2
            },
            handler(_ref3, args) {
              let {
                parser,
                funcName
              } = _ref3;
              const baseArg = args[1];
              const shiftedArg = args[0];
              let mclass;
              if (funcName !== "\\stackrel") {
                mclass = binrelClass2(baseArg);
              } else {
                mclass = "mrel";
              }
              const baseOp = {
                type: "op",
                mode: baseArg.mode,
                limits: true,
                alwaysHandleSupSub: true,
                parentIsSupSub: false,
                symbol: false,
                suppressBaseShift: funcName !== "\\stackrel",
                body: ordargument3(baseArg)
              };
              const supsub = {
                type: "supsub",
                mode: shiftedArg.mode,
                base: baseOp,
                sup: funcName === "\\underset" ? null : shiftedArg,
                sub: funcName === "\\underset" ? shiftedArg : null
              };
              return {
                type: "mclass",
                mode: parser.mode,
                mclass,
                body: [supsub],
                isCharacterBox: utils2.isCharacterBox(supsub)
              };
            },
            htmlBuilder: mclass_htmlBuilder,
            mathmlBuilder: mclass_mathmlBuilder
          });
          defineFunction2({
            type: "pmb",
            names: ["\\pmb"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "pmb",
                mode: parser.mode,
                mclass: binrelClass2(args[0]),
                body: ordargument3(args[0])
              };
            },
            htmlBuilder(group, options) {
              const elements = buildExpression4(group.body, options, true);
              const node = buildCommon2.makeSpan([group.mclass], elements, options);
              node.style.textShadow = "0.02em 0.01em 0.04px";
              return node;
            },
            mathmlBuilder(group, style) {
              const inner3 = buildMathML_buildExpression(group.body, style);
              const node = new mathMLTree2.MathNode("mstyle", inner3);
              node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
              return node;
            }
          });
          const cdArrowFunctionName2 = {
            ">": "\\\\cdrightarrow",
            "<": "\\\\cdleftarrow",
            "=": "\\\\cdlongequal",
            "A": "\\uparrow",
            "V": "\\downarrow",
            "|": "\\Vert",
            ".": "no arrow"
          };
          const newCell2 = () => {
            return {
              type: "styling",
              body: [],
              mode: "math",
              style: "display"
            };
          };
          const isStartOfArrow2 = (node) => {
            return node.type === "textord" && node.text === "@";
          };
          const isLabelEnd2 = (node, endChar) => {
            return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
          };
          function cdArrow2(arrowChar, labels, parser) {
            const funcName = cdArrowFunctionName2[arrowChar];
            switch (funcName) {
              case "\\\\cdrightarrow":
              case "\\\\cdleftarrow":
                return parser.callFunction(funcName, [labels[0]], [labels[1]]);
              case "\\uparrow":
              case "\\downarrow": {
                const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
                const bareArrow = {
                  type: "atom",
                  text: funcName,
                  mode: "math",
                  family: "rel"
                };
                const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
                const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
                const arrowGroup = {
                  type: "ordgroup",
                  mode: "math",
                  body: [leftLabel, sizedArrow, rightLabel]
                };
                return parser.callFunction("\\\\cdparent", [arrowGroup], []);
              }
              case "\\\\cdlongequal":
                return parser.callFunction("\\\\cdlongequal", [], []);
              case "\\Vert": {
                const arrow = {
                  type: "textord",
                  text: "\\Vert",
                  mode: "math"
                };
                return parser.callFunction("\\Big", [arrow], []);
              }
              default:
                return {
                  type: "textord",
                  text: " ",
                  mode: "math"
                };
            }
          }
          function parseCD2(parser) {
            const parsedRows = [];
            parser.gullet.beginGroup();
            parser.gullet.macros.set("\\cr", "\\\\\\relax");
            parser.gullet.beginGroup();
            while (true) {
              parsedRows.push(parser.parseExpression(false, "\\\\"));
              parser.gullet.endGroup();
              parser.gullet.beginGroup();
              const next = parser.fetch().text;
              if (next === "&" || next === "\\\\") {
                parser.consume();
              } else if (next === "\\end") {
                if (parsedRows[parsedRows.length - 1].length === 0) {
                  parsedRows.pop();
                }
                break;
              } else {
                throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
              }
            }
            let row = [];
            const body = [row];
            for (let i = 0; i < parsedRows.length; i++) {
              const rowNodes = parsedRows[i];
              let cell = newCell2();
              for (let j = 0; j < rowNodes.length; j++) {
                if (!isStartOfArrow2(rowNodes[j])) {
                  cell.body.push(rowNodes[j]);
                } else {
                  row.push(cell);
                  j += 1;
                  const arrowChar = assertSymbolNodeType2(rowNodes[j]).text;
                  const labels = new Array(2);
                  labels[0] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  };
                  labels[1] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  };
                  if ("=|.".indexOf(arrowChar) > -1) ;
                  else if ("<>AV".indexOf(arrowChar) > -1) {
                    for (let labelNum = 0; labelNum < 2; labelNum++) {
                      let inLabel = true;
                      for (let k = j + 1; k < rowNodes.length; k++) {
                        if (isLabelEnd2(rowNodes[k], arrowChar)) {
                          inLabel = false;
                          j = k;
                          break;
                        }
                        if (isStartOfArrow2(rowNodes[k])) {
                          throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                        }
                        labels[labelNum].body.push(rowNodes[k]);
                      }
                      if (inLabel) {
                        throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
                      }
                    }
                  } else {
                    throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
                  }
                  const arrow = cdArrow2(arrowChar, labels, parser);
                  const wrappedArrow = {
                    type: "styling",
                    body: [arrow],
                    mode: "math",
                    style: "display"
                    // CD is always displaystyle.
                  };
                  row.push(wrappedArrow);
                  cell = newCell2();
                }
              }
              if (i % 2 === 0) {
                row.push(cell);
              } else {
                row.shift();
              }
              row = [];
              body.push(row);
            }
            parser.gullet.endGroup();
            parser.gullet.endGroup();
            const cols = new Array(body[0].length).fill({
              type: "align",
              align: "c",
              pregap: 0.25,
              // CD package sets \enskip between columns.
              postgap: 0.25
              // So pre and post each get half an \enskip, i.e. 0.25em.
            });
            return {
              type: "array",
              mode: "math",
              body,
              arraystretch: 1,
              addJot: true,
              rowGaps: [null],
              cols,
              colSeparationType: "CD",
              hLinesBeforeRow: new Array(body.length + 1).fill([])
            };
          }
          defineFunction2({
            type: "cdlabel",
            names: ["\\\\cdleft", "\\\\cdright"],
            props: {
              numArgs: 1
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              return {
                type: "cdlabel",
                mode: parser.mode,
                side: funcName.slice(4),
                label: args[0]
              };
            },
            htmlBuilder(group, options) {
              const newOptions = options.havingStyle(options.style.sup());
              const label = buildCommon2.wrapFragment(buildGroup4(group.label, newOptions, options), options);
              label.classes.push("cd-label-" + group.side);
              label.style.bottom = makeEm3(0.8 - label.depth);
              label.height = 0;
              label.depth = 0;
              return label;
            },
            mathmlBuilder(group, options) {
              let label = new mathMLTree2.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
              label = new mathMLTree2.MathNode("mpadded", [label]);
              label.setAttribute("width", "0");
              if (group.side === "left") {
                label.setAttribute("lspace", "-1width");
              }
              label.setAttribute("voffset", "0.7em");
              label = new mathMLTree2.MathNode("mstyle", [label]);
              label.setAttribute("displaystyle", "false");
              label.setAttribute("scriptlevel", "1");
              return label;
            }
          });
          defineFunction2({
            type: "cdlabelparent",
            names: ["\\\\cdparent"],
            props: {
              numArgs: 1
            },
            handler(_ref2, args) {
              let {
                parser
              } = _ref2;
              return {
                type: "cdlabelparent",
                mode: parser.mode,
                fragment: args[0]
              };
            },
            htmlBuilder(group, options) {
              const parent = buildCommon2.wrapFragment(buildGroup4(group.fragment, options), options);
              parent.classes.push("cd-vert-arrow");
              return parent;
            },
            mathmlBuilder(group, options) {
              return new mathMLTree2.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
            }
          });
          defineFunction2({
            type: "textord",
            names: ["\\@char"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const arg = assertNodeType2(args[0], "ordgroup");
              const group = arg.body;
              let number2 = "";
              for (let i = 0; i < group.length; i++) {
                const node = assertNodeType2(group[i], "textord");
                number2 += node.text;
              }
              let code2 = parseInt(number2);
              let text2;
              if (isNaN(code2)) {
                throw new src_ParseError("\\@char has non-numeric argument " + number2);
              } else if (code2 < 0 || code2 >= 1114111) {
                throw new src_ParseError("\\@char with invalid code point " + number2);
              } else if (code2 <= 65535) {
                text2 = String.fromCharCode(code2);
              } else {
                code2 -= 65536;
                text2 = String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
              }
              return {
                type: "textord",
                mode: parser.mode,
                text: text2
              };
            }
          });
          const color_htmlBuilder = (group, options) => {
            const elements = buildExpression4(group.body, options.withColor(group.color), false);
            return buildCommon2.makeFragment(elements);
          };
          const color_mathmlBuilder = (group, options) => {
            const inner3 = buildMathML_buildExpression(group.body, options.withColor(group.color));
            const node = new mathMLTree2.MathNode("mstyle", inner3);
            node.setAttribute("mathcolor", group.color);
            return node;
          };
          defineFunction2({
            type: "color",
            names: ["\\textcolor"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "original"]
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const color2 = assertNodeType2(args[0], "color-token").color;
              const body = args[1];
              return {
                type: "color",
                mode: parser.mode,
                color: color2,
                body: ordargument3(body)
              };
            },
            htmlBuilder: color_htmlBuilder,
            mathmlBuilder: color_mathmlBuilder
          });
          defineFunction2({
            type: "color",
            names: ["\\color"],
            props: {
              numArgs: 1,
              allowedInText: true,
              argTypes: ["color"]
            },
            handler(_ref2, args) {
              let {
                parser,
                breakOnTokenText
              } = _ref2;
              const color2 = assertNodeType2(args[0], "color-token").color;
              parser.gullet.macros.set("\\current@color", color2);
              const body = parser.parseExpression(true, breakOnTokenText);
              return {
                type: "color",
                mode: parser.mode,
                color: color2,
                body
              };
            },
            htmlBuilder: color_htmlBuilder,
            mathmlBuilder: color_mathmlBuilder
          });
          defineFunction2({
            type: "cr",
            names: ["\\\\"],
            props: {
              numArgs: 0,
              numOptionalArgs: 0,
              allowedInText: true
            },
            handler(_ref, args, optArgs) {
              let {
                parser
              } = _ref;
              const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
              const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
              return {
                type: "cr",
                mode: parser.mode,
                newLine,
                size: size && assertNodeType2(size, "size").value
              };
            },
            // The following builders are called only at the top level,
            // not within tabular/array environments.
            htmlBuilder(group, options) {
              const span = buildCommon2.makeSpan(["mspace"], [], options);
              if (group.newLine) {
                span.classes.push("newline");
                if (group.size) {
                  span.style.marginTop = makeEm3(calculateSize3(group.size, options));
                }
              }
              return span;
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree2.MathNode("mspace");
              if (group.newLine) {
                node.setAttribute("linebreak", "newline");
                if (group.size) {
                  node.setAttribute("height", makeEm3(calculateSize3(group.size, options)));
                }
              }
              return node;
            }
          });
          const globalMap2 = {
            "\\global": "\\global",
            "\\long": "\\\\globallong",
            "\\\\globallong": "\\\\globallong",
            "\\def": "\\gdef",
            "\\gdef": "\\gdef",
            "\\edef": "\\xdef",
            "\\xdef": "\\xdef",
            "\\let": "\\\\globallet",
            "\\futurelet": "\\\\globalfuture"
          };
          const checkControlSequence2 = (tok) => {
            const name = tok.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
              throw new src_ParseError("Expected a control sequence", tok);
            }
            return name;
          };
          const getRHS2 = (parser) => {
            let tok = parser.gullet.popToken();
            if (tok.text === "=") {
              tok = parser.gullet.popToken();
              if (tok.text === " ") {
                tok = parser.gullet.popToken();
              }
            }
            return tok;
          };
          const letCommand2 = (parser, name, tok, global) => {
            let macro = parser.gullet.macros.get(tok.text);
            if (macro == null) {
              tok.noexpand = true;
              macro = {
                tokens: [tok],
                numArgs: 0,
                // reproduce the same behavior in expansion
                unexpandable: !parser.gullet.isExpandable(tok.text)
              };
            }
            parser.gullet.macros.set(name, macro, global);
          };
          defineFunction2({
            type: "internal",
            names: [
              "\\global",
              "\\long",
              "\\\\globallong"
              // cant be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(_ref) {
              let {
                parser,
                funcName
              } = _ref;
              parser.consumeSpaces();
              const token = parser.fetch();
              if (globalMap2[token.text]) {
                if (funcName === "\\global" || funcName === "\\\\globallong") {
                  token.text = globalMap2[token.text];
                }
                return assertNodeType2(parser.parseFunction(), "internal");
              }
              throw new src_ParseError("Invalid token after macro prefix", token);
            }
          });
          defineFunction2({
            type: "internal",
            names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref2) {
              let {
                parser,
                funcName
              } = _ref2;
              let tok = parser.gullet.popToken();
              const name = tok.text;
              if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
                throw new src_ParseError("Expected a control sequence", tok);
              }
              let numArgs = 0;
              let insert;
              const delimiters3 = [[]];
              while (parser.gullet.future().text !== "{") {
                tok = parser.gullet.popToken();
                if (tok.text === "#") {
                  if (parser.gullet.future().text === "{") {
                    insert = parser.gullet.future();
                    delimiters3[numArgs].push("{");
                    break;
                  }
                  tok = parser.gullet.popToken();
                  if (!/^[1-9]$/.test(tok.text)) {
                    throw new src_ParseError('Invalid argument number "' + tok.text + '"');
                  }
                  if (parseInt(tok.text) !== numArgs + 1) {
                    throw new src_ParseError('Argument number "' + tok.text + '" out of order');
                  }
                  numArgs++;
                  delimiters3.push([]);
                } else if (tok.text === "EOF") {
                  throw new src_ParseError("Expected a macro definition");
                } else {
                  delimiters3[numArgs].push(tok.text);
                }
              }
              let {
                tokens
              } = parser.gullet.consumeArg();
              if (insert) {
                tokens.unshift(insert);
              }
              if (funcName === "\\edef" || funcName === "\\xdef") {
                tokens = parser.gullet.expandTokens(tokens);
                tokens.reverse();
              }
              parser.gullet.macros.set(name, {
                tokens,
                numArgs,
                delimiters: delimiters3
              }, funcName === globalMap2[funcName]);
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction2({
            type: "internal",
            names: [
              "\\let",
              "\\\\globallet"
              // cant be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref3) {
              let {
                parser,
                funcName
              } = _ref3;
              const name = checkControlSequence2(parser.gullet.popToken());
              parser.gullet.consumeSpaces();
              const tok = getRHS2(parser);
              letCommand2(parser, name, tok, funcName === "\\\\globallet");
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction2({
            type: "internal",
            names: [
              "\\futurelet",
              "\\\\globalfuture"
              // cant be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref4) {
              let {
                parser,
                funcName
              } = _ref4;
              const name = checkControlSequence2(parser.gullet.popToken());
              const middle = parser.gullet.popToken();
              const tok = parser.gullet.popToken();
              letCommand2(parser, name, tok, funcName === "\\\\globalfuture");
              parser.gullet.pushToken(tok);
              parser.gullet.pushToken(middle);
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          const getMetrics3 = function(symbol, font, mode) {
            const replace2 = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
            const metrics = getCharacterMetrics2(replace2 || symbol, font, mode);
            if (!metrics) {
              throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
            }
            return metrics;
          };
          const styleWrap3 = function(delim, toStyle, options, classes) {
            const newOptions = options.havingBaseStyle(toStyle);
            const span = buildCommon2.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
            const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
            span.height *= delimSizeMultiplier;
            span.depth *= delimSizeMultiplier;
            span.maxFontSize = newOptions.sizeMultiplier;
            return span;
          };
          const centerSpan3 = function(span, options, style) {
            const newOptions = options.havingBaseStyle(style);
            const shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
            span.classes.push("delimcenter");
            span.style.top = makeEm3(shift);
            span.height -= shift;
            span.depth += shift;
          };
          const makeSmallDelim3 = function(delim, style, center, options, mode, classes) {
            const text2 = buildCommon2.makeSymbol(delim, "Main-Regular", mode, options);
            const span = styleWrap3(text2, style, options, classes);
            if (center) {
              centerSpan3(span, options, style);
            }
            return span;
          };
          const mathrmSize3 = function(value, size, mode, options) {
            return buildCommon2.makeSymbol(value, "Size" + size + "-Regular", mode, options);
          };
          const makeLargeDelim3 = function(delim, size, center, options, mode, classes) {
            const inner3 = mathrmSize3(delim, size, mode, options);
            const span = styleWrap3(buildCommon2.makeSpan(["delimsizing", "size" + size], [inner3], options), src_Style.TEXT, options, classes);
            if (center) {
              centerSpan3(span, options, src_Style.TEXT);
            }
            return span;
          };
          const makeGlyphSpan3 = function(symbol, font, mode) {
            let sizeClass;
            if (font === "Size1-Regular") {
              sizeClass = "delim-size1";
            } else {
              sizeClass = "delim-size4";
            }
            const corner = buildCommon2.makeSpan(["delimsizinginner", sizeClass], [buildCommon2.makeSpan([], [buildCommon2.makeSymbol(symbol, font, mode)])]);
            return {
              type: "elem",
              elem: corner
            };
          };
          const makeInner3 = function(ch, height, options) {
            const width = fontMetricsData2["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData2["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData2["Size1-Regular"][ch.charCodeAt(0)][4];
            const path3 = new PathNode2("inner", innerPath3(ch, Math.round(1e3 * height)));
            const svgNode = new SvgNode2([path3], {
              "width": makeEm3(width),
              "height": makeEm3(height),
              // Override CSS rule `.katex svg { width: 100% }`
              "style": "width:" + makeEm3(width),
              "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
              "preserveAspectRatio": "xMinYMin"
            });
            const span = buildCommon2.makeSvgSpan([], [svgNode], options);
            span.height = height;
            span.style.height = makeEm3(height);
            span.style.width = makeEm3(width);
            return {
              type: "elem",
              elem: span
            };
          };
          const lapInEms2 = 8e-3;
          const lap2 = {
            type: "kern",
            size: -1 * lapInEms2
          };
          const verts2 = ["|", "\\lvert", "\\rvert", "\\vert"];
          const doubleVerts2 = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
          const makeStackedDelim3 = function(delim, heightTotal, center, options, mode, classes) {
            let top;
            let middle;
            let repeat;
            let bottom;
            let svgLabel = "";
            let viewBoxWidth = 0;
            top = repeat = bottom = delim;
            middle = null;
            let font = "Size1-Regular";
            if (delim === "\\uparrow") {
              repeat = bottom = "";
            } else if (delim === "\\Uparrow") {
              repeat = bottom = "";
            } else if (delim === "\\downarrow") {
              top = repeat = "";
            } else if (delim === "\\Downarrow") {
              top = repeat = "";
            } else if (delim === "\\updownarrow") {
              top = "\\uparrow";
              repeat = "";
              bottom = "\\downarrow";
            } else if (delim === "\\Updownarrow") {
              top = "\\Uparrow";
              repeat = "";
              bottom = "\\Downarrow";
            } else if (verts2.includes(delim)) {
              repeat = "";
              svgLabel = "vert";
              viewBoxWidth = 333;
            } else if (doubleVerts2.includes(delim)) {
              repeat = "";
              svgLabel = "doublevert";
              viewBoxWidth = 556;
            } else if (delim === "[" || delim === "\\lbrack") {
              top = "";
              repeat = "";
              bottom = "";
              font = "Size4-Regular";
              svgLabel = "lbrack";
              viewBoxWidth = 667;
            } else if (delim === "]" || delim === "\\rbrack") {
              top = "";
              repeat = "";
              bottom = "";
              font = "Size4-Regular";
              svgLabel = "rbrack";
              viewBoxWidth = 667;
            } else if (delim === "\\lfloor" || delim === "") {
              repeat = top = "";
              bottom = "";
              font = "Size4-Regular";
              svgLabel = "lfloor";
              viewBoxWidth = 667;
            } else if (delim === "\\lceil" || delim === "") {
              top = "";
              repeat = bottom = "";
              font = "Size4-Regular";
              svgLabel = "lceil";
              viewBoxWidth = 667;
            } else if (delim === "\\rfloor" || delim === "") {
              repeat = top = "";
              bottom = "";
              font = "Size4-Regular";
              svgLabel = "rfloor";
              viewBoxWidth = 667;
            } else if (delim === "\\rceil" || delim === "") {
              top = "";
              repeat = bottom = "";
              font = "Size4-Regular";
              svgLabel = "rceil";
              viewBoxWidth = 667;
            } else if (delim === "(" || delim === "\\lparen") {
              top = "";
              repeat = "";
              bottom = "";
              font = "Size4-Regular";
              svgLabel = "lparen";
              viewBoxWidth = 875;
            } else if (delim === ")" || delim === "\\rparen") {
              top = "";
              repeat = "";
              bottom = "";
              font = "Size4-Regular";
              svgLabel = "rparen";
              viewBoxWidth = 875;
            } else if (delim === "\\{" || delim === "\\lbrace") {
              top = "";
              middle = "";
              bottom = "";
              repeat = "";
              font = "Size4-Regular";
            } else if (delim === "\\}" || delim === "\\rbrace") {
              top = "";
              middle = "";
              bottom = "";
              repeat = "";
              font = "Size4-Regular";
            } else if (delim === "\\lgroup" || delim === "") {
              top = "";
              bottom = "";
              repeat = "";
              font = "Size4-Regular";
            } else if (delim === "\\rgroup" || delim === "") {
              top = "";
              bottom = "";
              repeat = "";
              font = "Size4-Regular";
            } else if (delim === "\\lmoustache" || delim === "") {
              top = "";
              bottom = "";
              repeat = "";
              font = "Size4-Regular";
            } else if (delim === "\\rmoustache" || delim === "") {
              top = "";
              bottom = "";
              repeat = "";
              font = "Size4-Regular";
            }
            const topMetrics = getMetrics3(top, font, mode);
            const topHeightTotal = topMetrics.height + topMetrics.depth;
            const repeatMetrics = getMetrics3(repeat, font, mode);
            const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
            const bottomMetrics = getMetrics3(bottom, font, mode);
            const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
            let middleHeightTotal = 0;
            let middleFactor = 1;
            if (middle !== null) {
              const middleMetrics = getMetrics3(middle, font, mode);
              middleHeightTotal = middleMetrics.height + middleMetrics.depth;
              middleFactor = 2;
            }
            const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
            const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
            const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
            let axisHeight = options.fontMetrics().axisHeight;
            if (center) {
              axisHeight *= options.sizeMultiplier;
            }
            const depth = realHeightTotal / 2 - axisHeight;
            const stack = [];
            if (svgLabel.length > 0) {
              const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
              const viewBoxHeight = Math.round(realHeightTotal * 1e3);
              const pathStr = tallDelim3(svgLabel, Math.round(midHeight * 1e3));
              const path3 = new PathNode2(svgLabel, pathStr);
              const width = (viewBoxWidth / 1e3).toFixed(3) + "em";
              const height = (viewBoxHeight / 1e3).toFixed(3) + "em";
              const svg = new SvgNode2([path3], {
                "width": width,
                "height": height,
                "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
              });
              const wrapper = buildCommon2.makeSvgSpan([], [svg], options);
              wrapper.height = viewBoxHeight / 1e3;
              wrapper.style.width = width;
              wrapper.style.height = height;
              stack.push({
                type: "elem",
                elem: wrapper
              });
            } else {
              stack.push(makeGlyphSpan3(bottom, font, mode));
              stack.push(lap2);
              if (middle === null) {
                const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms2;
                stack.push(makeInner3(repeat, innerHeight, options));
              } else {
                const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms2;
                stack.push(makeInner3(repeat, innerHeight, options));
                stack.push(lap2);
                stack.push(makeGlyphSpan3(middle, font, mode));
                stack.push(lap2);
                stack.push(makeInner3(repeat, innerHeight, options));
              }
              stack.push(lap2);
              stack.push(makeGlyphSpan3(top, font, mode));
            }
            const newOptions = options.havingBaseStyle(src_Style.TEXT);
            const inner3 = buildCommon2.makeVList({
              positionType: "bottom",
              positionData: depth,
              children: stack
            }, newOptions);
            return styleWrap3(buildCommon2.makeSpan(["delimsizing", "mult"], [inner3], newOptions), src_Style.TEXT, options, classes);
          };
          const vbPad2 = 80;
          const emPad2 = 0.08;
          const sqrtSvg3 = function(sqrtName, height, viewBoxHeight, extraVinculum, options) {
            const path3 = sqrtPath3(sqrtName, extraVinculum, viewBoxHeight);
            const pathNode = new PathNode2(sqrtName, path3);
            const svg = new SvgNode2([pathNode], {
              // Note: 1000:1 ratio of viewBox to document em width.
              "width": "400em",
              "height": makeEm3(height),
              "viewBox": "0 0 400000 " + viewBoxHeight,
              "preserveAspectRatio": "xMinYMin slice"
            });
            return buildCommon2.makeSvgSpan(["hide-tail"], [svg], options);
          };
          const makeSqrtImage3 = function(height, options) {
            const newOptions = options.havingBaseSizing();
            const delim = traverseSequence3("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence2, newOptions);
            let sizeMultiplier = newOptions.sizeMultiplier;
            const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
            let span;
            let spanHeight = 0;
            let texHeight = 0;
            let viewBoxHeight = 0;
            let advanceWidth;
            if (delim.type === "small") {
              viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad2;
              if (height < 1) {
                sizeMultiplier = 1;
              } else if (height < 1.4) {
                sizeMultiplier = 0.7;
              }
              spanHeight = (1 + extraVinculum + emPad2) / sizeMultiplier;
              texHeight = (1 + extraVinculum) / sizeMultiplier;
              span = sqrtSvg3("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
              span.style.minWidth = "0.853em";
              advanceWidth = 0.833 / sizeMultiplier;
            } else if (delim.type === "large") {
              viewBoxHeight = (1e3 + vbPad2) * sizeToMaxHeight2[delim.size];
              texHeight = (sizeToMaxHeight2[delim.size] + extraVinculum) / sizeMultiplier;
              spanHeight = (sizeToMaxHeight2[delim.size] + extraVinculum + emPad2) / sizeMultiplier;
              span = sqrtSvg3("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
              span.style.minWidth = "1.02em";
              advanceWidth = 1 / sizeMultiplier;
            } else {
              spanHeight = height + extraVinculum + emPad2;
              texHeight = height + extraVinculum;
              viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad2;
              span = sqrtSvg3("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
              span.style.minWidth = "0.742em";
              advanceWidth = 1.056;
            }
            span.height = texHeight;
            span.style.height = makeEm3(spanHeight);
            return {
              span,
              advanceWidth,
              // Calculate the actual line width.
              // This actually should depend on the chosen font -- e.g. \boldmath
              // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
              // have thicker rules.
              ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
            };
          };
          const stackLargeDelimiters2 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"];
          const stackAlwaysDelimiters2 = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""];
          const stackNeverDelimiters2 = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
          const sizeToMaxHeight2 = [0, 1.2, 1.8, 2.4, 3];
          const makeSizedDelim3 = function(delim, size, options, mode, classes) {
            if (delim === "<" || delim === "\\lt" || delim === "") {
              delim = "\\langle";
            } else if (delim === ">" || delim === "\\gt" || delim === "") {
              delim = "\\rangle";
            }
            if (stackLargeDelimiters2.includes(delim) || stackNeverDelimiters2.includes(delim)) {
              return makeLargeDelim3(delim, size, false, options, mode, classes);
            } else if (stackAlwaysDelimiters2.includes(delim)) {
              return makeStackedDelim3(delim, sizeToMaxHeight2[size], false, options, mode, classes);
            } else {
              throw new src_ParseError("Illegal delimiter: '" + delim + "'");
            }
          };
          const stackNeverDelimiterSequence2 = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }];
          const stackAlwaysDelimiterSequence2 = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "stack"
          }];
          const stackLargeDelimiterSequence2 = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }, {
            type: "stack"
          }];
          const delimTypeToFont3 = function(type) {
            if (type.type === "small") {
              return "Main-Regular";
            } else if (type.type === "large") {
              return "Size" + type.size + "-Regular";
            } else if (type.type === "stack") {
              return "Size4-Regular";
            } else {
              throw new Error("Add support for delim type '" + type.type + "' here.");
            }
          };
          const traverseSequence3 = function(delim, height, sequence, options) {
            const start = Math.min(2, 3 - options.style.size);
            for (let i = start; i < sequence.length; i++) {
              if (sequence[i].type === "stack") {
                break;
              }
              const metrics = getMetrics3(delim, delimTypeToFont3(sequence[i]), "math");
              let heightDepth = metrics.height + metrics.depth;
              if (sequence[i].type === "small") {
                const newOptions = options.havingBaseStyle(sequence[i].style);
                heightDepth *= newOptions.sizeMultiplier;
              }
              if (heightDepth > height) {
                return sequence[i];
              }
            }
            return sequence[sequence.length - 1];
          };
          const makeCustomSizedDelim3 = function(delim, height, center, options, mode, classes) {
            if (delim === "<" || delim === "\\lt" || delim === "") {
              delim = "\\langle";
            } else if (delim === ">" || delim === "\\gt" || delim === "") {
              delim = "\\rangle";
            }
            let sequence;
            if (stackNeverDelimiters2.includes(delim)) {
              sequence = stackNeverDelimiterSequence2;
            } else if (stackLargeDelimiters2.includes(delim)) {
              sequence = stackLargeDelimiterSequence2;
            } else {
              sequence = stackAlwaysDelimiterSequence2;
            }
            const delimType = traverseSequence3(delim, height, sequence, options);
            if (delimType.type === "small") {
              return makeSmallDelim3(delim, delimType.style, center, options, mode, classes);
            } else if (delimType.type === "large") {
              return makeLargeDelim3(delim, delimType.size, center, options, mode, classes);
            } else {
              return makeStackedDelim3(delim, height, center, options, mode, classes);
            }
          };
          const makeLeftRightDelim3 = function(delim, height, depth, options, mode, classes) {
            const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
            const delimiterFactor = 901;
            const delimiterExtend = 5 / options.fontMetrics().ptPerEm;
            const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
            const totalHeight = Math.max(
              // In real TeX, calculations are done using integral values which are
              // 65536 per pt, or 655360 per em. So, the division here truncates in
              // TeX but doesn't here, producing different results. If we wanted to
              // exactly match TeX's calculation, we could do
              //   Math.floor(655360 * maxDistFromAxis / 500) *
              //    delimiterFactor / 655360
              // (To see the difference, compare
              //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
              // in TeX and KaTeX)
              maxDistFromAxis / 500 * delimiterFactor,
              2 * maxDistFromAxis - delimiterExtend
            );
            return makeCustomSizedDelim3(delim, totalHeight, true, options, mode, classes);
          };
          var delimiter2 = {
            sqrtImage: makeSqrtImage3,
            sizedDelim: makeSizedDelim3,
            sizeToMaxHeight: sizeToMaxHeight2,
            customSizedDelim: makeCustomSizedDelim3,
            leftRightDelim: makeLeftRightDelim3
          };
          const delimiterSizes2 = {
            "\\bigl": {
              mclass: "mopen",
              size: 1
            },
            "\\Bigl": {
              mclass: "mopen",
              size: 2
            },
            "\\biggl": {
              mclass: "mopen",
              size: 3
            },
            "\\Biggl": {
              mclass: "mopen",
              size: 4
            },
            "\\bigr": {
              mclass: "mclose",
              size: 1
            },
            "\\Bigr": {
              mclass: "mclose",
              size: 2
            },
            "\\biggr": {
              mclass: "mclose",
              size: 3
            },
            "\\Biggr": {
              mclass: "mclose",
              size: 4
            },
            "\\bigm": {
              mclass: "mrel",
              size: 1
            },
            "\\Bigm": {
              mclass: "mrel",
              size: 2
            },
            "\\biggm": {
              mclass: "mrel",
              size: 3
            },
            "\\Biggm": {
              mclass: "mrel",
              size: 4
            },
            "\\big": {
              mclass: "mord",
              size: 1
            },
            "\\Big": {
              mclass: "mord",
              size: 2
            },
            "\\bigg": {
              mclass: "mord",
              size: 3
            },
            "\\Bigg": {
              mclass: "mord",
              size: 4
            }
          };
          const delimiters2 = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
          function checkDelimiter2(delim, context) {
            const symDelim = checkSymbolNodeType2(delim);
            if (symDelim && delimiters2.includes(symDelim.text)) {
              return symDelim;
            } else if (symDelim) {
              throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
            } else {
              throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
            }
          }
          defineFunction2({
            type: "delimsizing",
            names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
            props: {
              numArgs: 1,
              argTypes: ["primitive"]
            },
            handler: (context, args) => {
              const delim = checkDelimiter2(args[0], context);
              return {
                type: "delimsizing",
                mode: context.parser.mode,
                size: delimiterSizes2[context.funcName].size,
                mclass: delimiterSizes2[context.funcName].mclass,
                delim: delim.text
              };
            },
            htmlBuilder: (group, options) => {
              if (group.delim === ".") {
                return buildCommon2.makeSpan([group.mclass]);
              }
              return delimiter2.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
            },
            mathmlBuilder: (group) => {
              const children = [];
              if (group.delim !== ".") {
                children.push(makeText3(group.delim, group.mode));
              }
              const node = new mathMLTree2.MathNode("mo", children);
              if (group.mclass === "mopen" || group.mclass === "mclose") {
                node.setAttribute("fence", "true");
              } else {
                node.setAttribute("fence", "false");
              }
              node.setAttribute("stretchy", "true");
              const size = makeEm3(delimiter2.sizeToMaxHeight[group.size]);
              node.setAttribute("minsize", size);
              node.setAttribute("maxsize", size);
              return node;
            }
          });
          function assertParsed2(group) {
            if (!group.body) {
              throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
            }
          }
          defineFunction2({
            type: "leftright-right",
            names: ["\\right"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (context, args) => {
              const color2 = context.parser.gullet.macros.get("\\current@color");
              if (color2 && typeof color2 !== "string") {
                throw new src_ParseError("\\current@color set to non-string in \\right");
              }
              return {
                type: "leftright-right",
                mode: context.parser.mode,
                delim: checkDelimiter2(args[0], context).text,
                color: color2
                // undefined if not set via \color
              };
            }
          });
          defineFunction2({
            type: "leftright",
            names: ["\\left"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (context, args) => {
              const delim = checkDelimiter2(args[0], context);
              const parser = context.parser;
              ++parser.leftrightDepth;
              const body = parser.parseExpression(false);
              --parser.leftrightDepth;
              parser.expect("\\right", false);
              const right = assertNodeType2(parser.parseFunction(), "leftright-right");
              return {
                type: "leftright",
                mode: parser.mode,
                body,
                left: delim.text,
                right: right.delim,
                rightColor: right.color
              };
            },
            htmlBuilder: (group, options) => {
              assertParsed2(group);
              const inner3 = buildExpression4(group.body, options, true, ["mopen", "mclose"]);
              let innerHeight = 0;
              let innerDepth = 0;
              let hadMiddle = false;
              for (let i = 0; i < inner3.length; i++) {
                if (inner3[i].isMiddle) {
                  hadMiddle = true;
                } else {
                  innerHeight = Math.max(inner3[i].height, innerHeight);
                  innerDepth = Math.max(inner3[i].depth, innerDepth);
                }
              }
              innerHeight *= options.sizeMultiplier;
              innerDepth *= options.sizeMultiplier;
              let leftDelim;
              if (group.left === ".") {
                leftDelim = makeNullDelimiter3(options, ["mopen"]);
              } else {
                leftDelim = delimiter2.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
              }
              inner3.unshift(leftDelim);
              if (hadMiddle) {
                for (let i = 1; i < inner3.length; i++) {
                  const middleDelim = inner3[i];
                  const isMiddle = middleDelim.isMiddle;
                  if (isMiddle) {
                    inner3[i] = delimiter2.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                  }
                }
              }
              let rightDelim;
              if (group.right === ".") {
                rightDelim = makeNullDelimiter3(options, ["mclose"]);
              } else {
                const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
                rightDelim = delimiter2.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
              }
              inner3.push(rightDelim);
              return buildCommon2.makeSpan(["minner"], inner3, options);
            },
            mathmlBuilder: (group, options) => {
              assertParsed2(group);
              const inner3 = buildMathML_buildExpression(group.body, options);
              if (group.left !== ".") {
                const leftNode = new mathMLTree2.MathNode("mo", [makeText3(group.left, group.mode)]);
                leftNode.setAttribute("fence", "true");
                inner3.unshift(leftNode);
              }
              if (group.right !== ".") {
                const rightNode = new mathMLTree2.MathNode("mo", [makeText3(group.right, group.mode)]);
                rightNode.setAttribute("fence", "true");
                if (group.rightColor) {
                  rightNode.setAttribute("mathcolor", group.rightColor);
                }
                inner3.push(rightNode);
              }
              return makeRow3(inner3);
            }
          });
          defineFunction2({
            type: "middle",
            names: ["\\middle"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (context, args) => {
              const delim = checkDelimiter2(args[0], context);
              if (!context.parser.leftrightDepth) {
                throw new src_ParseError("\\middle without preceding \\left", delim);
              }
              return {
                type: "middle",
                mode: context.parser.mode,
                delim: delim.text
              };
            },
            htmlBuilder: (group, options) => {
              let middleDelim;
              if (group.delim === ".") {
                middleDelim = makeNullDelimiter3(options, []);
              } else {
                middleDelim = delimiter2.sizedDelim(group.delim, 1, options, group.mode, []);
                const isMiddle = {
                  delim: group.delim,
                  options
                };
                middleDelim.isMiddle = isMiddle;
              }
              return middleDelim;
            },
            mathmlBuilder: (group, options) => {
              const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText3("|", "text") : makeText3(group.delim, group.mode);
              const middleNode = new mathMLTree2.MathNode("mo", [textNode]);
              middleNode.setAttribute("fence", "true");
              middleNode.setAttribute("lspace", "0.05em");
              middleNode.setAttribute("rspace", "0.05em");
              return middleNode;
            }
          });
          const enclose_htmlBuilder = (group, options) => {
            const inner3 = buildCommon2.wrapFragment(buildGroup4(group.body, options), options);
            const label = group.label.slice(1);
            let scale = options.sizeMultiplier;
            let img;
            let imgShift = 0;
            const isSingleChar = utils2.isCharacterBox(group.body);
            if (label === "sout") {
              img = buildCommon2.makeSpan(["stretchy", "sout"]);
              img.height = options.fontMetrics().defaultRuleThickness / scale;
              imgShift = -0.5 * options.fontMetrics().xHeight;
            } else if (label === "phase") {
              const lineWeight = calculateSize3({
                number: 0.6,
                unit: "pt"
              }, options);
              const clearance = calculateSize3({
                number: 0.35,
                unit: "ex"
              }, options);
              const newOptions = options.havingBaseSizing();
              scale = scale / newOptions.sizeMultiplier;
              const angleHeight = inner3.height + inner3.depth + lineWeight + clearance;
              inner3.style.paddingLeft = makeEm3(angleHeight / 2 + lineWeight);
              const viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
              const path3 = phasePath3(viewBoxHeight);
              const svgNode = new SvgNode2([new PathNode2("phase", path3)], {
                "width": "400em",
                "height": makeEm3(viewBoxHeight / 1e3),
                "viewBox": "0 0 400000 " + viewBoxHeight,
                "preserveAspectRatio": "xMinYMin slice"
              });
              img = buildCommon2.makeSvgSpan(["hide-tail"], [svgNode], options);
              img.style.height = makeEm3(angleHeight);
              imgShift = inner3.depth + lineWeight + clearance;
            } else {
              if (/cancel/.test(label)) {
                if (!isSingleChar) {
                  inner3.classes.push("cancel-pad");
                }
              } else if (label === "angl") {
                inner3.classes.push("anglpad");
              } else {
                inner3.classes.push("boxpad");
              }
              let topPad = 0;
              let bottomPad = 0;
              let ruleThickness = 0;
              if (/box/.test(label)) {
                ruleThickness = Math.max(
                  options.fontMetrics().fboxrule,
                  // default
                  options.minRuleThickness
                  // User override.
                );
                topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
                bottomPad = topPad;
              } else if (label === "angl") {
                ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
                topPad = 4 * ruleThickness;
                bottomPad = Math.max(0, 0.25 - inner3.depth);
              } else {
                topPad = isSingleChar ? 0.2 : 0;
                bottomPad = topPad;
              }
              img = stretchy2.encloseSpan(inner3, label, topPad, bottomPad, options);
              if (/fbox|boxed|fcolorbox/.test(label)) {
                img.style.borderStyle = "solid";
                img.style.borderWidth = makeEm3(ruleThickness);
              } else if (label === "angl" && ruleThickness !== 0.049) {
                img.style.borderTopWidth = makeEm3(ruleThickness);
                img.style.borderRightWidth = makeEm3(ruleThickness);
              }
              imgShift = inner3.depth + bottomPad;
              if (group.backgroundColor) {
                img.style.backgroundColor = group.backgroundColor;
                if (group.borderColor) {
                  img.style.borderColor = group.borderColor;
                }
              }
            }
            let vlist;
            if (group.backgroundColor) {
              vlist = buildCommon2.makeVList({
                positionType: "individualShift",
                children: [
                  // Put the color background behind inner;
                  {
                    type: "elem",
                    elem: img,
                    shift: imgShift
                  },
                  {
                    type: "elem",
                    elem: inner3,
                    shift: 0
                  }
                ]
              }, options);
            } else {
              const classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
              vlist = buildCommon2.makeVList({
                positionType: "individualShift",
                children: [
                  // Write the \cancel stroke on top of inner.
                  {
                    type: "elem",
                    elem: inner3,
                    shift: 0
                  },
                  {
                    type: "elem",
                    elem: img,
                    shift: imgShift,
                    wrapperClasses: classes
                  }
                ]
              }, options);
            }
            if (/cancel/.test(label)) {
              vlist.height = inner3.height;
              vlist.depth = inner3.depth;
            }
            if (/cancel/.test(label) && !isSingleChar) {
              return buildCommon2.makeSpan(["mord", "cancel-lap"], [vlist], options);
            } else {
              return buildCommon2.makeSpan(["mord"], [vlist], options);
            }
          };
          const enclose_mathmlBuilder = (group, options) => {
            let fboxsep = 0;
            const node = new mathMLTree2.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
            switch (group.label) {
              case "\\cancel":
                node.setAttribute("notation", "updiagonalstrike");
                break;
              case "\\bcancel":
                node.setAttribute("notation", "downdiagonalstrike");
                break;
              case "\\phase":
                node.setAttribute("notation", "phasorangle");
                break;
              case "\\sout":
                node.setAttribute("notation", "horizontalstrike");
                break;
              case "\\fbox":
                node.setAttribute("notation", "box");
                break;
              case "\\angl":
                node.setAttribute("notation", "actuarial");
                break;
              case "\\fcolorbox":
              case "\\colorbox":
                fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
                node.setAttribute("width", "+" + 2 * fboxsep + "pt");
                node.setAttribute("height", "+" + 2 * fboxsep + "pt");
                node.setAttribute("lspace", fboxsep + "pt");
                node.setAttribute("voffset", fboxsep + "pt");
                if (group.label === "\\fcolorbox") {
                  const thk = Math.max(
                    options.fontMetrics().fboxrule,
                    // default
                    options.minRuleThickness
                    // user override
                  );
                  node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
                }
                break;
              case "\\xcancel":
                node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                break;
            }
            if (group.backgroundColor) {
              node.setAttribute("mathbackground", group.backgroundColor);
            }
            return node;
          };
          defineFunction2({
            type: "enclose",
            names: ["\\colorbox"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "text"]
            },
            handler(_ref, args, optArgs) {
              let {
                parser,
                funcName
              } = _ref;
              const color2 = assertNodeType2(args[0], "color-token").color;
              const body = args[1];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                backgroundColor: color2,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction2({
            type: "enclose",
            names: ["\\fcolorbox"],
            props: {
              numArgs: 3,
              allowedInText: true,
              argTypes: ["color", "color", "text"]
            },
            handler(_ref2, args, optArgs) {
              let {
                parser,
                funcName
              } = _ref2;
              const borderColor = assertNodeType2(args[0], "color-token").color;
              const backgroundColor = assertNodeType2(args[1], "color-token").color;
              const body = args[2];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                backgroundColor,
                borderColor,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction2({
            type: "enclose",
            names: ["\\fbox"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: true
            },
            handler(_ref3, args) {
              let {
                parser
              } = _ref3;
              return {
                type: "enclose",
                mode: parser.mode,
                label: "\\fbox",
                body: args[0]
              };
            }
          });
          defineFunction2({
            type: "enclose",
            names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
            props: {
              numArgs: 1
            },
            handler(_ref4, args) {
              let {
                parser,
                funcName
              } = _ref4;
              const body = args[0];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction2({
            type: "enclose",
            names: ["\\angl"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: false
            },
            handler(_ref5, args) {
              let {
                parser
              } = _ref5;
              return {
                type: "enclose",
                mode: parser.mode,
                label: "\\angl",
                body: args[0]
              };
            }
          });
          const _environments2 = {};
          function defineEnvironment2(_ref) {
            let {
              type,
              names,
              props,
              handler,
              htmlBuilder: htmlBuilder4,
              mathmlBuilder: mathmlBuilder4
            } = _ref;
            const data = {
              type,
              numArgs: props.numArgs || 0,
              allowedInText: false,
              numOptionalArgs: 0,
              handler
            };
            for (let i = 0; i < names.length; ++i) {
              _environments2[names[i]] = data;
            }
            if (htmlBuilder4) {
              _htmlGroupBuilders2[type] = htmlBuilder4;
            }
            if (mathmlBuilder4) {
              _mathmlGroupBuilders2[type] = mathmlBuilder4;
            }
          }
          const _macros2 = {};
          function defineMacro2(name, body) {
            _macros2[name] = body;
          }
          class SourceLocation2 {
            // The + prefix indicates that these fields aren't writeable
            // Lexer holding the input string.
            // Start offset, zero-based inclusive.
            // End offset, zero-based exclusive.
            constructor(lexer, start, end) {
              this.lexer = void 0;
              this.start = void 0;
              this.end = void 0;
              this.lexer = lexer;
              this.start = start;
              this.end = end;
            }
            /**
             * Merges two `SourceLocation`s from location providers, given they are
             * provided in order of appearance.
             * - Returns the first one's location if only the first is provided.
             * - Returns a merged range of the first and the last if both are provided
             *   and their lexers match.
             * - Otherwise, returns null.
             */
            static range(first, second2) {
              if (!second2) {
                return first && first.loc;
              } else if (!first || !first.loc || !second2.loc || first.loc.lexer !== second2.loc.lexer) {
                return null;
              } else {
                return new SourceLocation2(first.loc.lexer, first.loc.start, second2.loc.end);
              }
            }
          }
          class Token3 {
            // don't expand the token
            // used in \noexpand
            constructor(text2, loc) {
              this.text = void 0;
              this.loc = void 0;
              this.noexpand = void 0;
              this.treatAsRelax = void 0;
              this.text = text2;
              this.loc = loc;
            }
            /**
             * Given a pair of tokens (this and endToken), compute a `Token` encompassing
             * the whole input range enclosed by these two.
             */
            range(endToken, text2) {
              return new Token3(text2, SourceLocation2.range(this, endToken));
            }
          }
          function getHLines2(parser) {
            const hlineInfo = [];
            parser.consumeSpaces();
            let nxt = parser.fetch().text;
            if (nxt === "\\relax") {
              parser.consume();
              parser.consumeSpaces();
              nxt = parser.fetch().text;
            }
            while (nxt === "\\hline" || nxt === "\\hdashline") {
              parser.consume();
              hlineInfo.push(nxt === "\\hdashline");
              parser.consumeSpaces();
              nxt = parser.fetch().text;
            }
            return hlineInfo;
          }
          const validateAmsEnvironmentContext2 = (context) => {
            const settings = context.parser.settings;
            if (!settings.displayMode) {
              throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
            }
          };
          function getAutoTag2(name) {
            if (name.indexOf("ed") === -1) {
              return name.indexOf("*") === -1;
            }
          }
          function parseArray2(parser, _ref, style) {
            let {
              hskipBeforeAndAfter,
              addJot,
              cols,
              arraystretch,
              colSeparationType,
              autoTag,
              singleRow,
              emptySingleRow,
              maxNumCols,
              leqno
            } = _ref;
            parser.gullet.beginGroup();
            if (!singleRow) {
              parser.gullet.macros.set("\\cr", "\\\\\\relax");
            }
            if (!arraystretch) {
              const stretch = parser.gullet.expandMacroAsText("\\arraystretch");
              if (stretch == null) {
                arraystretch = 1;
              } else {
                arraystretch = parseFloat(stretch);
                if (!arraystretch || arraystretch < 0) {
                  throw new src_ParseError("Invalid \\arraystretch: " + stretch);
                }
              }
            }
            parser.gullet.beginGroup();
            let row = [];
            const body = [row];
            const rowGaps = [];
            const hLinesBeforeRow = [];
            const tags = autoTag != null ? [] : void 0;
            function beginRow() {
              if (autoTag) {
                parser.gullet.macros.set("\\@eqnsw", "1", true);
              }
            }
            function endRow() {
              if (tags) {
                if (parser.gullet.macros.get("\\df@tag")) {
                  tags.push(parser.subparse([new Token3("\\df@tag")]));
                  parser.gullet.macros.set("\\df@tag", void 0, true);
                } else {
                  tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
                }
              }
            }
            beginRow();
            hLinesBeforeRow.push(getHLines2(parser));
            while (true) {
              let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
              parser.gullet.endGroup();
              parser.gullet.beginGroup();
              cell = {
                type: "ordgroup",
                mode: parser.mode,
                body: cell
              };
              if (style) {
                cell = {
                  type: "styling",
                  mode: parser.mode,
                  style,
                  body: [cell]
                };
              }
              row.push(cell);
              const next = parser.fetch().text;
              if (next === "&") {
                if (maxNumCols && row.length === maxNumCols) {
                  if (singleRow || colSeparationType) {
                    throw new src_ParseError("Too many tab characters: &", parser.nextToken);
                  } else {
                    parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                  }
                }
                parser.consume();
              } else if (next === "\\end") {
                endRow();
                if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
                  body.pop();
                }
                if (hLinesBeforeRow.length < body.length + 1) {
                  hLinesBeforeRow.push([]);
                }
                break;
              } else if (next === "\\\\") {
                parser.consume();
                let size;
                if (parser.gullet.future().text !== " ") {
                  size = parser.parseSizeGroup(true);
                }
                rowGaps.push(size ? size.value : null);
                endRow();
                hLinesBeforeRow.push(getHLines2(parser));
                row = [];
                body.push(row);
                beginRow();
              } else {
                throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
              }
            }
            parser.gullet.endGroup();
            parser.gullet.endGroup();
            return {
              type: "array",
              mode: parser.mode,
              addJot,
              arraystretch,
              body,
              cols,
              rowGaps,
              hskipBeforeAndAfter,
              hLinesBeforeRow,
              colSeparationType,
              tags,
              leqno
            };
          }
          function dCellStyle2(envName) {
            if (envName.slice(0, 1) === "d") {
              return "display";
            } else {
              return "text";
            }
          }
          const array_htmlBuilder = function(group, options) {
            let r;
            let c;
            const nr = group.body.length;
            const hLinesBeforeRow = group.hLinesBeforeRow;
            let nc = 0;
            let body = new Array(nr);
            const hlines = [];
            const ruleThickness = Math.max(
              // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
              options.fontMetrics().arrayRuleWidth,
              options.minRuleThickness
              // User override.
            );
            const pt = 1 / options.fontMetrics().ptPerEm;
            let arraycolsep = 5 * pt;
            if (group.colSeparationType && group.colSeparationType === "small") {
              const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
              arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
            }
            const baselineskip = group.colSeparationType === "CD" ? calculateSize3({
              number: 3,
              unit: "ex"
            }, options) : 12 * pt;
            const jot = 3 * pt;
            const arrayskip = group.arraystretch * baselineskip;
            const arstrutHeight = 0.7 * arrayskip;
            const arstrutDepth = 0.3 * arrayskip;
            let totalHeight = 0;
            function setHLinePos(hlinesInGap) {
              for (let i = 0; i < hlinesInGap.length; ++i) {
                if (i > 0) {
                  totalHeight += 0.25;
                }
                hlines.push({
                  pos: totalHeight,
                  isDashed: hlinesInGap[i]
                });
              }
            }
            setHLinePos(hLinesBeforeRow[0]);
            for (r = 0; r < group.body.length; ++r) {
              const inrow = group.body[r];
              let height = arstrutHeight;
              let depth = arstrutDepth;
              if (nc < inrow.length) {
                nc = inrow.length;
              }
              const outrow = new Array(inrow.length);
              for (c = 0; c < inrow.length; ++c) {
                const elt = buildGroup4(inrow[c], options);
                if (depth < elt.depth) {
                  depth = elt.depth;
                }
                if (height < elt.height) {
                  height = elt.height;
                }
                outrow[c] = elt;
              }
              const rowGap = group.rowGaps[r];
              let gap = 0;
              if (rowGap) {
                gap = calculateSize3(rowGap, options);
                if (gap > 0) {
                  gap += arstrutDepth;
                  if (depth < gap) {
                    depth = gap;
                  }
                  gap = 0;
                }
              }
              if (group.addJot) {
                depth += jot;
              }
              outrow.height = height;
              outrow.depth = depth;
              totalHeight += height;
              outrow.pos = totalHeight;
              totalHeight += depth + gap;
              body[r] = outrow;
              setHLinePos(hLinesBeforeRow[r + 1]);
            }
            const offset = totalHeight / 2 + options.fontMetrics().axisHeight;
            const colDescriptions = group.cols || [];
            const cols = [];
            let colSep;
            let colDescrNum;
            const tagSpans = [];
            if (group.tags && group.tags.some((tag) => tag)) {
              for (r = 0; r < nr; ++r) {
                const rw = body[r];
                const shift = rw.pos - offset;
                const tag = group.tags[r];
                let tagSpan;
                if (tag === true) {
                  tagSpan = buildCommon2.makeSpan(["eqn-num"], [], options);
                } else if (tag === false) {
                  tagSpan = buildCommon2.makeSpan([], [], options);
                } else {
                  tagSpan = buildCommon2.makeSpan([], buildExpression4(tag, options, true), options);
                }
                tagSpan.depth = rw.depth;
                tagSpan.height = rw.height;
                tagSpans.push({
                  type: "elem",
                  elem: tagSpan,
                  shift
                });
              }
            }
            for (
              c = 0, colDescrNum = 0;
              // Continue while either there are more columns or more column
              // descriptions, so trailing separators don't get lost.
              c < nc || colDescrNum < colDescriptions.length;
              ++c, ++colDescrNum
            ) {
              let colDescr = colDescriptions[colDescrNum] || {};
              let firstSeparator = true;
              while (colDescr.type === "separator") {
                if (!firstSeparator) {
                  colSep = buildCommon2.makeSpan(["arraycolsep"], []);
                  colSep.style.width = makeEm3(options.fontMetrics().doubleRuleSep);
                  cols.push(colSep);
                }
                if (colDescr.separator === "|" || colDescr.separator === ":") {
                  const lineType = colDescr.separator === "|" ? "solid" : "dashed";
                  const separator = buildCommon2.makeSpan(["vertical-separator"], [], options);
                  separator.style.height = makeEm3(totalHeight);
                  separator.style.borderRightWidth = makeEm3(ruleThickness);
                  separator.style.borderRightStyle = lineType;
                  separator.style.margin = "0 " + makeEm3(-ruleThickness / 2);
                  const shift = totalHeight - offset;
                  if (shift) {
                    separator.style.verticalAlign = makeEm3(-shift);
                  }
                  cols.push(separator);
                } else {
                  throw new src_ParseError("Invalid separator type: " + colDescr.separator);
                }
                colDescrNum++;
                colDescr = colDescriptions[colDescrNum] || {};
                firstSeparator = false;
              }
              if (c >= nc) {
                continue;
              }
              let sepwidth;
              if (c > 0 || group.hskipBeforeAndAfter) {
                sepwidth = utils2.deflt(colDescr.pregap, arraycolsep);
                if (sepwidth !== 0) {
                  colSep = buildCommon2.makeSpan(["arraycolsep"], []);
                  colSep.style.width = makeEm3(sepwidth);
                  cols.push(colSep);
                }
              }
              let col = [];
              for (r = 0; r < nr; ++r) {
                const row = body[r];
                const elem = row[c];
                if (!elem) {
                  continue;
                }
                const shift = row.pos - offset;
                elem.depth = row.depth;
                elem.height = row.height;
                col.push({
                  type: "elem",
                  elem,
                  shift
                });
              }
              col = buildCommon2.makeVList({
                positionType: "individualShift",
                children: col
              }, options);
              col = buildCommon2.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
              cols.push(col);
              if (c < nc - 1 || group.hskipBeforeAndAfter) {
                sepwidth = utils2.deflt(colDescr.postgap, arraycolsep);
                if (sepwidth !== 0) {
                  colSep = buildCommon2.makeSpan(["arraycolsep"], []);
                  colSep.style.width = makeEm3(sepwidth);
                  cols.push(colSep);
                }
              }
            }
            body = buildCommon2.makeSpan(["mtable"], cols);
            if (hlines.length > 0) {
              const line = buildCommon2.makeLineSpan("hline", options, ruleThickness);
              const dashes = buildCommon2.makeLineSpan("hdashline", options, ruleThickness);
              const vListElems = [{
                type: "elem",
                elem: body,
                shift: 0
              }];
              while (hlines.length > 0) {
                const hline = hlines.pop();
                const lineShift = hline.pos - offset;
                if (hline.isDashed) {
                  vListElems.push({
                    type: "elem",
                    elem: dashes,
                    shift: lineShift
                  });
                } else {
                  vListElems.push({
                    type: "elem",
                    elem: line,
                    shift: lineShift
                  });
                }
              }
              body = buildCommon2.makeVList({
                positionType: "individualShift",
                children: vListElems
              }, options);
            }
            if (tagSpans.length === 0) {
              return buildCommon2.makeSpan(["mord"], [body], options);
            } else {
              let eqnNumCol = buildCommon2.makeVList({
                positionType: "individualShift",
                children: tagSpans
              }, options);
              eqnNumCol = buildCommon2.makeSpan(["tag"], [eqnNumCol], options);
              return buildCommon2.makeFragment([body, eqnNumCol]);
            }
          };
          const alignMap2 = {
            c: "center ",
            l: "left ",
            r: "right "
          };
          const array_mathmlBuilder = function(group, options) {
            const tbl = [];
            const glue = new mathMLTree2.MathNode("mtd", [], ["mtr-glue"]);
            const tag = new mathMLTree2.MathNode("mtd", [], ["mml-eqn-num"]);
            for (let i = 0; i < group.body.length; i++) {
              const rw = group.body[i];
              const row = [];
              for (let j = 0; j < rw.length; j++) {
                row.push(new mathMLTree2.MathNode("mtd", [buildMathML_buildGroup(rw[j], options)]));
              }
              if (group.tags && group.tags[i]) {
                row.unshift(glue);
                row.push(glue);
                if (group.leqno) {
                  row.unshift(tag);
                } else {
                  row.push(tag);
                }
              }
              tbl.push(new mathMLTree2.MathNode("mtr", row));
            }
            let table2 = new mathMLTree2.MathNode("mtable", tbl);
            const gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
            table2.setAttribute("rowspacing", makeEm3(gap));
            let menclose = "";
            let align = "";
            if (group.cols && group.cols.length > 0) {
              const cols = group.cols;
              let columnLines = "";
              let prevTypeWasAlign = false;
              let iStart = 0;
              let iEnd = cols.length;
              if (cols[0].type === "separator") {
                menclose += "top ";
                iStart = 1;
              }
              if (cols[cols.length - 1].type === "separator") {
                menclose += "bottom ";
                iEnd -= 1;
              }
              for (let i = iStart; i < iEnd; i++) {
                if (cols[i].type === "align") {
                  align += alignMap2[cols[i].align];
                  if (prevTypeWasAlign) {
                    columnLines += "none ";
                  }
                  prevTypeWasAlign = true;
                } else if (cols[i].type === "separator") {
                  if (prevTypeWasAlign) {
                    columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                    prevTypeWasAlign = false;
                  }
                }
              }
              table2.setAttribute("columnalign", align.trim());
              if (/[sd]/.test(columnLines)) {
                table2.setAttribute("columnlines", columnLines.trim());
              }
            }
            if (group.colSeparationType === "align") {
              const cols = group.cols || [];
              let spacing3 = "";
              for (let i = 1; i < cols.length; i++) {
                spacing3 += i % 2 ? "0em " : "1em ";
              }
              table2.setAttribute("columnspacing", spacing3.trim());
            } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
              table2.setAttribute("columnspacing", "0em");
            } else if (group.colSeparationType === "small") {
              table2.setAttribute("columnspacing", "0.2778em");
            } else if (group.colSeparationType === "CD") {
              table2.setAttribute("columnspacing", "0.5em");
            } else {
              table2.setAttribute("columnspacing", "1em");
            }
            let rowLines = "";
            const hlines = group.hLinesBeforeRow;
            menclose += hlines[0].length > 0 ? "left " : "";
            menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
            for (let i = 1; i < hlines.length - 1; i++) {
              rowLines += hlines[i].length === 0 ? "none " : hlines[i][0] ? "dashed " : "solid ";
            }
            if (/[sd]/.test(rowLines)) {
              table2.setAttribute("rowlines", rowLines.trim());
            }
            if (menclose !== "") {
              table2 = new mathMLTree2.MathNode("menclose", [table2]);
              table2.setAttribute("notation", menclose.trim());
            }
            if (group.arraystretch && group.arraystretch < 1) {
              table2 = new mathMLTree2.MathNode("mstyle", [table2]);
              table2.setAttribute("scriptlevel", "1");
            }
            return table2;
          };
          const alignedHandler3 = function(context, args) {
            if (context.envName.indexOf("ed") === -1) {
              validateAmsEnvironmentContext2(context);
            }
            const cols = [];
            const separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
            const isSplit = context.envName === "split";
            const res = parseArray2(context.parser, {
              cols,
              addJot: true,
              autoTag: isSplit ? void 0 : getAutoTag2(context.envName),
              emptySingleRow: true,
              colSeparationType: separationType,
              maxNumCols: isSplit ? 2 : void 0,
              leqno: context.parser.settings.leqno
            }, "display");
            let numMaths;
            let numCols = 0;
            const emptyGroup = {
              type: "ordgroup",
              mode: context.mode,
              body: []
            };
            if (args[0] && args[0].type === "ordgroup") {
              let arg0 = "";
              for (let i = 0; i < args[0].body.length; i++) {
                const textord3 = assertNodeType2(args[0].body[i], "textord");
                arg0 += textord3.text;
              }
              numMaths = Number(arg0);
              numCols = numMaths * 2;
            }
            const isAligned = !numCols;
            res.body.forEach(function(row) {
              for (let i = 1; i < row.length; i += 2) {
                const styling = assertNodeType2(row[i], "styling");
                const ordgroup = assertNodeType2(styling.body[0], "ordgroup");
                ordgroup.body.unshift(emptyGroup);
              }
              if (!isAligned) {
                const curMaths = row.length / 2;
                if (numMaths < curMaths) {
                  throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
                }
              } else if (numCols < row.length) {
                numCols = row.length;
              }
            });
            for (let i = 0; i < numCols; ++i) {
              let align = "r";
              let pregap = 0;
              if (i % 2 === 1) {
                align = "l";
              } else if (i > 0 && isAligned) {
                pregap = 1;
              }
              cols[i] = {
                type: "align",
                align,
                pregap,
                postgap: 0
              };
            }
            res.colSeparationType = isAligned ? "align" : "alignat";
            return res;
          };
          defineEnvironment2({
            type: "array",
            names: ["array", "darray"],
            props: {
              numArgs: 1
            },
            handler(context, args) {
              const symNode = checkSymbolNodeType2(args[0]);
              const colalign = symNode ? [args[0]] : assertNodeType2(args[0], "ordgroup").body;
              const cols = colalign.map(function(nde) {
                const node = assertSymbolNodeType2(nde);
                const ca = node.text;
                if ("lcr".indexOf(ca) !== -1) {
                  return {
                    type: "align",
                    align: ca
                  };
                } else if (ca === "|") {
                  return {
                    type: "separator",
                    separator: "|"
                  };
                } else if (ca === ":") {
                  return {
                    type: "separator",
                    separator: ":"
                  };
                }
                throw new src_ParseError("Unknown column alignment: " + ca, nde);
              });
              const res = {
                cols,
                hskipBeforeAndAfter: true,
                // \@preamble in lttab.dtx
                maxNumCols: cols.length
              };
              return parseArray2(context.parser, res, dCellStyle2(context.envName));
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
            props: {
              numArgs: 0
            },
            handler(context) {
              const delimiters3 = {
                "matrix": null,
                "pmatrix": ["(", ")"],
                "bmatrix": ["[", "]"],
                "Bmatrix": ["\\{", "\\}"],
                "vmatrix": ["|", "|"],
                "Vmatrix": ["\\Vert", "\\Vert"]
              }[context.envName.replace("*", "")];
              let colAlign = "c";
              const payload = {
                hskipBeforeAndAfter: false,
                cols: [{
                  type: "align",
                  align: colAlign
                }]
              };
              if (context.envName.charAt(context.envName.length - 1) === "*") {
                const parser = context.parser;
                parser.consumeSpaces();
                if (parser.fetch().text === "[") {
                  parser.consume();
                  parser.consumeSpaces();
                  colAlign = parser.fetch().text;
                  if ("lcr".indexOf(colAlign) === -1) {
                    throw new src_ParseError("Expected l or c or r", parser.nextToken);
                  }
                  parser.consume();
                  parser.consumeSpaces();
                  parser.expect("]");
                  parser.consume();
                  payload.cols = [{
                    type: "align",
                    align: colAlign
                  }];
                }
              }
              const res = parseArray2(context.parser, payload, dCellStyle2(context.envName));
              const numCols = Math.max(0, ...res.body.map((row) => row.length));
              res.cols = new Array(numCols).fill({
                type: "align",
                align: colAlign
              });
              return delimiters3 ? {
                type: "leftright",
                mode: context.mode,
                body: [res],
                left: delimiters3[0],
                right: delimiters3[1],
                rightColor: void 0
                // \right uninfluenced by \color in array
              } : res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["smallmatrix"],
            props: {
              numArgs: 0
            },
            handler(context) {
              const payload = {
                arraystretch: 0.5
              };
              const res = parseArray2(context.parser, payload, "script");
              res.colSeparationType = "small";
              return res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["subarray"],
            props: {
              numArgs: 1
            },
            handler(context, args) {
              const symNode = checkSymbolNodeType2(args[0]);
              const colalign = symNode ? [args[0]] : assertNodeType2(args[0], "ordgroup").body;
              const cols = colalign.map(function(nde) {
                const node = assertSymbolNodeType2(nde);
                const ca = node.text;
                if ("lc".indexOf(ca) !== -1) {
                  return {
                    type: "align",
                    align: ca
                  };
                }
                throw new src_ParseError("Unknown column alignment: " + ca, nde);
              });
              if (cols.length > 1) {
                throw new src_ParseError("{subarray} can contain only one column");
              }
              let res = {
                cols,
                hskipBeforeAndAfter: false,
                arraystretch: 0.5
              };
              res = parseArray2(context.parser, res, "script");
              if (res.body.length > 0 && res.body[0].length > 1) {
                throw new src_ParseError("{subarray} can contain only one column");
              }
              return res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["cases", "dcases", "rcases", "drcases"],
            props: {
              numArgs: 0
            },
            handler(context) {
              const payload = {
                arraystretch: 1.2,
                cols: [{
                  type: "align",
                  align: "l",
                  pregap: 0,
                  // TODO(kevinb) get the current style.
                  // For now we use the metrics for TEXT style which is what we were
                  // doing before.  Before attempting to get the current style we
                  // should look at TeX's behavior especially for \over and matrices.
                  postgap: 1
                  /* 1em quad */
                }, {
                  type: "align",
                  align: "l",
                  pregap: 0,
                  postgap: 0
                }]
              };
              const res = parseArray2(context.parser, payload, dCellStyle2(context.envName));
              return {
                type: "leftright",
                mode: context.mode,
                body: [res],
                left: context.envName.indexOf("r") > -1 ? "." : "\\{",
                right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
                rightColor: void 0
              };
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["align", "align*", "aligned", "split"],
            props: {
              numArgs: 0
            },
            handler: alignedHandler3,
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["gathered", "gather", "gather*"],
            props: {
              numArgs: 0
            },
            handler(context) {
              if (["gather", "gather*"].includes(context.envName)) {
                validateAmsEnvironmentContext2(context);
              }
              const res = {
                cols: [{
                  type: "align",
                  align: "c"
                }],
                addJot: true,
                colSeparationType: "gather",
                autoTag: getAutoTag2(context.envName),
                emptySingleRow: true,
                leqno: context.parser.settings.leqno
              };
              return parseArray2(context.parser, res, "display");
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["alignat", "alignat*", "alignedat"],
            props: {
              numArgs: 1
            },
            handler: alignedHandler3,
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["equation", "equation*"],
            props: {
              numArgs: 0
            },
            handler(context) {
              validateAmsEnvironmentContext2(context);
              const res = {
                autoTag: getAutoTag2(context.envName),
                emptySingleRow: true,
                singleRow: true,
                maxNumCols: 1,
                leqno: context.parser.settings.leqno
              };
              return parseArray2(context.parser, res, "display");
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment2({
            type: "array",
            names: ["CD"],
            props: {
              numArgs: 0
            },
            handler(context) {
              validateAmsEnvironmentContext2(context);
              return parseCD2(context.parser);
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineMacro2("\\nonumber", "\\gdef\\@eqnsw{0}");
          defineMacro2("\\notag", "\\nonumber");
          defineFunction2({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\hline", "\\hdashline"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: true
            },
            handler(context, args) {
              throw new src_ParseError(context.funcName + " valid only within array environment");
            }
          });
          const environments2 = _environments2;
          var src_environments = environments2;
          defineFunction2({
            type: "environment",
            names: ["\\begin", "\\end"],
            props: {
              numArgs: 1,
              argTypes: ["text"]
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const nameGroup = args[0];
              if (nameGroup.type !== "ordgroup") {
                throw new src_ParseError("Invalid environment name", nameGroup);
              }
              let envName = "";
              for (let i = 0; i < nameGroup.body.length; ++i) {
                envName += assertNodeType2(nameGroup.body[i], "textord").text;
              }
              if (funcName === "\\begin") {
                if (!src_environments.hasOwnProperty(envName)) {
                  throw new src_ParseError("No such environment: " + envName, nameGroup);
                }
                const env = src_environments[envName];
                const {
                  args: args2,
                  optArgs
                } = parser.parseArguments("\\begin{" + envName + "}", env);
                const context = {
                  mode: parser.mode,
                  envName,
                  parser
                };
                const result = env.handler(context, args2, optArgs);
                parser.expect("\\end", false);
                const endNameToken = parser.nextToken;
                const end = assertNodeType2(parser.parseFunction(), "environment");
                if (end.name !== envName) {
                  throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
                }
                return result;
              }
              return {
                type: "environment",
                mode: parser.mode,
                name: envName,
                nameGroup
              };
            }
          });
          const font_htmlBuilder = (group, options) => {
            const font = group.font;
            const newOptions = options.withFont(font);
            return buildGroup4(group.body, newOptions);
          };
          const font_mathmlBuilder = (group, options) => {
            const font = group.font;
            const newOptions = options.withFont(font);
            return buildMathML_buildGroup(group.body, newOptions);
          };
          const fontAliases2 = {
            "\\Bbb": "\\mathbb",
            "\\bold": "\\mathbf",
            "\\frak": "\\mathfrak",
            "\\bm": "\\boldsymbol"
          };
          defineFunction2({
            type: "font",
            names: [
              // styles, except \boldsymbol defined below
              "\\mathrm",
              "\\mathit",
              "\\mathbf",
              "\\mathnormal",
              "\\mathsfit",
              // families
              "\\mathbb",
              "\\mathcal",
              "\\mathfrak",
              "\\mathscr",
              "\\mathsf",
              "\\mathtt",
              // aliases, except \bm defined below
              "\\Bbb",
              "\\bold",
              "\\frak"
            ],
            props: {
              numArgs: 1,
              allowedInArgument: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const body = normalizeArgument3(args[0]);
              let func = funcName;
              if (func in fontAliases2) {
                func = fontAliases2[func];
              }
              return {
                type: "font",
                mode: parser.mode,
                font: func.slice(1),
                body
              };
            },
            htmlBuilder: font_htmlBuilder,
            mathmlBuilder: font_mathmlBuilder
          });
          defineFunction2({
            type: "mclass",
            names: ["\\boldsymbol", "\\bm"],
            props: {
              numArgs: 1
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const body = args[0];
              const isCharacterBox4 = utils2.isCharacterBox(body);
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: binrelClass2(body),
                body: [{
                  type: "font",
                  mode: parser.mode,
                  font: "boldsymbol",
                  body
                }],
                isCharacterBox: isCharacterBox4
              };
            }
          });
          defineFunction2({
            type: "font",
            names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (_ref3, args) => {
              let {
                parser,
                funcName,
                breakOnTokenText
              } = _ref3;
              const {
                mode
              } = parser;
              const body = parser.parseExpression(true, breakOnTokenText);
              const style = "math" + funcName.slice(1);
              return {
                type: "font",
                mode,
                font: style,
                body: {
                  type: "ordgroup",
                  mode: parser.mode,
                  body
                }
              };
            },
            htmlBuilder: font_htmlBuilder,
            mathmlBuilder: font_mathmlBuilder
          });
          const adjustStyle2 = (size, originalStyle) => {
            let style = originalStyle;
            if (size === "display") {
              style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
            } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
              style = src_Style.TEXT;
            } else if (size === "script") {
              style = src_Style.SCRIPT;
            } else if (size === "scriptscript") {
              style = src_Style.SCRIPTSCRIPT;
            }
            return style;
          };
          const genfrac_htmlBuilder = (group, options) => {
            const style = adjustStyle2(group.size, options.style);
            const nstyle = style.fracNum();
            const dstyle = style.fracDen();
            let newOptions;
            newOptions = options.havingStyle(nstyle);
            const numerm = buildGroup4(group.numer, newOptions, options);
            if (group.continued) {
              const hStrut = 8.5 / options.fontMetrics().ptPerEm;
              const dStrut = 3.5 / options.fontMetrics().ptPerEm;
              numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
              numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
            }
            newOptions = options.havingStyle(dstyle);
            const denomm = buildGroup4(group.denom, newOptions, options);
            let rule;
            let ruleWidth;
            let ruleSpacing;
            if (group.hasBarLine) {
              if (group.barSize) {
                ruleWidth = calculateSize3(group.barSize, options);
                rule = buildCommon2.makeLineSpan("frac-line", options, ruleWidth);
              } else {
                rule = buildCommon2.makeLineSpan("frac-line", options);
              }
              ruleWidth = rule.height;
              ruleSpacing = rule.height;
            } else {
              rule = null;
              ruleWidth = 0;
              ruleSpacing = options.fontMetrics().defaultRuleThickness;
            }
            let numShift;
            let clearance;
            let denomShift;
            if (style.size === src_Style.DISPLAY.size || group.size === "display") {
              numShift = options.fontMetrics().num1;
              if (ruleWidth > 0) {
                clearance = 3 * ruleSpacing;
              } else {
                clearance = 7 * ruleSpacing;
              }
              denomShift = options.fontMetrics().denom1;
            } else {
              if (ruleWidth > 0) {
                numShift = options.fontMetrics().num2;
                clearance = ruleSpacing;
              } else {
                numShift = options.fontMetrics().num3;
                clearance = 3 * ruleSpacing;
              }
              denomShift = options.fontMetrics().denom2;
            }
            let frac;
            if (!rule) {
              const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
              if (candidateClearance < clearance) {
                numShift += 0.5 * (clearance - candidateClearance);
                denomShift += 0.5 * (clearance - candidateClearance);
              }
              frac = buildCommon2.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: denomm,
                  shift: denomShift
                }, {
                  type: "elem",
                  elem: numerm,
                  shift: -numShift
                }]
              }, options);
            } else {
              const axisHeight = options.fontMetrics().axisHeight;
              if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
                numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
              }
              if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
                denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
              }
              const midShift = -(axisHeight - 0.5 * ruleWidth);
              frac = buildCommon2.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: denomm,
                  shift: denomShift
                }, {
                  type: "elem",
                  elem: rule,
                  shift: midShift
                }, {
                  type: "elem",
                  elem: numerm,
                  shift: -numShift
                }]
              }, options);
            }
            newOptions = options.havingStyle(style);
            frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
            frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
            let delimSize;
            if (style.size === src_Style.DISPLAY.size) {
              delimSize = options.fontMetrics().delim1;
            } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
              delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
            } else {
              delimSize = options.fontMetrics().delim2;
            }
            let leftDelim;
            let rightDelim;
            if (group.leftDelim == null) {
              leftDelim = makeNullDelimiter3(options, ["mopen"]);
            } else {
              leftDelim = delimiter2.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
            }
            if (group.continued) {
              rightDelim = buildCommon2.makeSpan([]);
            } else if (group.rightDelim == null) {
              rightDelim = makeNullDelimiter3(options, ["mclose"]);
            } else {
              rightDelim = delimiter2.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
            }
            return buildCommon2.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon2.makeSpan(["mfrac"], [frac]), rightDelim], options);
          };
          const genfrac_mathmlBuilder = (group, options) => {
            let node = new mathMLTree2.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
            if (!group.hasBarLine) {
              node.setAttribute("linethickness", "0px");
            } else if (group.barSize) {
              const ruleWidth = calculateSize3(group.barSize, options);
              node.setAttribute("linethickness", makeEm3(ruleWidth));
            }
            const style = adjustStyle2(group.size, options.style);
            if (style.size !== options.style.size) {
              node = new mathMLTree2.MathNode("mstyle", [node]);
              const isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
              node.setAttribute("displaystyle", isDisplay);
              node.setAttribute("scriptlevel", "0");
            }
            if (group.leftDelim != null || group.rightDelim != null) {
              const withDelims = [];
              if (group.leftDelim != null) {
                const leftOp = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode(group.leftDelim.replace("\\", ""))]);
                leftOp.setAttribute("fence", "true");
                withDelims.push(leftOp);
              }
              withDelims.push(node);
              if (group.rightDelim != null) {
                const rightOp = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode(group.rightDelim.replace("\\", ""))]);
                rightOp.setAttribute("fence", "true");
                withDelims.push(rightOp);
              }
              return makeRow3(withDelims);
            }
            return node;
          };
          defineFunction2({
            type: "genfrac",
            names: [
              "\\dfrac",
              "\\frac",
              "\\tfrac",
              "\\dbinom",
              "\\binom",
              "\\tbinom",
              "\\\\atopfrac",
              // cant be entered directly
              "\\\\bracefrac",
              "\\\\brackfrac"
              // ditto
            ],
            props: {
              numArgs: 2,
              allowedInArgument: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const numer = args[0];
              const denom = args[1];
              let hasBarLine;
              let leftDelim = null;
              let rightDelim = null;
              let size = "auto";
              switch (funcName) {
                case "\\dfrac":
                case "\\frac":
                case "\\tfrac":
                  hasBarLine = true;
                  break;
                case "\\\\atopfrac":
                  hasBarLine = false;
                  break;
                case "\\dbinom":
                case "\\binom":
                case "\\tbinom":
                  hasBarLine = false;
                  leftDelim = "(";
                  rightDelim = ")";
                  break;
                case "\\\\bracefrac":
                  hasBarLine = false;
                  leftDelim = "\\{";
                  rightDelim = "\\}";
                  break;
                case "\\\\brackfrac":
                  hasBarLine = false;
                  leftDelim = "[";
                  rightDelim = "]";
                  break;
                default:
                  throw new Error("Unrecognized genfrac command");
              }
              switch (funcName) {
                case "\\dfrac":
                case "\\dbinom":
                  size = "display";
                  break;
                case "\\tfrac":
                case "\\tbinom":
                  size = "text";
                  break;
              }
              return {
                type: "genfrac",
                mode: parser.mode,
                continued: false,
                numer,
                denom,
                hasBarLine,
                leftDelim,
                rightDelim,
                size,
                barSize: null
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          defineFunction2({
            type: "genfrac",
            names: ["\\cfrac"],
            props: {
              numArgs: 2
            },
            handler: (_ref2, args) => {
              let {
                parser,
                funcName
              } = _ref2;
              const numer = args[0];
              const denom = args[1];
              return {
                type: "genfrac",
                mode: parser.mode,
                continued: true,
                numer,
                denom,
                hasBarLine: true,
                leftDelim: null,
                rightDelim: null,
                size: "display",
                barSize: null
              };
            }
          });
          defineFunction2({
            type: "infix",
            names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
            props: {
              numArgs: 0,
              infix: true
            },
            handler(_ref3) {
              let {
                parser,
                funcName,
                token
              } = _ref3;
              let replaceWith;
              switch (funcName) {
                case "\\over":
                  replaceWith = "\\frac";
                  break;
                case "\\choose":
                  replaceWith = "\\binom";
                  break;
                case "\\atop":
                  replaceWith = "\\\\atopfrac";
                  break;
                case "\\brace":
                  replaceWith = "\\\\bracefrac";
                  break;
                case "\\brack":
                  replaceWith = "\\\\brackfrac";
                  break;
                default:
                  throw new Error("Unrecognized infix genfrac command");
              }
              return {
                type: "infix",
                mode: parser.mode,
                replaceWith,
                token
              };
            }
          });
          const stylArray2 = ["display", "text", "script", "scriptscript"];
          const delimFromValue3 = function(delimString) {
            let delim = null;
            if (delimString.length > 0) {
              delim = delimString;
              delim = delim === "." ? null : delim;
            }
            return delim;
          };
          defineFunction2({
            type: "genfrac",
            names: ["\\genfrac"],
            props: {
              numArgs: 6,
              allowedInArgument: true,
              argTypes: ["math", "math", "size", "text", "math", "math"]
            },
            handler(_ref4, args) {
              let {
                parser
              } = _ref4;
              const numer = args[4];
              const denom = args[5];
              const leftNode = normalizeArgument3(args[0]);
              const leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue3(leftNode.text) : null;
              const rightNode = normalizeArgument3(args[1]);
              const rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue3(rightNode.text) : null;
              const barNode = assertNodeType2(args[2], "size");
              let hasBarLine;
              let barSize = null;
              if (barNode.isBlank) {
                hasBarLine = true;
              } else {
                barSize = barNode.value;
                hasBarLine = barSize.number > 0;
              }
              let size = "auto";
              let styl = args[3];
              if (styl.type === "ordgroup") {
                if (styl.body.length > 0) {
                  const textOrd = assertNodeType2(styl.body[0], "textord");
                  size = stylArray2[Number(textOrd.text)];
                }
              } else {
                styl = assertNodeType2(styl, "textord");
                size = stylArray2[Number(styl.text)];
              }
              return {
                type: "genfrac",
                mode: parser.mode,
                numer,
                denom,
                continued: false,
                hasBarLine,
                barSize,
                leftDelim,
                rightDelim,
                size
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          defineFunction2({
            type: "infix",
            names: ["\\above"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              infix: true
            },
            handler(_ref5, args) {
              let {
                parser,
                funcName,
                token
              } = _ref5;
              return {
                type: "infix",
                mode: parser.mode,
                replaceWith: "\\\\abovefrac",
                size: assertNodeType2(args[0], "size").value,
                token
              };
            }
          });
          defineFunction2({
            type: "genfrac",
            names: ["\\\\abovefrac"],
            props: {
              numArgs: 3,
              argTypes: ["math", "size", "math"]
            },
            handler: (_ref6, args) => {
              let {
                parser,
                funcName
              } = _ref6;
              const numer = args[0];
              const barSize = assert3(assertNodeType2(args[1], "infix").size);
              const denom = args[2];
              const hasBarLine = barSize.number > 0;
              return {
                type: "genfrac",
                mode: parser.mode,
                numer,
                denom,
                continued: false,
                hasBarLine,
                barSize,
                leftDelim: null,
                rightDelim: null,
                size: "auto"
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          const horizBrace_htmlBuilder = (grp, options) => {
            const style = options.style;
            let supSubGroup;
            let group;
            if (grp.type === "supsub") {
              supSubGroup = grp.sup ? buildGroup4(grp.sup, options.havingStyle(style.sup()), options) : buildGroup4(grp.sub, options.havingStyle(style.sub()), options);
              group = assertNodeType2(grp.base, "horizBrace");
            } else {
              group = assertNodeType2(grp, "horizBrace");
            }
            const body = buildGroup4(group.base, options.havingBaseStyle(src_Style.DISPLAY));
            const braceBody = stretchy2.svgSpan(group, options);
            let vlist;
            if (group.isOver) {
              vlist = buildCommon2.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "kern",
                  size: 0.1
                }, {
                  type: "elem",
                  elem: braceBody
                }]
              }, options);
              vlist.children[0].children[0].children[1].classes.push("svg-align");
            } else {
              vlist = buildCommon2.makeVList({
                positionType: "bottom",
                positionData: body.depth + 0.1 + braceBody.height,
                children: [{
                  type: "elem",
                  elem: braceBody
                }, {
                  type: "kern",
                  size: 0.1
                }, {
                  type: "elem",
                  elem: body
                }]
              }, options);
              vlist.children[0].children[0].children[0].classes.push("svg-align");
            }
            if (supSubGroup) {
              const vSpan = buildCommon2.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
              if (group.isOver) {
                vlist = buildCommon2.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: vSpan
                  }, {
                    type: "kern",
                    size: 0.2
                  }, {
                    type: "elem",
                    elem: supSubGroup
                  }]
                }, options);
              } else {
                vlist = buildCommon2.makeVList({
                  positionType: "bottom",
                  positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                  children: [{
                    type: "elem",
                    elem: supSubGroup
                  }, {
                    type: "kern",
                    size: 0.2
                  }, {
                    type: "elem",
                    elem: vSpan
                  }]
                }, options);
              }
            }
            return buildCommon2.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
          };
          const horizBrace_mathmlBuilder = (group, options) => {
            const accentNode = stretchy2.mathMLnode(group.label);
            return new mathMLTree2.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
          };
          defineFunction2({
            type: "horizBrace",
            names: ["\\overbrace", "\\underbrace"],
            props: {
              numArgs: 1
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              return {
                type: "horizBrace",
                mode: parser.mode,
                label: funcName,
                isOver: /^\\over/.test(funcName),
                base: args[0]
              };
            },
            htmlBuilder: horizBrace_htmlBuilder,
            mathmlBuilder: horizBrace_mathmlBuilder
          });
          defineFunction2({
            type: "href",
            names: ["\\href"],
            props: {
              numArgs: 2,
              argTypes: ["url", "original"],
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              const body = args[1];
              const href = assertNodeType2(args[0], "url").url;
              if (!parser.settings.isTrusted({
                command: "\\href",
                url: href
              })) {
                return parser.formatUnsupportedCmd("\\href");
              }
              return {
                type: "href",
                mode: parser.mode,
                href,
                body: ordargument3(body)
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression4(group.body, options, false);
              return buildCommon2.makeAnchor(group.href, [], elements, options);
            },
            mathmlBuilder: (group, options) => {
              let math3 = buildExpressionRow3(group.body, options);
              if (!(math3 instanceof MathNode2)) {
                math3 = new MathNode2("mrow", [math3]);
              }
              math3.setAttribute("href", group.href);
              return math3;
            }
          });
          defineFunction2({
            type: "href",
            names: ["\\url"],
            props: {
              numArgs: 1,
              argTypes: ["url"],
              allowedInText: true
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const href = assertNodeType2(args[0], "url").url;
              if (!parser.settings.isTrusted({
                command: "\\url",
                url: href
              })) {
                return parser.formatUnsupportedCmd("\\url");
              }
              const chars = [];
              for (let i = 0; i < href.length; i++) {
                let c = href[i];
                if (c === "~") {
                  c = "\\textasciitilde";
                }
                chars.push({
                  type: "textord",
                  mode: "text",
                  text: c
                });
              }
              const body = {
                type: "text",
                mode: parser.mode,
                font: "\\texttt",
                body: chars
              };
              return {
                type: "href",
                mode: parser.mode,
                href,
                body: ordargument3(body)
              };
            }
          });
          defineFunction2({
            type: "hbox",
            names: ["\\hbox"],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInText: true,
              primitive: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "hbox",
                mode: parser.mode,
                body: ordargument3(args[0])
              };
            },
            htmlBuilder(group, options) {
              const elements = buildExpression4(group.body, options, false);
              return buildCommon2.makeFragment(elements);
            },
            mathmlBuilder(group, options) {
              return new mathMLTree2.MathNode("mrow", buildMathML_buildExpression(group.body, options));
            }
          });
          defineFunction2({
            type: "html",
            names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
            props: {
              numArgs: 2,
              argTypes: ["raw", "original"],
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName,
                token
              } = _ref;
              const value = assertNodeType2(args[0], "raw").string;
              const body = args[1];
              if (parser.settings.strict) {
                parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
              }
              let trustContext;
              const attributes = {};
              switch (funcName) {
                case "\\htmlClass":
                  attributes.class = value;
                  trustContext = {
                    command: "\\htmlClass",
                    class: value
                  };
                  break;
                case "\\htmlId":
                  attributes.id = value;
                  trustContext = {
                    command: "\\htmlId",
                    id: value
                  };
                  break;
                case "\\htmlStyle":
                  attributes.style = value;
                  trustContext = {
                    command: "\\htmlStyle",
                    style: value
                  };
                  break;
                case "\\htmlData": {
                  const data = value.split(",");
                  for (let i = 0; i < data.length; i++) {
                    const item = data[i];
                    const firstEquals = item.indexOf("=");
                    if (firstEquals < 0) {
                      throw new src_ParseError("\\htmlData key/value '" + item + "' missing equals sign");
                    }
                    const key = item.slice(0, firstEquals);
                    const value2 = item.slice(firstEquals + 1);
                    attributes["data-" + key.trim()] = value2;
                  }
                  trustContext = {
                    command: "\\htmlData",
                    attributes
                  };
                  break;
                }
                default:
                  throw new Error("Unrecognized html command");
              }
              if (!parser.settings.isTrusted(trustContext)) {
                return parser.formatUnsupportedCmd(funcName);
              }
              return {
                type: "html",
                mode: parser.mode,
                attributes,
                body: ordargument3(body)
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression4(group.body, options, false);
              const classes = ["enclosing"];
              if (group.attributes.class) {
                classes.push(...group.attributes.class.trim().split(/\s+/));
              }
              const span = buildCommon2.makeSpan(classes, elements, options);
              for (const attr in group.attributes) {
                if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
                  span.setAttribute(attr, group.attributes[attr]);
                }
              }
              return span;
            },
            mathmlBuilder: (group, options) => {
              return buildExpressionRow3(group.body, options);
            }
          });
          defineFunction2({
            type: "htmlmathml",
            names: ["\\html@mathml"],
            props: {
              numArgs: 2,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              return {
                type: "htmlmathml",
                mode: parser.mode,
                html: ordargument3(args[0]),
                mathml: ordargument3(args[1])
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression4(group.html, options, false);
              return buildCommon2.makeFragment(elements);
            },
            mathmlBuilder: (group, options) => {
              return buildExpressionRow3(group.mathml, options);
            }
          });
          const sizeData3 = function(str) {
            if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
              return {
                number: +str,
                unit: "bp"
              };
            } else {
              const match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
              if (!match2) {
                throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
              }
              const data = {
                number: +(match2[1] + match2[2]),
                // sign + magnitude, cast to number
                unit: match2[3]
              };
              if (!validUnit3(data)) {
                throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
              }
              return data;
            }
          };
          defineFunction2({
            type: "includegraphics",
            names: ["\\includegraphics"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              argTypes: ["raw", "url"],
              allowedInText: false
            },
            handler: (_ref, args, optArgs) => {
              let {
                parser
              } = _ref;
              let width = {
                number: 0,
                unit: "em"
              };
              let height = {
                number: 0.9,
                unit: "em"
              };
              let totalheight = {
                number: 0,
                unit: "em"
              };
              let alt = "";
              if (optArgs[0]) {
                const attributeStr = assertNodeType2(optArgs[0], "raw").string;
                const attributes = attributeStr.split(",");
                for (let i = 0; i < attributes.length; i++) {
                  const keyVal = attributes[i].split("=");
                  if (keyVal.length === 2) {
                    const str = keyVal[1].trim();
                    switch (keyVal[0].trim()) {
                      case "alt":
                        alt = str;
                        break;
                      case "width":
                        width = sizeData3(str);
                        break;
                      case "height":
                        height = sizeData3(str);
                        break;
                      case "totalheight":
                        totalheight = sizeData3(str);
                        break;
                      default:
                        throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                    }
                  }
                }
              }
              const src = assertNodeType2(args[0], "url").url;
              if (alt === "") {
                alt = src;
                alt = alt.replace(/^.*[\\/]/, "");
                alt = alt.substring(0, alt.lastIndexOf("."));
              }
              if (!parser.settings.isTrusted({
                command: "\\includegraphics",
                url: src
              })) {
                return parser.formatUnsupportedCmd("\\includegraphics");
              }
              return {
                type: "includegraphics",
                mode: parser.mode,
                alt,
                width,
                height,
                totalheight,
                src
              };
            },
            htmlBuilder: (group, options) => {
              const height = calculateSize3(group.height, options);
              let depth = 0;
              if (group.totalheight.number > 0) {
                depth = calculateSize3(group.totalheight, options) - height;
              }
              let width = 0;
              if (group.width.number > 0) {
                width = calculateSize3(group.width, options);
              }
              const style = {
                height: makeEm3(height + depth)
              };
              if (width > 0) {
                style.width = makeEm3(width);
              }
              if (depth > 0) {
                style.verticalAlign = makeEm3(-depth);
              }
              const node = new Img2(group.src, group.alt, style);
              node.height = height;
              node.depth = depth;
              return node;
            },
            mathmlBuilder: (group, options) => {
              const node = new mathMLTree2.MathNode("mglyph", []);
              node.setAttribute("alt", group.alt);
              const height = calculateSize3(group.height, options);
              let depth = 0;
              if (group.totalheight.number > 0) {
                depth = calculateSize3(group.totalheight, options) - height;
                node.setAttribute("valign", makeEm3(-depth));
              }
              node.setAttribute("height", makeEm3(height + depth));
              if (group.width.number > 0) {
                const width = calculateSize3(group.width, options);
                node.setAttribute("width", makeEm3(width));
              }
              node.setAttribute("src", group.src);
              return node;
            }
          });
          defineFunction2({
            type: "kern",
            names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              primitive: true,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const size = assertNodeType2(args[0], "size");
              if (parser.settings.strict) {
                const mathFunction = funcName[1] === "m";
                const muUnit = size.value.unit === "mu";
                if (mathFunction) {
                  if (!muUnit) {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                  }
                  if (parser.mode !== "math") {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                  }
                } else {
                  if (muUnit) {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                  }
                }
              }
              return {
                type: "kern",
                mode: parser.mode,
                dimension: size.value
              };
            },
            htmlBuilder(group, options) {
              return buildCommon2.makeGlue(group.dimension, options);
            },
            mathmlBuilder(group, options) {
              const dimension = calculateSize3(group.dimension, options);
              return new mathMLTree2.SpaceNode(dimension);
            }
          });
          defineFunction2({
            type: "lap",
            names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "lap",
                mode: parser.mode,
                alignment: funcName.slice(5),
                body
              };
            },
            htmlBuilder: (group, options) => {
              let inner3;
              if (group.alignment === "clap") {
                inner3 = buildCommon2.makeSpan([], [buildGroup4(group.body, options)]);
                inner3 = buildCommon2.makeSpan(["inner"], [inner3], options);
              } else {
                inner3 = buildCommon2.makeSpan(["inner"], [buildGroup4(group.body, options)]);
              }
              const fix = buildCommon2.makeSpan(["fix"], []);
              let node = buildCommon2.makeSpan([group.alignment], [inner3, fix], options);
              const strut = buildCommon2.makeSpan(["strut"]);
              strut.style.height = makeEm3(node.height + node.depth);
              if (node.depth) {
                strut.style.verticalAlign = makeEm3(-node.depth);
              }
              node.children.unshift(strut);
              node = buildCommon2.makeSpan(["thinbox"], [node], options);
              return buildCommon2.makeSpan(["mord", "vbox"], [node], options);
            },
            mathmlBuilder: (group, options) => {
              const node = new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              if (group.alignment !== "rlap") {
                const offset = group.alignment === "llap" ? "-1" : "-0.5";
                node.setAttribute("lspace", offset + "width");
              }
              node.setAttribute("width", "0px");
              return node;
            }
          });
          defineFunction2({
            type: "styling",
            names: ["\\(", "$"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(_ref, args) {
              let {
                funcName,
                parser
              } = _ref;
              const outerMode = parser.mode;
              parser.switchMode("math");
              const close2 = funcName === "\\(" ? "\\)" : "$";
              const body = parser.parseExpression(false, close2);
              parser.expect(close2);
              parser.switchMode(outerMode);
              return {
                type: "styling",
                mode: parser.mode,
                style: "text",
                body
              };
            }
          });
          defineFunction2({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\)", "\\]"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(context, args) {
              throw new src_ParseError("Mismatched " + context.funcName);
            }
          });
          const chooseMathStyle2 = (group, options) => {
            switch (options.style.size) {
              case src_Style.DISPLAY.size:
                return group.display;
              case src_Style.TEXT.size:
                return group.text;
              case src_Style.SCRIPT.size:
                return group.script;
              case src_Style.SCRIPTSCRIPT.size:
                return group.scriptscript;
              default:
                return group.text;
            }
          };
          defineFunction2({
            type: "mathchoice",
            names: ["\\mathchoice"],
            props: {
              numArgs: 4,
              primitive: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              return {
                type: "mathchoice",
                mode: parser.mode,
                display: ordargument3(args[0]),
                text: ordargument3(args[1]),
                script: ordargument3(args[2]),
                scriptscript: ordargument3(args[3])
              };
            },
            htmlBuilder: (group, options) => {
              const body = chooseMathStyle2(group, options);
              const elements = buildExpression4(body, options, false);
              return buildCommon2.makeFragment(elements);
            },
            mathmlBuilder: (group, options) => {
              const body = chooseMathStyle2(group, options);
              return buildExpressionRow3(body, options);
            }
          });
          const assembleSupSub2 = (base2, supGroup, subGroup, options, style, slant, baseShift) => {
            base2 = buildCommon2.makeSpan([], [base2]);
            const subIsSingleCharacter = subGroup && utils2.isCharacterBox(subGroup);
            let sub3;
            let sup3;
            if (supGroup) {
              const elem = buildGroup4(supGroup, options.havingStyle(style.sup()), options);
              sup3 = {
                elem,
                kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
              };
            }
            if (subGroup) {
              const elem = buildGroup4(subGroup, options.havingStyle(style.sub()), options);
              sub3 = {
                elem,
                kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
              };
            }
            let finalGroup;
            if (sup3 && sub3) {
              const bottom = options.fontMetrics().bigOpSpacing5 + sub3.elem.height + sub3.elem.depth + sub3.kern + base2.depth + baseShift;
              finalGroup = buildCommon2.makeVList({
                positionType: "bottom",
                positionData: bottom,
                children: [{
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: sub3.elem,
                  marginLeft: makeEm3(-slant)
                }, {
                  type: "kern",
                  size: sub3.kern
                }, {
                  type: "elem",
                  elem: base2
                }, {
                  type: "kern",
                  size: sup3.kern
                }, {
                  type: "elem",
                  elem: sup3.elem,
                  marginLeft: makeEm3(slant)
                }, {
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }]
              }, options);
            } else if (sub3) {
              const top = base2.height - baseShift;
              finalGroup = buildCommon2.makeVList({
                positionType: "top",
                positionData: top,
                children: [{
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: sub3.elem,
                  marginLeft: makeEm3(-slant)
                }, {
                  type: "kern",
                  size: sub3.kern
                }, {
                  type: "elem",
                  elem: base2
                }]
              }, options);
            } else if (sup3) {
              const bottom = base2.depth + baseShift;
              finalGroup = buildCommon2.makeVList({
                positionType: "bottom",
                positionData: bottom,
                children: [{
                  type: "elem",
                  elem: base2
                }, {
                  type: "kern",
                  size: sup3.kern
                }, {
                  type: "elem",
                  elem: sup3.elem,
                  marginLeft: makeEm3(slant)
                }, {
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }]
              }, options);
            } else {
              return base2;
            }
            const parts = [finalGroup];
            if (sub3 && slant !== 0 && !subIsSingleCharacter) {
              const spacer = buildCommon2.makeSpan(["mspace"], [], options);
              spacer.style.marginRight = makeEm3(slant);
              parts.unshift(spacer);
            }
            return buildCommon2.makeSpan(["mop", "op-limits"], parts, options);
          };
          const noSuccessor2 = ["\\smallint"];
          const op_htmlBuilder = (grp, options) => {
            let supGroup;
            let subGroup;
            let hasLimits = false;
            let group;
            if (grp.type === "supsub") {
              supGroup = grp.sup;
              subGroup = grp.sub;
              group = assertNodeType2(grp.base, "op");
              hasLimits = true;
            } else {
              group = assertNodeType2(grp, "op");
            }
            const style = options.style;
            let large = false;
            if (style.size === src_Style.DISPLAY.size && group.symbol && !noSuccessor2.includes(group.name)) {
              large = true;
            }
            let base2;
            if (group.symbol) {
              const fontName = large ? "Size2-Regular" : "Size1-Regular";
              let stash = "";
              if (group.name === "\\oiint" || group.name === "\\oiiint") {
                stash = group.name.slice(1);
                group.name = stash === "oiint" ? "\\iint" : "\\iiint";
              }
              base2 = buildCommon2.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
              if (stash.length > 0) {
                const italic = base2.italic;
                const oval = buildCommon2.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
                base2 = buildCommon2.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: base2,
                    shift: 0
                  }, {
                    type: "elem",
                    elem: oval,
                    shift: large ? 0.08 : 0
                  }]
                }, options);
                group.name = "\\" + stash;
                base2.classes.unshift("mop");
                base2.italic = italic;
              }
            } else if (group.body) {
              const inner3 = buildExpression4(group.body, options, true);
              if (inner3.length === 1 && inner3[0] instanceof SymbolNode2) {
                base2 = inner3[0];
                base2.classes[0] = "mop";
              } else {
                base2 = buildCommon2.makeSpan(["mop"], inner3, options);
              }
            } else {
              const output = [];
              for (let i = 1; i < group.name.length; i++) {
                output.push(buildCommon2.mathsym(group.name[i], group.mode, options));
              }
              base2 = buildCommon2.makeSpan(["mop"], output, options);
            }
            let baseShift = 0;
            let slant = 0;
            if ((base2 instanceof SymbolNode2 || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
              baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
              slant = base2.italic;
            }
            if (hasLimits) {
              return assembleSupSub2(base2, supGroup, subGroup, options, style, slant, baseShift);
            } else {
              if (baseShift) {
                base2.style.position = "relative";
                base2.style.top = makeEm3(baseShift);
              }
              return base2;
            }
          };
          const op_mathmlBuilder = (group, options) => {
            let node;
            if (group.symbol) {
              node = new MathNode2("mo", [makeText3(group.name, group.mode)]);
              if (noSuccessor2.includes(group.name)) {
                node.setAttribute("largeop", "false");
              }
            } else if (group.body) {
              node = new MathNode2("mo", buildMathML_buildExpression(group.body, options));
            } else {
              node = new MathNode2("mi", [new TextNode2(group.name.slice(1))]);
              const operator = new MathNode2("mo", [makeText3("", "text")]);
              if (group.parentIsSupSub) {
                node = new MathNode2("mrow", [node, operator]);
              } else {
                node = newDocumentFragment2([node, operator]);
              }
            }
            return node;
          };
          const singleCharBigOps2 = {
            "": "\\prod",
            "": "\\coprod",
            "": "\\sum",
            "": "\\bigwedge",
            "": "\\bigvee",
            "": "\\bigcap",
            "": "\\bigcup",
            "": "\\bigodot",
            "": "\\bigoplus",
            "": "\\bigotimes",
            "": "\\biguplus",
            "": "\\bigsqcup"
          };
          defineFunction2({
            type: "op",
            names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
            props: {
              numArgs: 0
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              let fName = funcName;
              if (fName.length === 1) {
                fName = singleCharBigOps2[fName];
              }
              return {
                type: "op",
                mode: parser.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: true,
                name: fName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction2({
            type: "op",
            names: ["\\mathop"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const body = args[0];
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                body: ordargument3(body)
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          const singleCharIntegrals2 = {
            "": "\\int",
            "": "\\iint",
            "": "\\iiint",
            "": "\\oint",
            "": "\\oiint",
            "": "\\oiiint"
          };
          defineFunction2({
            type: "op",
            names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
            props: {
              numArgs: 0
            },
            handler(_ref3) {
              let {
                parser,
                funcName
              } = _ref3;
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                name: funcName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction2({
            type: "op",
            names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
            props: {
              numArgs: 0
            },
            handler(_ref4) {
              let {
                parser,
                funcName
              } = _ref4;
              return {
                type: "op",
                mode: parser.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: false,
                name: funcName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction2({
            type: "op",
            names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
            props: {
              numArgs: 0,
              allowedInArgument: true
            },
            handler(_ref5) {
              let {
                parser,
                funcName
              } = _ref5;
              let fName = funcName;
              if (fName.length === 1) {
                fName = singleCharIntegrals2[fName];
              }
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: true,
                name: fName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          const operatorname_htmlBuilder = (grp, options) => {
            let supGroup;
            let subGroup;
            let hasLimits = false;
            let group;
            if (grp.type === "supsub") {
              supGroup = grp.sup;
              subGroup = grp.sub;
              group = assertNodeType2(grp.base, "operatorname");
              hasLimits = true;
            } else {
              group = assertNodeType2(grp, "operatorname");
            }
            let base2;
            if (group.body.length > 0) {
              const body = group.body.map((child) => {
                const childText = child.text;
                if (typeof childText === "string") {
                  return {
                    type: "textord",
                    mode: child.mode,
                    text: childText
                  };
                } else {
                  return child;
                }
              });
              const expression = buildExpression4(body, options.withFont("mathrm"), true);
              for (let i = 0; i < expression.length; i++) {
                const child = expression[i];
                if (child instanceof SymbolNode2) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                }
              }
              base2 = buildCommon2.makeSpan(["mop"], expression, options);
            } else {
              base2 = buildCommon2.makeSpan(["mop"], [], options);
            }
            if (hasLimits) {
              return assembleSupSub2(base2, supGroup, subGroup, options, options.style, 0, 0);
            } else {
              return base2;
            }
          };
          const operatorname_mathmlBuilder = (group, options) => {
            let expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
            let isAllString = true;
            for (let i = 0; i < expression.length; i++) {
              const node = expression[i];
              if (node instanceof mathMLTree2.SpaceNode) ;
              else if (node instanceof mathMLTree2.MathNode) {
                switch (node.type) {
                  case "mi":
                  case "mn":
                  case "ms":
                  case "mspace":
                  case "mtext":
                    break;
                  // Do nothing yet.
                  case "mo": {
                    const child = node.children[0];
                    if (node.children.length === 1 && child instanceof mathMLTree2.TextNode) {
                      child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                    } else {
                      isAllString = false;
                    }
                    break;
                  }
                  default:
                    isAllString = false;
                }
              } else {
                isAllString = false;
              }
            }
            if (isAllString) {
              const word = expression.map((node) => node.toText()).join("");
              expression = [new mathMLTree2.TextNode(word)];
            }
            const identifier = new mathMLTree2.MathNode("mi", expression);
            identifier.setAttribute("mathvariant", "normal");
            const operator = new mathMLTree2.MathNode("mo", [makeText3("", "text")]);
            if (group.parentIsSupSub) {
              return new mathMLTree2.MathNode("mrow", [identifier, operator]);
            } else {
              return mathMLTree2.newDocumentFragment([identifier, operator]);
            }
          };
          defineFunction2({
            type: "operatorname",
            names: ["\\operatorname@", "\\operatornamewithlimits"],
            props: {
              numArgs: 1
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "operatorname",
                mode: parser.mode,
                body: ordargument3(body),
                alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
                limits: false,
                parentIsSupSub: false
              };
            },
            htmlBuilder: operatorname_htmlBuilder,
            mathmlBuilder: operatorname_mathmlBuilder
          });
          defineMacro2("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
          defineFunctionBuilders2({
            type: "ordgroup",
            htmlBuilder(group, options) {
              if (group.semisimple) {
                return buildCommon2.makeFragment(buildExpression4(group.body, options, false));
              }
              return buildCommon2.makeSpan(["mord"], buildExpression4(group.body, options, true), options);
            },
            mathmlBuilder(group, options) {
              return buildExpressionRow3(group.body, options, true);
            }
          });
          defineFunction2({
            type: "overline",
            names: ["\\overline"],
            props: {
              numArgs: 1
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const body = args[0];
              return {
                type: "overline",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder(group, options) {
              const innerGroup = buildGroup4(group.body, options.havingCrampedStyle());
              const line = buildCommon2.makeLineSpan("overline-line", options);
              const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
              const vlist = buildCommon2.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: innerGroup
                }, {
                  type: "kern",
                  size: 3 * defaultRuleThickness
                }, {
                  type: "elem",
                  elem: line
                }, {
                  type: "kern",
                  size: defaultRuleThickness
                }]
              }, options);
              return buildCommon2.makeSpan(["mord", "overline"], [vlist], options);
            },
            mathmlBuilder(group, options) {
              const operator = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode("")]);
              operator.setAttribute("stretchy", "true");
              const node = new mathMLTree2.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
              node.setAttribute("accent", "true");
              return node;
            }
          });
          defineFunction2({
            type: "phantom",
            names: ["\\phantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              const body = args[0];
              return {
                type: "phantom",
                mode: parser.mode,
                body: ordargument3(body)
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression4(group.body, options.withPhantom(), false);
              return buildCommon2.makeFragment(elements);
            },
            mathmlBuilder: (group, options) => {
              const inner3 = buildMathML_buildExpression(group.body, options);
              return new mathMLTree2.MathNode("mphantom", inner3);
            }
          });
          defineFunction2({
            type: "hphantom",
            names: ["\\hphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const body = args[0];
              return {
                type: "hphantom",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder: (group, options) => {
              let node = buildCommon2.makeSpan([], [buildGroup4(group.body, options.withPhantom())]);
              node.height = 0;
              node.depth = 0;
              if (node.children) {
                for (let i = 0; i < node.children.length; i++) {
                  node.children[i].height = 0;
                  node.children[i].depth = 0;
                }
              }
              node = buildCommon2.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: node
                }]
              }, options);
              return buildCommon2.makeSpan(["mord"], [node], options);
            },
            mathmlBuilder: (group, options) => {
              const inner3 = buildMathML_buildExpression(ordargument3(group.body), options);
              const phantom = new mathMLTree2.MathNode("mphantom", inner3);
              const node = new mathMLTree2.MathNode("mpadded", [phantom]);
              node.setAttribute("height", "0px");
              node.setAttribute("depth", "0px");
              return node;
            }
          });
          defineFunction2({
            type: "vphantom",
            names: ["\\vphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref3, args) => {
              let {
                parser
              } = _ref3;
              const body = args[0];
              return {
                type: "vphantom",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder: (group, options) => {
              const inner3 = buildCommon2.makeSpan(["inner"], [buildGroup4(group.body, options.withPhantom())]);
              const fix = buildCommon2.makeSpan(["fix"], []);
              return buildCommon2.makeSpan(["mord", "rlap"], [inner3, fix], options);
            },
            mathmlBuilder: (group, options) => {
              const inner3 = buildMathML_buildExpression(ordargument3(group.body), options);
              const phantom = new mathMLTree2.MathNode("mphantom", inner3);
              const node = new mathMLTree2.MathNode("mpadded", [phantom]);
              node.setAttribute("width", "0px");
              return node;
            }
          });
          defineFunction2({
            type: "raisebox",
            names: ["\\raisebox"],
            props: {
              numArgs: 2,
              argTypes: ["size", "hbox"],
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const amount = assertNodeType2(args[0], "size").value;
              const body = args[1];
              return {
                type: "raisebox",
                mode: parser.mode,
                dy: amount,
                body
              };
            },
            htmlBuilder(group, options) {
              const body = buildGroup4(group.body, options);
              const dy = calculateSize3(group.dy, options);
              return buildCommon2.makeVList({
                positionType: "shift",
                positionData: -dy,
                children: [{
                  type: "elem",
                  elem: body
                }]
              }, options);
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              const dy = group.dy.number + group.dy.unit;
              node.setAttribute("voffset", dy);
              return node;
            }
          });
          defineFunction2({
            type: "internal",
            names: ["\\relax"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInArgument: true
            },
            handler(_ref) {
              let {
                parser
              } = _ref;
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction2({
            type: "rule",
            names: ["\\rule"],
            props: {
              numArgs: 2,
              numOptionalArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              argTypes: ["size", "size", "size"]
            },
            handler(_ref, args, optArgs) {
              let {
                parser
              } = _ref;
              const shift = optArgs[0];
              const width = assertNodeType2(args[0], "size");
              const height = assertNodeType2(args[1], "size");
              return {
                type: "rule",
                mode: parser.mode,
                shift: shift && assertNodeType2(shift, "size").value,
                width: width.value,
                height: height.value
              };
            },
            htmlBuilder(group, options) {
              const rule = buildCommon2.makeSpan(["mord", "rule"], [], options);
              const width = calculateSize3(group.width, options);
              const height = calculateSize3(group.height, options);
              const shift = group.shift ? calculateSize3(group.shift, options) : 0;
              rule.style.borderRightWidth = makeEm3(width);
              rule.style.borderTopWidth = makeEm3(height);
              rule.style.bottom = makeEm3(shift);
              rule.width = width;
              rule.height = height + shift;
              rule.depth = -shift;
              rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
              return rule;
            },
            mathmlBuilder(group, options) {
              const width = calculateSize3(group.width, options);
              const height = calculateSize3(group.height, options);
              const shift = group.shift ? calculateSize3(group.shift, options) : 0;
              const color2 = options.color && options.getColor() || "black";
              const rule = new mathMLTree2.MathNode("mspace");
              rule.setAttribute("mathbackground", color2);
              rule.setAttribute("width", makeEm3(width));
              rule.setAttribute("height", makeEm3(height));
              const wrapper = new mathMLTree2.MathNode("mpadded", [rule]);
              if (shift >= 0) {
                wrapper.setAttribute("height", makeEm3(shift));
              } else {
                wrapper.setAttribute("height", makeEm3(shift));
                wrapper.setAttribute("depth", makeEm3(-shift));
              }
              wrapper.setAttribute("voffset", makeEm3(shift));
              return wrapper;
            }
          });
          function sizingGroup2(value, options, baseOptions) {
            const inner3 = buildExpression4(value, options, false);
            const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
            for (let i = 0; i < inner3.length; i++) {
              const pos = inner3[i].classes.indexOf("sizing");
              if (pos < 0) {
                Array.prototype.push.apply(inner3[i].classes, options.sizingClasses(baseOptions));
              } else if (inner3[i].classes[pos + 1] === "reset-size" + options.size) {
                inner3[i].classes[pos + 1] = "reset-size" + baseOptions.size;
              }
              inner3[i].height *= multiplier;
              inner3[i].depth *= multiplier;
            }
            return buildCommon2.makeFragment(inner3);
          }
          const sizeFuncs2 = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
          const sizing_htmlBuilder = (group, options) => {
            const newOptions = options.havingSize(group.size);
            return sizingGroup2(group.body, newOptions, options);
          };
          defineFunction2({
            type: "sizing",
            names: sizeFuncs2,
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                breakOnTokenText,
                funcName,
                parser
              } = _ref;
              const body = parser.parseExpression(false, breakOnTokenText);
              return {
                type: "sizing",
                mode: parser.mode,
                // Figure out what size to use based on the list of functions above
                size: sizeFuncs2.indexOf(funcName) + 1,
                body
              };
            },
            htmlBuilder: sizing_htmlBuilder,
            mathmlBuilder: (group, options) => {
              const newOptions = options.havingSize(group.size);
              const inner3 = buildMathML_buildExpression(group.body, newOptions);
              const node = new mathMLTree2.MathNode("mstyle", inner3);
              node.setAttribute("mathsize", makeEm3(newOptions.sizeMultiplier));
              return node;
            }
          });
          defineFunction2({
            type: "smash",
            names: ["\\smash"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              allowedInText: true
            },
            handler: (_ref, args, optArgs) => {
              let {
                parser
              } = _ref;
              let smashHeight = false;
              let smashDepth = false;
              const tbArg = optArgs[0] && assertNodeType2(optArgs[0], "ordgroup");
              if (tbArg) {
                let letter = "";
                for (let i = 0; i < tbArg.body.length; ++i) {
                  const node = tbArg.body[i];
                  letter = node.text;
                  if (letter === "t") {
                    smashHeight = true;
                  } else if (letter === "b") {
                    smashDepth = true;
                  } else {
                    smashHeight = false;
                    smashDepth = false;
                    break;
                  }
                }
              } else {
                smashHeight = true;
                smashDepth = true;
              }
              const body = args[0];
              return {
                type: "smash",
                mode: parser.mode,
                body,
                smashHeight,
                smashDepth
              };
            },
            htmlBuilder: (group, options) => {
              const node = buildCommon2.makeSpan([], [buildGroup4(group.body, options)]);
              if (!group.smashHeight && !group.smashDepth) {
                return node;
              }
              if (group.smashHeight) {
                node.height = 0;
                if (node.children) {
                  for (let i = 0; i < node.children.length; i++) {
                    node.children[i].height = 0;
                  }
                }
              }
              if (group.smashDepth) {
                node.depth = 0;
                if (node.children) {
                  for (let i = 0; i < node.children.length; i++) {
                    node.children[i].depth = 0;
                  }
                }
              }
              const smashedNode = buildCommon2.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: node
                }]
              }, options);
              return buildCommon2.makeSpan(["mord"], [smashedNode], options);
            },
            mathmlBuilder: (group, options) => {
              const node = new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              if (group.smashHeight) {
                node.setAttribute("height", "0px");
              }
              if (group.smashDepth) {
                node.setAttribute("depth", "0px");
              }
              return node;
            }
          });
          defineFunction2({
            type: "sqrt",
            names: ["\\sqrt"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(_ref, args, optArgs) {
              let {
                parser
              } = _ref;
              const index = optArgs[0];
              const body = args[0];
              return {
                type: "sqrt",
                mode: parser.mode,
                body,
                index
              };
            },
            htmlBuilder(group, options) {
              let inner3 = buildGroup4(group.body, options.havingCrampedStyle());
              if (inner3.height === 0) {
                inner3.height = options.fontMetrics().xHeight;
              }
              inner3 = buildCommon2.wrapFragment(inner3, options);
              const metrics = options.fontMetrics();
              const theta = metrics.defaultRuleThickness;
              let phi = theta;
              if (options.style.id < src_Style.TEXT.id) {
                phi = options.fontMetrics().xHeight;
              }
              let lineClearance = theta + phi / 4;
              const minDelimiterHeight = inner3.height + inner3.depth + lineClearance + theta;
              const {
                span: img,
                ruleWidth,
                advanceWidth
              } = delimiter2.sqrtImage(minDelimiterHeight, options);
              const delimDepth = img.height - ruleWidth;
              if (delimDepth > inner3.height + inner3.depth + lineClearance) {
                lineClearance = (lineClearance + delimDepth - inner3.height - inner3.depth) / 2;
              }
              const imgShift = img.height - inner3.height - lineClearance - ruleWidth;
              inner3.style.paddingLeft = makeEm3(advanceWidth);
              const body = buildCommon2.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: inner3,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: -(inner3.height + imgShift)
                }, {
                  type: "elem",
                  elem: img
                }, {
                  type: "kern",
                  size: ruleWidth
                }]
              }, options);
              if (!group.index) {
                return buildCommon2.makeSpan(["mord", "sqrt"], [body], options);
              } else {
                const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
                const rootm = buildGroup4(group.index, newOptions, options);
                const toShift = 0.6 * (body.height - body.depth);
                const rootVList = buildCommon2.makeVList({
                  positionType: "shift",
                  positionData: -toShift,
                  children: [{
                    type: "elem",
                    elem: rootm
                  }]
                }, options);
                const rootVListWrap = buildCommon2.makeSpan(["root"], [rootVList]);
                return buildCommon2.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
              }
            },
            mathmlBuilder(group, options) {
              const {
                body,
                index
              } = group;
              return index ? new mathMLTree2.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree2.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
            }
          });
          const styling_styleMap = {
            "display": src_Style.DISPLAY,
            "text": src_Style.TEXT,
            "script": src_Style.SCRIPT,
            "scriptscript": src_Style.SCRIPTSCRIPT
          };
          defineFunction2({
            type: "styling",
            names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref, args) {
              let {
                breakOnTokenText,
                funcName,
                parser
              } = _ref;
              const body = parser.parseExpression(true, breakOnTokenText);
              const style = funcName.slice(1, funcName.length - 5);
              return {
                type: "styling",
                mode: parser.mode,
                // Figure out what style to use by pulling out the style from
                // the function name
                style,
                body
              };
            },
            htmlBuilder(group, options) {
              const newStyle = styling_styleMap[group.style];
              const newOptions = options.havingStyle(newStyle).withFont("");
              return sizingGroup2(group.body, newOptions, options);
            },
            mathmlBuilder(group, options) {
              const newStyle = styling_styleMap[group.style];
              const newOptions = options.havingStyle(newStyle);
              const inner3 = buildMathML_buildExpression(group.body, newOptions);
              const node = new mathMLTree2.MathNode("mstyle", inner3);
              const styleAttributes = {
                "display": ["0", "true"],
                "text": ["0", "false"],
                "script": ["1", "false"],
                "scriptscript": ["2", "false"]
              };
              const attr = styleAttributes[group.style];
              node.setAttribute("scriptlevel", attr[0]);
              node.setAttribute("displaystyle", attr[1]);
              return node;
            }
          });
          const htmlBuilderDelegate3 = function(group, options) {
            const base2 = group.base;
            if (!base2) {
              return null;
            } else if (base2.type === "op") {
              const delegate = base2.limits && (options.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
              return delegate ? op_htmlBuilder : null;
            } else if (base2.type === "operatorname") {
              const delegate = base2.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base2.limits);
              return delegate ? operatorname_htmlBuilder : null;
            } else if (base2.type === "accent") {
              return utils2.isCharacterBox(base2.base) ? htmlBuilder3 : null;
            } else if (base2.type === "horizBrace") {
              const isSup = !group.sub;
              return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
            } else {
              return null;
            }
          };
          defineFunctionBuilders2({
            type: "supsub",
            htmlBuilder(group, options) {
              const builderDelegate = htmlBuilderDelegate3(group, options);
              if (builderDelegate) {
                return builderDelegate(group, options);
              }
              const {
                base: valueBase,
                sup: valueSup,
                sub: valueSub
              } = group;
              const base2 = buildGroup4(valueBase, options);
              let supm;
              let subm;
              const metrics = options.fontMetrics();
              let supShift = 0;
              let subShift = 0;
              const isCharacterBox4 = valueBase && utils2.isCharacterBox(valueBase);
              if (valueSup) {
                const newOptions = options.havingStyle(options.style.sup());
                supm = buildGroup4(valueSup, newOptions, options);
                if (!isCharacterBox4) {
                  supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              if (valueSub) {
                const newOptions = options.havingStyle(options.style.sub());
                subm = buildGroup4(valueSub, newOptions, options);
                if (!isCharacterBox4) {
                  subShift = base2.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              let minSupShift;
              if (options.style === src_Style.DISPLAY) {
                minSupShift = metrics.sup1;
              } else if (options.style.cramped) {
                minSupShift = metrics.sup3;
              } else {
                minSupShift = metrics.sup2;
              }
              const multiplier = options.sizeMultiplier;
              const marginRight = makeEm3(0.5 / metrics.ptPerEm / multiplier);
              let marginLeft = null;
              if (subm) {
                const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
                if (base2 instanceof SymbolNode2 || isOiint) {
                  marginLeft = makeEm3(-base2.italic);
                }
              }
              let supsub;
              if (supm && subm) {
                supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                subShift = Math.max(subShift, metrics.sub2);
                const ruleWidth = metrics.defaultRuleThickness;
                const maxWidth = 4 * ruleWidth;
                if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                  subShift = maxWidth - (supShift - supm.depth) + subm.height;
                  const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                  if (psi > 0) {
                    supShift += psi;
                    subShift -= psi;
                  }
                }
                const vlistElem = [{
                  type: "elem",
                  elem: subm,
                  shift: subShift,
                  marginRight,
                  marginLeft
                }, {
                  type: "elem",
                  elem: supm,
                  shift: -supShift,
                  marginRight
                }];
                supsub = buildCommon2.makeVList({
                  positionType: "individualShift",
                  children: vlistElem
                }, options);
              } else if (subm) {
                subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
                const vlistElem = [{
                  type: "elem",
                  elem: subm,
                  marginLeft,
                  marginRight
                }];
                supsub = buildCommon2.makeVList({
                  positionType: "shift",
                  positionData: subShift,
                  children: vlistElem
                }, options);
              } else if (supm) {
                supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                supsub = buildCommon2.makeVList({
                  positionType: "shift",
                  positionData: -supShift,
                  children: [{
                    type: "elem",
                    elem: supm,
                    marginRight
                  }]
                }, options);
              } else {
                throw new Error("supsub must have either sup or sub.");
              }
              const mclass = getTypeOfDomTree3(base2, "right") || "mord";
              return buildCommon2.makeSpan([mclass], [base2, buildCommon2.makeSpan(["msupsub"], [supsub])], options);
            },
            mathmlBuilder(group, options) {
              let isBrace = false;
              let isOver;
              let isSup;
              if (group.base && group.base.type === "horizBrace") {
                isSup = !!group.sup;
                if (isSup === group.base.isOver) {
                  isBrace = true;
                  isOver = group.base.isOver;
                }
              }
              if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
                group.base.parentIsSupSub = true;
              }
              const children = [buildMathML_buildGroup(group.base, options)];
              if (group.sub) {
                children.push(buildMathML_buildGroup(group.sub, options));
              }
              if (group.sup) {
                children.push(buildMathML_buildGroup(group.sup, options));
              }
              let nodeType;
              if (isBrace) {
                nodeType = isOver ? "mover" : "munder";
              } else if (!group.sub) {
                const base2 = group.base;
                if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                  nodeType = "mover";
                } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                  nodeType = "mover";
                } else {
                  nodeType = "msup";
                }
              } else if (!group.sup) {
                const base2 = group.base;
                if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                  nodeType = "munder";
                } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                  nodeType = "munder";
                } else {
                  nodeType = "msub";
                }
              } else {
                const base2 = group.base;
                if (base2 && base2.type === "op" && base2.limits && options.style === src_Style.DISPLAY) {
                  nodeType = "munderover";
                } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base2.limits)) {
                  nodeType = "munderover";
                } else {
                  nodeType = "msubsup";
                }
              }
              return new mathMLTree2.MathNode(nodeType, children);
            }
          });
          defineFunctionBuilders2({
            type: "atom",
            htmlBuilder(group, options) {
              return buildCommon2.mathsym(group.text, group.mode, options, ["m" + group.family]);
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree2.MathNode("mo", [makeText3(group.text, group.mode)]);
              if (group.family === "bin") {
                const variant = getVariant3(group, options);
                if (variant === "bold-italic") {
                  node.setAttribute("mathvariant", variant);
                }
              } else if (group.family === "punct") {
                node.setAttribute("separator", "true");
              } else if (group.family === "open" || group.family === "close") {
                node.setAttribute("stretchy", "false");
              }
              return node;
            }
          });
          const defaultVariant2 = {
            "mi": "italic",
            "mn": "normal",
            "mtext": "normal"
          };
          defineFunctionBuilders2({
            type: "mathord",
            htmlBuilder(group, options) {
              return buildCommon2.makeOrd(group, options, "mathord");
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree2.MathNode("mi", [makeText3(group.text, group.mode, options)]);
              const variant = getVariant3(group, options) || "italic";
              if (variant !== defaultVariant2[node.type]) {
                node.setAttribute("mathvariant", variant);
              }
              return node;
            }
          });
          defineFunctionBuilders2({
            type: "textord",
            htmlBuilder(group, options) {
              return buildCommon2.makeOrd(group, options, "textord");
            },
            mathmlBuilder(group, options) {
              const text2 = makeText3(group.text, group.mode, options);
              const variant = getVariant3(group, options) || "normal";
              let node;
              if (group.mode === "text") {
                node = new mathMLTree2.MathNode("mtext", [text2]);
              } else if (/[0-9]/.test(group.text)) {
                node = new mathMLTree2.MathNode("mn", [text2]);
              } else if (group.text === "\\prime") {
                node = new mathMLTree2.MathNode("mo", [text2]);
              } else {
                node = new mathMLTree2.MathNode("mi", [text2]);
              }
              if (variant !== defaultVariant2[node.type]) {
                node.setAttribute("mathvariant", variant);
              }
              return node;
            }
          });
          const cssSpace2 = {
            "\\nobreak": "nobreak",
            "\\allowbreak": "allowbreak"
          };
          const regularSpace2 = {
            " ": {},
            "\\ ": {},
            "~": {
              className: "nobreak"
            },
            "\\space": {},
            "\\nobreakspace": {
              className: "nobreak"
            }
          };
          defineFunctionBuilders2({
            type: "spacing",
            htmlBuilder(group, options) {
              if (regularSpace2.hasOwnProperty(group.text)) {
                const className = regularSpace2[group.text].className || "";
                if (group.mode === "text") {
                  const ord = buildCommon2.makeOrd(group, options, "textord");
                  ord.classes.push(className);
                  return ord;
                } else {
                  return buildCommon2.makeSpan(["mspace", className], [buildCommon2.mathsym(group.text, group.mode, options)], options);
                }
              } else if (cssSpace2.hasOwnProperty(group.text)) {
                return buildCommon2.makeSpan(["mspace", cssSpace2[group.text]], [], options);
              } else {
                throw new src_ParseError('Unknown type of space "' + group.text + '"');
              }
            },
            mathmlBuilder(group, options) {
              let node;
              if (regularSpace2.hasOwnProperty(group.text)) {
                node = new mathMLTree2.MathNode("mtext", [new mathMLTree2.TextNode("")]);
              } else if (cssSpace2.hasOwnProperty(group.text)) {
                return new mathMLTree2.MathNode("mspace");
              } else {
                throw new src_ParseError('Unknown type of space "' + group.text + '"');
              }
              return node;
            }
          });
          const pad2 = () => {
            const padNode = new mathMLTree2.MathNode("mtd", []);
            padNode.setAttribute("width", "50%");
            return padNode;
          };
          defineFunctionBuilders2({
            type: "tag",
            mathmlBuilder(group, options) {
              const table2 = new mathMLTree2.MathNode("mtable", [new mathMLTree2.MathNode("mtr", [pad2(), new mathMLTree2.MathNode("mtd", [buildExpressionRow3(group.body, options)]), pad2(), new mathMLTree2.MathNode("mtd", [buildExpressionRow3(group.tag, options)])])]);
              table2.setAttribute("width", "100%");
              return table2;
            }
          });
          const textFontFamilies2 = {
            "\\text": void 0,
            "\\textrm": "textrm",
            "\\textsf": "textsf",
            "\\texttt": "texttt",
            "\\textnormal": "textrm"
          };
          const textFontWeights2 = {
            "\\textbf": "textbf",
            "\\textmd": "textmd"
          };
          const textFontShapes2 = {
            "\\textit": "textit",
            "\\textup": "textup"
          };
          const optionsWithFont2 = (group, options) => {
            const font = group.font;
            if (!font) {
              return options;
            } else if (textFontFamilies2[font]) {
              return options.withTextFontFamily(textFontFamilies2[font]);
            } else if (textFontWeights2[font]) {
              return options.withTextFontWeight(textFontWeights2[font]);
            } else if (font === "\\emph") {
              return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
            }
            return options.withTextFontShape(textFontShapes2[font]);
          };
          defineFunction2({
            type: "text",
            names: [
              // Font families
              "\\text",
              "\\textrm",
              "\\textsf",
              "\\texttt",
              "\\textnormal",
              // Font weights
              "\\textbf",
              "\\textmd",
              // Font Shapes
              "\\textit",
              "\\textup",
              "\\emph"
            ],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInArgument: true,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "text",
                mode: parser.mode,
                body: ordargument3(body),
                font: funcName
              };
            },
            htmlBuilder(group, options) {
              const newOptions = optionsWithFont2(group, options);
              const inner3 = buildExpression4(group.body, newOptions, true);
              return buildCommon2.makeSpan(["mord", "text"], inner3, newOptions);
            },
            mathmlBuilder(group, options) {
              const newOptions = optionsWithFont2(group, options);
              return buildExpressionRow3(group.body, newOptions);
            }
          });
          defineFunction2({
            type: "underline",
            names: ["\\underline"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "underline",
                mode: parser.mode,
                body: args[0]
              };
            },
            htmlBuilder(group, options) {
              const innerGroup = buildGroup4(group.body, options);
              const line = buildCommon2.makeLineSpan("underline-line", options);
              const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
              const vlist = buildCommon2.makeVList({
                positionType: "top",
                positionData: innerGroup.height,
                children: [{
                  type: "kern",
                  size: defaultRuleThickness
                }, {
                  type: "elem",
                  elem: line
                }, {
                  type: "kern",
                  size: 3 * defaultRuleThickness
                }, {
                  type: "elem",
                  elem: innerGroup
                }]
              }, options);
              return buildCommon2.makeSpan(["mord", "underline"], [vlist], options);
            },
            mathmlBuilder(group, options) {
              const operator = new mathMLTree2.MathNode("mo", [new mathMLTree2.TextNode("")]);
              operator.setAttribute("stretchy", "true");
              const node = new mathMLTree2.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
              node.setAttribute("accentunder", "true");
              return node;
            }
          });
          defineFunction2({
            type: "vcenter",
            names: ["\\vcenter"],
            props: {
              numArgs: 1,
              argTypes: ["original"],
              // In LaTeX, \vcenter can act only on a box.
              allowedInText: false
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "vcenter",
                mode: parser.mode,
                body: args[0]
              };
            },
            htmlBuilder(group, options) {
              const body = buildGroup4(group.body, options);
              const axisHeight = options.fontMetrics().axisHeight;
              const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
              return buildCommon2.makeVList({
                positionType: "shift",
                positionData: dy,
                children: [{
                  type: "elem",
                  elem: body
                }]
              }, options);
            },
            mathmlBuilder(group, options) {
              return new mathMLTree2.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
            }
          });
          defineFunction2({
            type: "verb",
            names: ["\\verb"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(context, args, optArgs) {
              throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
            },
            htmlBuilder(group, options) {
              const text2 = makeVerb2(group);
              const body = [];
              const newOptions = options.havingStyle(options.style.text());
              for (let i = 0; i < text2.length; i++) {
                let c = text2[i];
                if (c === "~") {
                  c = "\\textasciitilde";
                }
                body.push(buildCommon2.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
              }
              return buildCommon2.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon2.tryCombineChars(body), newOptions);
            },
            mathmlBuilder(group, options) {
              const text2 = new mathMLTree2.TextNode(makeVerb2(group));
              const node = new mathMLTree2.MathNode("mtext", [text2]);
              node.setAttribute("mathvariant", "monospace");
              return node;
            }
          });
          const makeVerb2 = (group) => group.body.replace(/ /g, group.star ? "" : "");
          const functions2 = _functions2;
          var src_functions = functions2;
          const spaceRegexString2 = "[ \r\n	]";
          const controlWordRegexString2 = "\\\\[a-zA-Z@]+";
          const controlSymbolRegexString2 = "\\\\[^\uD800-\uDFFF]";
          const controlWordWhitespaceRegexString2 = "(" + controlWordRegexString2 + ")" + spaceRegexString2 + "*";
          const controlSpaceRegexString2 = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
          const combiningDiacriticalMarkString2 = "[-]";
          const combiningDiacriticalMarksEndRegex2 = new RegExp(combiningDiacriticalMarkString2 + "+$");
          const tokenRegexString2 = "(" + spaceRegexString2 + "+)|" + // whitespace
          (controlSpaceRegexString2 + "|") + // \whitespace
          "([!-\\[\\]---]" + // single codepoint
          (combiningDiacriticalMarkString2 + "*") + // ...plus accents
          "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
          (combiningDiacriticalMarkString2 + "*") + // ...plus accents
          "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
          ("|" + controlWordWhitespaceRegexString2) + // \macroName + spaces
          ("|" + controlSymbolRegexString2 + ")");
          class Lexer2 {
            // Category codes. The lexer only supports comment characters (14) for now.
            // MacroExpander additionally distinguishes active (13).
            constructor(input, settings) {
              this.input = void 0;
              this.settings = void 0;
              this.tokenRegex = void 0;
              this.catcodes = void 0;
              this.input = input;
              this.settings = settings;
              this.tokenRegex = new RegExp(tokenRegexString2, "g");
              this.catcodes = {
                "%": 14,
                // comment character
                "~": 13
                // active character
              };
            }
            setCatcode(char, code2) {
              this.catcodes[char] = code2;
            }
            /**
             * This function lexes a single token.
             */
            lex() {
              const input = this.input;
              const pos = this.tokenRegex.lastIndex;
              if (pos === input.length) {
                return new Token3("EOF", new SourceLocation2(this, pos, pos));
              }
              const match2 = this.tokenRegex.exec(input);
              if (match2 === null || match2.index !== pos) {
                throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token3(input[pos], new SourceLocation2(this, pos, pos + 1)));
              }
              const text2 = match2[6] || match2[3] || (match2[2] ? "\\ " : " ");
              if (this.catcodes[text2] === 14) {
                const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
                if (nlIndex === -1) {
                  this.tokenRegex.lastIndex = input.length;
                  this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
                } else {
                  this.tokenRegex.lastIndex = nlIndex + 1;
                }
                return this.lex();
              }
              return new Token3(text2, new SourceLocation2(this, pos, this.tokenRegex.lastIndex));
            }
          }
          class Namespace2 {
            /**
             * Both arguments are optional.  The first argument is an object of
             * built-in mappings which never change.  The second argument is an object
             * of initial (global-level) mappings, which will constantly change
             * according to any global/top-level `set`s done.
             */
            constructor(builtins, globalMacros) {
              if (builtins === void 0) {
                builtins = {};
              }
              if (globalMacros === void 0) {
                globalMacros = {};
              }
              this.current = void 0;
              this.builtins = void 0;
              this.undefStack = void 0;
              this.current = globalMacros;
              this.builtins = builtins;
              this.undefStack = [];
            }
            /**
             * Start a new nested group, affecting future local `set`s.
             */
            beginGroup() {
              this.undefStack.push({});
            }
            /**
             * End current nested group, restoring values before the group began.
             */
            endGroup() {
              if (this.undefStack.length === 0) {
                throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
              }
              const undefs = this.undefStack.pop();
              for (const undef in undefs) {
                if (undefs.hasOwnProperty(undef)) {
                  if (undefs[undef] == null) {
                    delete this.current[undef];
                  } else {
                    this.current[undef] = undefs[undef];
                  }
                }
              }
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              while (this.undefStack.length > 0) {
                this.endGroup();
              }
            }
            /**
             * Detect whether `name` has a definition.  Equivalent to
             * `get(name) != null`.
             */
            has(name) {
              return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
            }
            /**
             * Get the current value of a name, or `undefined` if there is no value.
             *
             * Note: Do not use `if (namespace.get(...))` to detect whether a macro
             * is defined, as the definition may be the empty string which evaluates
             * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
             * `if (namespace.has(...))`.
             */
            get(name) {
              if (this.current.hasOwnProperty(name)) {
                return this.current[name];
              } else {
                return this.builtins[name];
              }
            }
            /**
             * Set the current value of a name, and optionally set it globally too.
             * Local set() sets the current value and (when appropriate) adds an undo
             * operation to the undo stack.  Global set() may change the undo
             * operation at every level, so takes time linear in their number.
             * A value of undefined means to delete existing definitions.
             */
            set(name, value, global) {
              if (global === void 0) {
                global = false;
              }
              if (global) {
                for (let i = 0; i < this.undefStack.length; i++) {
                  delete this.undefStack[i][name];
                }
                if (this.undefStack.length > 0) {
                  this.undefStack[this.undefStack.length - 1][name] = value;
                }
              } else {
                const top = this.undefStack[this.undefStack.length - 1];
                if (top && !top.hasOwnProperty(name)) {
                  top[name] = this.current[name];
                }
              }
              if (value == null) {
                delete this.current[name];
              } else {
                this.current[name] = value;
              }
            }
          }
          const macros2 = _macros2;
          var src_macros = macros2;
          defineMacro2("\\noexpand", function(context) {
            const t = context.popToken();
            if (context.isExpandable(t.text)) {
              t.noexpand = true;
              t.treatAsRelax = true;
            }
            return {
              tokens: [t],
              numArgs: 0
            };
          });
          defineMacro2("\\expandafter", function(context) {
            const t = context.popToken();
            context.expandOnce(true);
            return {
              tokens: [t],
              numArgs: 0
            };
          });
          defineMacro2("\\@firstoftwo", function(context) {
            const args = context.consumeArgs(2);
            return {
              tokens: args[0],
              numArgs: 0
            };
          });
          defineMacro2("\\@secondoftwo", function(context) {
            const args = context.consumeArgs(2);
            return {
              tokens: args[1],
              numArgs: 0
            };
          });
          defineMacro2("\\@ifnextchar", function(context) {
            const args = context.consumeArgs(3);
            context.consumeSpaces();
            const nextToken = context.future();
            if (args[0].length === 1 && args[0][0].text === nextToken.text) {
              return {
                tokens: args[1],
                numArgs: 0
              };
            } else {
              return {
                tokens: args[2],
                numArgs: 0
              };
            }
          });
          defineMacro2("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
          defineMacro2("\\TextOrMath", function(context) {
            const args = context.consumeArgs(2);
            if (context.mode === "text") {
              return {
                tokens: args[0],
                numArgs: 0
              };
            } else {
              return {
                tokens: args[1],
                numArgs: 0
              };
            }
          });
          const digitToNumber2 = {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
            "a": 10,
            "A": 10,
            "b": 11,
            "B": 11,
            "c": 12,
            "C": 12,
            "d": 13,
            "D": 13,
            "e": 14,
            "E": 14,
            "f": 15,
            "F": 15
          };
          defineMacro2("\\char", function(context) {
            let token = context.popToken();
            let base2;
            let number2 = "";
            if (token.text === "'") {
              base2 = 8;
              token = context.popToken();
            } else if (token.text === '"') {
              base2 = 16;
              token = context.popToken();
            } else if (token.text === "`") {
              token = context.popToken();
              if (token.text[0] === "\\") {
                number2 = token.text.charCodeAt(1);
              } else if (token.text === "EOF") {
                throw new src_ParseError("\\char` missing argument");
              } else {
                number2 = token.text.charCodeAt(0);
              }
            } else {
              base2 = 10;
            }
            if (base2) {
              number2 = digitToNumber2[token.text];
              if (number2 == null || number2 >= base2) {
                throw new src_ParseError("Invalid base-" + base2 + " digit " + token.text);
              }
              let digit;
              while ((digit = digitToNumber2[context.future().text]) != null && digit < base2) {
                number2 *= base2;
                number2 += digit;
                context.popToken();
              }
            }
            return "\\@char{" + number2 + "}";
          });
          const newcommand2 = (context, existsOK, nonexistsOK, skipIfExists) => {
            let arg = context.consumeArg().tokens;
            if (arg.length !== 1) {
              throw new src_ParseError("\\newcommand's first argument must be a macro name");
            }
            const name = arg[0].text;
            const exists = context.isDefined(name);
            if (exists && !existsOK) {
              throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
            }
            if (!exists && !nonexistsOK) {
              throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
            }
            let numArgs = 0;
            arg = context.consumeArg().tokens;
            if (arg.length === 1 && arg[0].text === "[") {
              let argText = "";
              let token = context.expandNextToken();
              while (token.text !== "]" && token.text !== "EOF") {
                argText += token.text;
                token = context.expandNextToken();
              }
              if (!argText.match(/^\s*[0-9]+\s*$/)) {
                throw new src_ParseError("Invalid number of arguments: " + argText);
              }
              numArgs = parseInt(argText);
              arg = context.consumeArg().tokens;
            }
            if (!(exists && skipIfExists)) {
              context.macros.set(name, {
                tokens: arg,
                numArgs
              });
            }
            return "";
          };
          defineMacro2("\\newcommand", (context) => newcommand2(context, false, true, false));
          defineMacro2("\\renewcommand", (context) => newcommand2(context, true, false, false));
          defineMacro2("\\providecommand", (context) => newcommand2(context, true, true, true));
          defineMacro2("\\message", (context) => {
            const arg = context.consumeArgs(1)[0];
            console.log(arg.reverse().map((token) => token.text).join(""));
            return "";
          });
          defineMacro2("\\errmessage", (context) => {
            const arg = context.consumeArgs(1)[0];
            console.error(arg.reverse().map((token) => token.text).join(""));
            return "";
          });
          defineMacro2("\\show", (context) => {
            const tok = context.popToken();
            const name = tok.text;
            console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
            return "";
          });
          defineMacro2("\\bgroup", "{");
          defineMacro2("\\egroup", "}");
          defineMacro2("~", "\\nobreakspace");
          defineMacro2("\\lq", "`");
          defineMacro2("\\rq", "'");
          defineMacro2("\\aa", "\\r a");
          defineMacro2("\\AA", "\\r A");
          defineMacro2("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
          defineMacro2("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
          defineMacro2("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
          defineMacro2("", "\\mathscr{B}");
          defineMacro2("", "\\mathscr{E}");
          defineMacro2("", "\\mathscr{F}");
          defineMacro2("", "\\mathscr{H}");
          defineMacro2("", "\\mathscr{I}");
          defineMacro2("", "\\mathscr{L}");
          defineMacro2("", "\\mathscr{M}");
          defineMacro2("", "\\mathscr{R}");
          defineMacro2("", "\\mathfrak{C}");
          defineMacro2("", "\\mathfrak{H}");
          defineMacro2("", "\\mathfrak{Z}");
          defineMacro2("\\Bbbk", "\\Bbb{k}");
          defineMacro2("", "\\cdotp");
          defineMacro2("\\llap", "\\mathllap{\\textrm{#1}}");
          defineMacro2("\\rlap", "\\mathrlap{\\textrm{#1}}");
          defineMacro2("\\clap", "\\mathclap{\\textrm{#1}}");
          defineMacro2("\\mathstrut", "\\vphantom{(}");
          defineMacro2("\\underbar", "\\underline{\\text{#1}}");
          defineMacro2("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
          defineMacro2("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
          defineMacro2("\\ne", "\\neq");
          defineMacro2("", "\\neq");
          defineMacro2("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\notin");
          defineMacro2("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
          defineMacro2("", "\\perp");
          defineMacro2("", "\\mathclose{!\\mkern-0.8mu!}");
          defineMacro2("", "\\notni");
          defineMacro2("", "\\ulcorner");
          defineMacro2("", "\\urcorner");
          defineMacro2("", "\\llcorner");
          defineMacro2("", "\\lrcorner");
          defineMacro2("", "\\copyright");
          defineMacro2("", "\\textregistered");
          defineMacro2("", "\\textregistered");
          defineMacro2("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
          defineMacro2("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
          defineMacro2("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
          defineMacro2("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
          defineMacro2("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
          defineMacro2("", "\\vdots");
          defineMacro2("\\varGamma", "\\mathit{\\Gamma}");
          defineMacro2("\\varDelta", "\\mathit{\\Delta}");
          defineMacro2("\\varTheta", "\\mathit{\\Theta}");
          defineMacro2("\\varLambda", "\\mathit{\\Lambda}");
          defineMacro2("\\varXi", "\\mathit{\\Xi}");
          defineMacro2("\\varPi", "\\mathit{\\Pi}");
          defineMacro2("\\varSigma", "\\mathit{\\Sigma}");
          defineMacro2("\\varUpsilon", "\\mathit{\\Upsilon}");
          defineMacro2("\\varPhi", "\\mathit{\\Phi}");
          defineMacro2("\\varPsi", "\\mathit{\\Psi}");
          defineMacro2("\\varOmega", "\\mathit{\\Omega}");
          defineMacro2("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
          defineMacro2("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
          defineMacro2("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
          defineMacro2("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
          defineMacro2("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
          defineMacro2("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
          defineMacro2("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
          defineMacro2("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
          const dotsByToken2 = {
            ",": "\\dotsc",
            "\\not": "\\dotsb",
            // \keybin@ checks for the following:
            "+": "\\dotsb",
            "=": "\\dotsb",
            "<": "\\dotsb",
            ">": "\\dotsb",
            "-": "\\dotsb",
            "*": "\\dotsb",
            ":": "\\dotsb",
            // Symbols whose definition starts with \DOTSB:
            "\\DOTSB": "\\dotsb",
            "\\coprod": "\\dotsb",
            "\\bigvee": "\\dotsb",
            "\\bigwedge": "\\dotsb",
            "\\biguplus": "\\dotsb",
            "\\bigcap": "\\dotsb",
            "\\bigcup": "\\dotsb",
            "\\prod": "\\dotsb",
            "\\sum": "\\dotsb",
            "\\bigotimes": "\\dotsb",
            "\\bigoplus": "\\dotsb",
            "\\bigodot": "\\dotsb",
            "\\bigsqcup": "\\dotsb",
            "\\And": "\\dotsb",
            "\\longrightarrow": "\\dotsb",
            "\\Longrightarrow": "\\dotsb",
            "\\longleftarrow": "\\dotsb",
            "\\Longleftarrow": "\\dotsb",
            "\\longleftrightarrow": "\\dotsb",
            "\\Longleftrightarrow": "\\dotsb",
            "\\mapsto": "\\dotsb",
            "\\longmapsto": "\\dotsb",
            "\\hookrightarrow": "\\dotsb",
            "\\doteq": "\\dotsb",
            // Symbols whose definition starts with \mathbin:
            "\\mathbin": "\\dotsb",
            // Symbols whose definition starts with \mathrel:
            "\\mathrel": "\\dotsb",
            "\\relbar": "\\dotsb",
            "\\Relbar": "\\dotsb",
            "\\xrightarrow": "\\dotsb",
            "\\xleftarrow": "\\dotsb",
            // Symbols whose definition starts with \DOTSI:
            "\\DOTSI": "\\dotsi",
            "\\int": "\\dotsi",
            "\\oint": "\\dotsi",
            "\\iint": "\\dotsi",
            "\\iiint": "\\dotsi",
            "\\iiiint": "\\dotsi",
            "\\idotsint": "\\dotsi",
            // Symbols whose definition starts with \DOTSX:
            "\\DOTSX": "\\dotsx"
          };
          defineMacro2("\\dots", function(context) {
            let thedots = "\\dotso";
            const next = context.expandAfterFuture().text;
            if (next in dotsByToken2) {
              thedots = dotsByToken2[next];
            } else if (next.slice(0, 4) === "\\not") {
              thedots = "\\dotsb";
            } else if (next in src_symbols.math) {
              if (["bin", "rel"].includes(src_symbols.math[next].group)) {
                thedots = "\\dotsb";
              }
            }
            return thedots;
          });
          const spaceAfterDots2 = {
            // \rightdelim@ checks for the following:
            ")": true,
            "]": true,
            "\\rbrack": true,
            "\\}": true,
            "\\rbrace": true,
            "\\rangle": true,
            "\\rceil": true,
            "\\rfloor": true,
            "\\rgroup": true,
            "\\rmoustache": true,
            "\\right": true,
            "\\bigr": true,
            "\\biggr": true,
            "\\Bigr": true,
            "\\Biggr": true,
            // \extra@ also tests for the following:
            "$": true,
            // \extrap@ checks for the following:
            ";": true,
            ".": true,
            ",": true
          };
          defineMacro2("\\dotso", function(context) {
            const next = context.future().text;
            if (next in spaceAfterDots2) {
              return "\\ldots\\,";
            } else {
              return "\\ldots";
            }
          });
          defineMacro2("\\dotsc", function(context) {
            const next = context.future().text;
            if (next in spaceAfterDots2 && next !== ",") {
              return "\\ldots\\,";
            } else {
              return "\\ldots";
            }
          });
          defineMacro2("\\cdots", function(context) {
            const next = context.future().text;
            if (next in spaceAfterDots2) {
              return "\\@cdots\\,";
            } else {
              return "\\@cdots";
            }
          });
          defineMacro2("\\dotsb", "\\cdots");
          defineMacro2("\\dotsm", "\\cdots");
          defineMacro2("\\dotsi", "\\!\\cdots");
          defineMacro2("\\dotsx", "\\ldots\\,");
          defineMacro2("\\DOTSI", "\\relax");
          defineMacro2("\\DOTSB", "\\relax");
          defineMacro2("\\DOTSX", "\\relax");
          defineMacro2("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
          defineMacro2("\\,", "\\tmspace+{3mu}{.1667em}");
          defineMacro2("\\thinspace", "\\,");
          defineMacro2("\\>", "\\mskip{4mu}");
          defineMacro2("\\:", "\\tmspace+{4mu}{.2222em}");
          defineMacro2("\\medspace", "\\:");
          defineMacro2("\\;", "\\tmspace+{5mu}{.2777em}");
          defineMacro2("\\thickspace", "\\;");
          defineMacro2("\\!", "\\tmspace-{3mu}{.1667em}");
          defineMacro2("\\negthinspace", "\\!");
          defineMacro2("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
          defineMacro2("\\negthickspace", "\\tmspace-{5mu}{.277em}");
          defineMacro2("\\enspace", "\\kern.5em ");
          defineMacro2("\\enskip", "\\hskip.5em\\relax");
          defineMacro2("\\quad", "\\hskip1em\\relax");
          defineMacro2("\\qquad", "\\hskip2em\\relax");
          defineMacro2("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
          defineMacro2("\\tag@paren", "\\tag@literal{({#1})}");
          defineMacro2("\\tag@literal", (context) => {
            if (context.macros.get("\\df@tag")) {
              throw new src_ParseError("Multiple \\tag");
            }
            return "\\gdef\\df@tag{\\text{#1}}";
          });
          defineMacro2("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
          defineMacro2("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
          defineMacro2("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
          defineMacro2("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
          defineMacro2("\\newline", "\\\\\\relax");
          defineMacro2("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
          const latexRaiseA2 = makeEm3(fontMetricsData2["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData2["Main-Regular"]["A".charCodeAt(0)][1]);
          defineMacro2("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA2 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
          defineMacro2("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA2 + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
          defineMacro2("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
          defineMacro2("\\@hspace", "\\hskip #1\\relax");
          defineMacro2("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
          defineMacro2("\\ordinarycolon", ":");
          defineMacro2("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
          defineMacro2("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
          defineMacro2("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
          defineMacro2("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
          defineMacro2("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
          defineMacro2("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
          defineMacro2("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
          defineMacro2("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
          defineMacro2("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
          defineMacro2("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
          defineMacro2("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
          defineMacro2("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
          defineMacro2("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
          defineMacro2("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
          defineMacro2("", "\\dblcolon");
          defineMacro2("", "\\eqcolon");
          defineMacro2("", "\\coloneqq");
          defineMacro2("", "\\eqqcolon");
          defineMacro2("", "\\Coloneqq");
          defineMacro2("\\ratio", "\\vcentcolon");
          defineMacro2("\\coloncolon", "\\dblcolon");
          defineMacro2("\\colonequals", "\\coloneqq");
          defineMacro2("\\coloncolonequals", "\\Coloneqq");
          defineMacro2("\\equalscolon", "\\eqqcolon");
          defineMacro2("\\equalscoloncolon", "\\Eqqcolon");
          defineMacro2("\\colonminus", "\\coloneq");
          defineMacro2("\\coloncolonminus", "\\Coloneq");
          defineMacro2("\\minuscolon", "\\eqcolon");
          defineMacro2("\\minuscoloncolon", "\\Eqcolon");
          defineMacro2("\\coloncolonapprox", "\\Colonapprox");
          defineMacro2("\\coloncolonsim", "\\Colonsim");
          defineMacro2("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
          defineMacro2("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
          defineMacro2("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
          defineMacro2("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
          defineMacro2("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
          defineMacro2("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
          defineMacro2("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
          defineMacro2("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
          defineMacro2("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
          defineMacro2("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
          defineMacro2("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
          defineMacro2("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
          defineMacro2("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
          defineMacro2("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
          defineMacro2("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
          defineMacro2("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
          defineMacro2("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
          defineMacro2("\\nleqq", "\\html@mathml{\\@nleqq}{}");
          defineMacro2("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
          defineMacro2("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
          defineMacro2("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
          defineMacro2("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
          defineMacro2("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
          defineMacro2("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
          defineMacro2("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
          defineMacro2("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
          defineMacro2("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
          defineMacro2("\\imath", "\\html@mathml{\\@imath}{}");
          defineMacro2("\\jmath", "\\html@mathml{\\@jmath}{}");
          defineMacro2("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
          defineMacro2("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
          defineMacro2("", "\\llbracket");
          defineMacro2("", "\\rrbracket");
          defineMacro2("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
          defineMacro2("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
          defineMacro2("", "\\lBrace");
          defineMacro2("", "\\rBrace");
          defineMacro2("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
          defineMacro2("", "\\minuso");
          defineMacro2("\\darr", "\\downarrow");
          defineMacro2("\\dArr", "\\Downarrow");
          defineMacro2("\\Darr", "\\Downarrow");
          defineMacro2("\\lang", "\\langle");
          defineMacro2("\\rang", "\\rangle");
          defineMacro2("\\uarr", "\\uparrow");
          defineMacro2("\\uArr", "\\Uparrow");
          defineMacro2("\\Uarr", "\\Uparrow");
          defineMacro2("\\N", "\\mathbb{N}");
          defineMacro2("\\R", "\\mathbb{R}");
          defineMacro2("\\Z", "\\mathbb{Z}");
          defineMacro2("\\alef", "\\aleph");
          defineMacro2("\\alefsym", "\\aleph");
          defineMacro2("\\Alpha", "\\mathrm{A}");
          defineMacro2("\\Beta", "\\mathrm{B}");
          defineMacro2("\\bull", "\\bullet");
          defineMacro2("\\Chi", "\\mathrm{X}");
          defineMacro2("\\clubs", "\\clubsuit");
          defineMacro2("\\cnums", "\\mathbb{C}");
          defineMacro2("\\Complex", "\\mathbb{C}");
          defineMacro2("\\Dagger", "\\ddagger");
          defineMacro2("\\diamonds", "\\diamondsuit");
          defineMacro2("\\empty", "\\emptyset");
          defineMacro2("\\Epsilon", "\\mathrm{E}");
          defineMacro2("\\Eta", "\\mathrm{H}");
          defineMacro2("\\exist", "\\exists");
          defineMacro2("\\harr", "\\leftrightarrow");
          defineMacro2("\\hArr", "\\Leftrightarrow");
          defineMacro2("\\Harr", "\\Leftrightarrow");
          defineMacro2("\\hearts", "\\heartsuit");
          defineMacro2("\\image", "\\Im");
          defineMacro2("\\infin", "\\infty");
          defineMacro2("\\Iota", "\\mathrm{I}");
          defineMacro2("\\isin", "\\in");
          defineMacro2("\\Kappa", "\\mathrm{K}");
          defineMacro2("\\larr", "\\leftarrow");
          defineMacro2("\\lArr", "\\Leftarrow");
          defineMacro2("\\Larr", "\\Leftarrow");
          defineMacro2("\\lrarr", "\\leftrightarrow");
          defineMacro2("\\lrArr", "\\Leftrightarrow");
          defineMacro2("\\Lrarr", "\\Leftrightarrow");
          defineMacro2("\\Mu", "\\mathrm{M}");
          defineMacro2("\\natnums", "\\mathbb{N}");
          defineMacro2("\\Nu", "\\mathrm{N}");
          defineMacro2("\\Omicron", "\\mathrm{O}");
          defineMacro2("\\plusmn", "\\pm");
          defineMacro2("\\rarr", "\\rightarrow");
          defineMacro2("\\rArr", "\\Rightarrow");
          defineMacro2("\\Rarr", "\\Rightarrow");
          defineMacro2("\\real", "\\Re");
          defineMacro2("\\reals", "\\mathbb{R}");
          defineMacro2("\\Reals", "\\mathbb{R}");
          defineMacro2("\\Rho", "\\mathrm{P}");
          defineMacro2("\\sdot", "\\cdot");
          defineMacro2("\\sect", "\\S");
          defineMacro2("\\spades", "\\spadesuit");
          defineMacro2("\\sub", "\\subset");
          defineMacro2("\\sube", "\\subseteq");
          defineMacro2("\\supe", "\\supseteq");
          defineMacro2("\\Tau", "\\mathrm{T}");
          defineMacro2("\\thetasym", "\\vartheta");
          defineMacro2("\\weierp", "\\wp");
          defineMacro2("\\Zeta", "\\mathrm{Z}");
          defineMacro2("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
          defineMacro2("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
          defineMacro2("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
          defineMacro2("\\bra", "\\mathinner{\\langle{#1}|}");
          defineMacro2("\\ket", "\\mathinner{|{#1}\\rangle}");
          defineMacro2("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
          defineMacro2("\\Bra", "\\left\\langle#1\\right|");
          defineMacro2("\\Ket", "\\left|#1\\right\\rangle");
          const braketHelper2 = (one2) => (context) => {
            const left = context.consumeArg().tokens;
            const middle = context.consumeArg().tokens;
            const middleDouble = context.consumeArg().tokens;
            const right = context.consumeArg().tokens;
            const oldMiddle = context.macros.get("|");
            const oldMiddleDouble = context.macros.get("\\|");
            context.macros.beginGroup();
            const midMacro = (double) => (context2) => {
              if (one2) {
                context2.macros.set("|", oldMiddle);
                if (middleDouble.length) {
                  context2.macros.set("\\|", oldMiddleDouble);
                }
              }
              let doubled = double;
              if (!double && middleDouble.length) {
                const nextToken = context2.future();
                if (nextToken.text === "|") {
                  context2.popToken();
                  doubled = true;
                }
              }
              return {
                tokens: doubled ? middleDouble : middle,
                numArgs: 0
              };
            };
            context.macros.set("|", midMacro(false));
            if (middleDouble.length) {
              context.macros.set("\\|", midMacro(true));
            }
            const arg = context.consumeArg().tokens;
            const expanded = context.expandTokens([
              ...right,
              ...arg,
              ...left
              // reversed
            ]);
            context.macros.endGroup();
            return {
              tokens: expanded.reverse(),
              numArgs: 0
            };
          };
          defineMacro2("\\bra@ket", braketHelper2(false));
          defineMacro2("\\bra@set", braketHelper2(true));
          defineMacro2("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
          defineMacro2("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
          defineMacro2("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
          defineMacro2("\\angln", "{\\angl n}");
          defineMacro2("\\blue", "\\textcolor{##6495ed}{#1}");
          defineMacro2("\\orange", "\\textcolor{##ffa500}{#1}");
          defineMacro2("\\pink", "\\textcolor{##ff00af}{#1}");
          defineMacro2("\\red", "\\textcolor{##df0030}{#1}");
          defineMacro2("\\green", "\\textcolor{##28ae7b}{#1}");
          defineMacro2("\\gray", "\\textcolor{gray}{#1}");
          defineMacro2("\\purple", "\\textcolor{##9d38bd}{#1}");
          defineMacro2("\\blueA", "\\textcolor{##ccfaff}{#1}");
          defineMacro2("\\blueB", "\\textcolor{##80f6ff}{#1}");
          defineMacro2("\\blueC", "\\textcolor{##63d9ea}{#1}");
          defineMacro2("\\blueD", "\\textcolor{##11accd}{#1}");
          defineMacro2("\\blueE", "\\textcolor{##0c7f99}{#1}");
          defineMacro2("\\tealA", "\\textcolor{##94fff5}{#1}");
          defineMacro2("\\tealB", "\\textcolor{##26edd5}{#1}");
          defineMacro2("\\tealC", "\\textcolor{##01d1c1}{#1}");
          defineMacro2("\\tealD", "\\textcolor{##01a995}{#1}");
          defineMacro2("\\tealE", "\\textcolor{##208170}{#1}");
          defineMacro2("\\greenA", "\\textcolor{##b6ffb0}{#1}");
          defineMacro2("\\greenB", "\\textcolor{##8af281}{#1}");
          defineMacro2("\\greenC", "\\textcolor{##74cf70}{#1}");
          defineMacro2("\\greenD", "\\textcolor{##1fab54}{#1}");
          defineMacro2("\\greenE", "\\textcolor{##0d923f}{#1}");
          defineMacro2("\\goldA", "\\textcolor{##ffd0a9}{#1}");
          defineMacro2("\\goldB", "\\textcolor{##ffbb71}{#1}");
          defineMacro2("\\goldC", "\\textcolor{##ff9c39}{#1}");
          defineMacro2("\\goldD", "\\textcolor{##e07d10}{#1}");
          defineMacro2("\\goldE", "\\textcolor{##a75a05}{#1}");
          defineMacro2("\\redA", "\\textcolor{##fca9a9}{#1}");
          defineMacro2("\\redB", "\\textcolor{##ff8482}{#1}");
          defineMacro2("\\redC", "\\textcolor{##f9685d}{#1}");
          defineMacro2("\\redD", "\\textcolor{##e84d39}{#1}");
          defineMacro2("\\redE", "\\textcolor{##bc2612}{#1}");
          defineMacro2("\\maroonA", "\\textcolor{##ffbde0}{#1}");
          defineMacro2("\\maroonB", "\\textcolor{##ff92c6}{#1}");
          defineMacro2("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
          defineMacro2("\\maroonD", "\\textcolor{##ca337c}{#1}");
          defineMacro2("\\maroonE", "\\textcolor{##9e034e}{#1}");
          defineMacro2("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
          defineMacro2("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
          defineMacro2("\\purpleC", "\\textcolor{##aa87ff}{#1}");
          defineMacro2("\\purpleD", "\\textcolor{##7854ab}{#1}");
          defineMacro2("\\purpleE", "\\textcolor{##543b78}{#1}");
          defineMacro2("\\mintA", "\\textcolor{##f5f9e8}{#1}");
          defineMacro2("\\mintB", "\\textcolor{##edf2df}{#1}");
          defineMacro2("\\mintC", "\\textcolor{##e0e5cc}{#1}");
          defineMacro2("\\grayA", "\\textcolor{##f6f7f7}{#1}");
          defineMacro2("\\grayB", "\\textcolor{##f0f1f2}{#1}");
          defineMacro2("\\grayC", "\\textcolor{##e3e5e6}{#1}");
          defineMacro2("\\grayD", "\\textcolor{##d6d8da}{#1}");
          defineMacro2("\\grayE", "\\textcolor{##babec2}{#1}");
          defineMacro2("\\grayF", "\\textcolor{##888d93}{#1}");
          defineMacro2("\\grayG", "\\textcolor{##626569}{#1}");
          defineMacro2("\\grayH", "\\textcolor{##3b3e40}{#1}");
          defineMacro2("\\grayI", "\\textcolor{##21242c}{#1}");
          defineMacro2("\\kaBlue", "\\textcolor{##314453}{#1}");
          defineMacro2("\\kaGreen", "\\textcolor{##71B307}{#1}");
          const implicitCommands2 = {
            "^": true,
            // Parser.js
            "_": true,
            // Parser.js
            "\\limits": true,
            // Parser.js
            "\\nolimits": true
            // Parser.js
          };
          class MacroExpander2 {
            constructor(input, settings, mode) {
              this.settings = void 0;
              this.expansionCount = void 0;
              this.lexer = void 0;
              this.macros = void 0;
              this.stack = void 0;
              this.mode = void 0;
              this.settings = settings;
              this.expansionCount = 0;
              this.feed(input);
              this.macros = new Namespace2(src_macros, settings.macros);
              this.mode = mode;
              this.stack = [];
            }
            /**
             * Feed a new input string to the same MacroExpander
             * (with existing macros etc.).
             */
            feed(input) {
              this.lexer = new Lexer2(input, this.settings);
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(newMode) {
              this.mode = newMode;
            }
            /**
             * Start a new group nesting within all namespaces.
             */
            beginGroup() {
              this.macros.beginGroup();
            }
            /**
             * End current group nesting within all namespaces.
             */
            endGroup() {
              this.macros.endGroup();
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              this.macros.endGroups();
            }
            /**
             * Returns the topmost token on the stack, without expanding it.
             * Similar in behavior to TeX's `\futurelet`.
             */
            future() {
              if (this.stack.length === 0) {
                this.pushToken(this.lexer.lex());
              }
              return this.stack[this.stack.length - 1];
            }
            /**
             * Remove and return the next unexpanded token.
             */
            popToken() {
              this.future();
              return this.stack.pop();
            }
            /**
             * Add a given token to the token stack.  In particular, this get be used
             * to put back a token returned from one of the other methods.
             */
            pushToken(token) {
              this.stack.push(token);
            }
            /**
             * Append an array of tokens to the token stack.
             */
            pushTokens(tokens) {
              this.stack.push(...tokens);
            }
            /**
             * Find an macro argument without expanding tokens and append the array of
             * tokens to the token stack. Uses Token as a container for the result.
             */
            scanArgument(isOptional) {
              let start;
              let end;
              let tokens;
              if (isOptional) {
                this.consumeSpaces();
                if (this.future().text !== "[") {
                  return null;
                }
                start = this.popToken();
                ({
                  tokens,
                  end
                } = this.consumeArg(["]"]));
              } else {
                ({
                  tokens,
                  start,
                  end
                } = this.consumeArg());
              }
              this.pushToken(new Token3("EOF", end.loc));
              this.pushTokens(tokens);
              return new Token3("", SourceLocation2.range(start, end));
            }
            /**
             * Consume all following space tokens, without expansion.
             */
            consumeSpaces() {
              for (; ; ) {
                const token = this.future();
                if (token.text === " ") {
                  this.stack.pop();
                } else {
                  break;
                }
              }
            }
            /**
             * Consume an argument from the token stream, and return the resulting array
             * of tokens and start/end token.
             */
            consumeArg(delims2) {
              const tokens = [];
              const isDelimited = delims2 && delims2.length > 0;
              if (!isDelimited) {
                this.consumeSpaces();
              }
              const start = this.future();
              let tok;
              let depth = 0;
              let match2 = 0;
              do {
                tok = this.popToken();
                tokens.push(tok);
                if (tok.text === "{") {
                  ++depth;
                } else if (tok.text === "}") {
                  --depth;
                  if (depth === -1) {
                    throw new src_ParseError("Extra }", tok);
                  }
                } else if (tok.text === "EOF") {
                  throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims2 && isDelimited ? delims2[match2] : "}") + "'", tok);
                }
                if (delims2 && isDelimited) {
                  if ((depth === 0 || depth === 1 && delims2[match2] === "{") && tok.text === delims2[match2]) {
                    ++match2;
                    if (match2 === delims2.length) {
                      tokens.splice(-match2, match2);
                      break;
                    }
                  } else {
                    match2 = 0;
                  }
                }
              } while (depth !== 0 || isDelimited);
              if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
                tokens.pop();
                tokens.shift();
              }
              tokens.reverse();
              return {
                tokens,
                start,
                end: tok
              };
            }
            /**
             * Consume the specified number of (delimited) arguments from the token
             * stream and return the resulting array of arguments.
             */
            consumeArgs(numArgs, delimiters3) {
              if (delimiters3) {
                if (delimiters3.length !== numArgs + 1) {
                  throw new src_ParseError("The length of delimiters doesn't match the number of args!");
                }
                const delims2 = delimiters3[0];
                for (let i = 0; i < delims2.length; i++) {
                  const tok = this.popToken();
                  if (delims2[i] !== tok.text) {
                    throw new src_ParseError("Use of the macro doesn't match its definition", tok);
                  }
                }
              }
              const args = [];
              for (let i = 0; i < numArgs; i++) {
                args.push(this.consumeArg(delimiters3 && delimiters3[i + 1]).tokens);
              }
              return args;
            }
            /**
             * Increment `expansionCount` by the specified amount.
             * Throw an error if it exceeds `maxExpand`.
             */
            countExpansion(amount) {
              this.expansionCount += amount;
              if (this.expansionCount > this.settings.maxExpand) {
                throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
              }
            }
            /**
             * Expand the next token only once if possible.
             *
             * If the token is expanded, the resulting tokens will be pushed onto
             * the stack in reverse order, and the number of such tokens will be
             * returned.  This number might be zero or positive.
             *
             * If not, the return value is `false`, and the next token remains at the
             * top of the stack.
             *
             * In either case, the next token will be on the top of the stack,
             * or the stack will be empty (in case of empty expansion
             * and no other tokens).
             *
             * Used to implement `expandAfterFuture` and `expandNextToken`.
             *
             * If expandableOnly, only expandable tokens are expanded and
             * an undefined control sequence results in an error.
             */
            expandOnce(expandableOnly) {
              const topToken = this.popToken();
              const name = topToken.text;
              const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
              if (expansion == null || expandableOnly && expansion.unexpandable) {
                if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
                  throw new src_ParseError("Undefined control sequence: " + name);
                }
                this.pushToken(topToken);
                return false;
              }
              this.countExpansion(1);
              let tokens = expansion.tokens;
              const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
              if (expansion.numArgs) {
                tokens = tokens.slice();
                for (let i = tokens.length - 1; i >= 0; --i) {
                  let tok = tokens[i];
                  if (tok.text === "#") {
                    if (i === 0) {
                      throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                    }
                    tok = tokens[--i];
                    if (tok.text === "#") {
                      tokens.splice(i + 1, 1);
                    } else if (/^[1-9]$/.test(tok.text)) {
                      tokens.splice(i, 2, ...args[+tok.text - 1]);
                    } else {
                      throw new src_ParseError("Not a valid argument number", tok);
                    }
                  }
                }
              }
              this.pushTokens(tokens);
              return tokens.length;
            }
            /**
             * Expand the next token only once (if possible), and return the resulting
             * top token on the stack (without removing anything from the stack).
             * Similar in behavior to TeX's `\expandafter\futurelet`.
             * Equivalent to expandOnce() followed by future().
             */
            expandAfterFuture() {
              this.expandOnce();
              return this.future();
            }
            /**
             * Recursively expand first token, then return first non-expandable token.
             */
            expandNextToken() {
              for (; ; ) {
                if (this.expandOnce() === false) {
                  const token = this.stack.pop();
                  if (token.treatAsRelax) {
                    token.text = "\\relax";
                  }
                  return token;
                }
              }
              throw new Error();
            }
            /**
             * Fully expand the given macro name and return the resulting list of
             * tokens, or return `undefined` if no such macro is defined.
             */
            expandMacro(name) {
              return this.macros.has(name) ? this.expandTokens([new Token3(name)]) : void 0;
            }
            /**
             * Fully expand the given token stream and return the resulting list of
             * tokens.  Note that the input tokens are in reverse order, but the
             * output tokens are in forward order.
             */
            expandTokens(tokens) {
              const output = [];
              const oldStackLength = this.stack.length;
              this.pushTokens(tokens);
              while (this.stack.length > oldStackLength) {
                if (this.expandOnce(true) === false) {
                  const token = this.stack.pop();
                  if (token.treatAsRelax) {
                    token.noexpand = false;
                    token.treatAsRelax = false;
                  }
                  output.push(token);
                }
              }
              this.countExpansion(output.length);
              return output;
            }
            /**
             * Fully expand the given macro name and return the result as a string,
             * or return `undefined` if no such macro is defined.
             */
            expandMacroAsText(name) {
              const tokens = this.expandMacro(name);
              if (tokens) {
                return tokens.map((token) => token.text).join("");
              } else {
                return tokens;
              }
            }
            /**
             * Returns the expanded macro as a reversed array of tokens and a macro
             * argument count.  Or returns `null` if no such macro.
             */
            _getExpansion(name) {
              const definition = this.macros.get(name);
              if (definition == null) {
                return definition;
              }
              if (name.length === 1) {
                const catcode = this.lexer.catcodes[name];
                if (catcode != null && catcode !== 13) {
                  return;
                }
              }
              const expansion = typeof definition === "function" ? definition(this) : definition;
              if (typeof expansion === "string") {
                let numArgs = 0;
                if (expansion.indexOf("#") !== -1) {
                  const stripped = expansion.replace(/##/g, "");
                  while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                    ++numArgs;
                  }
                }
                const bodyLexer = new Lexer2(expansion, this.settings);
                const tokens = [];
                let tok = bodyLexer.lex();
                while (tok.text !== "EOF") {
                  tokens.push(tok);
                  tok = bodyLexer.lex();
                }
                tokens.reverse();
                const expanded = {
                  tokens,
                  numArgs
                };
                return expanded;
              }
              return expansion;
            }
            /**
             * Determine whether a command is currently "defined" (has some
             * functionality), meaning that it's a macro (in the current group),
             * a function, a symbol, or one of the special commands listed in
             * `implicitCommands`.
             */
            isDefined(name) {
              return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands2.hasOwnProperty(name);
            }
            /**
             * Determine whether a command is expandable.
             */
            isExpandable(name) {
              const macro = this.macros.get(name);
              return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
            }
          }
          const unicodeSubRegEx2 = /^[]/;
          const uSubsAndSups2 = Object.freeze({
            "": "+",
            "": "-",
            "": "=",
            "": "(",
            "": ")",
            "": "0",
            "": "1",
            "": "2",
            "": "3",
            "": "4",
            "": "5",
            "": "6",
            "": "7",
            "": "8",
            "": "9",
            "": "a",
            "": "e",
            "": "h",
            "": "i",
            "": "j",
            "": "k",
            "": "l",
            "": "m",
            "": "n",
            "": "o",
            "": "p",
            "": "r",
            "": "s",
            "": "t",
            "": "u",
            "": "v",
            "": "x",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "+",
            "": "-",
            "": "=",
            "": "(",
            "": ")",
            "": "0",
            "": "1",
            "": "2",
            "": "3",
            "": "4",
            "": "5",
            "": "6",
            "": "7",
            "": "8",
            "": "9",
            "": "A",
            "": "B",
            "": "D",
            "": "E",
            "": "G",
            "": "H",
            "": "I",
            "": "J",
            "": "K",
            "": "L",
            "": "M",
            "": "N",
            "": "O",
            "": "P",
            "": "R",
            "": "T",
            "": "U",
            "": "V",
            "": "W",
            "": "a",
            "": "b",
            "": "c",
            "": "d",
            "": "e",
            "": "f",
            "": "g",
            "": "h",
            "": "i",
            "": "j",
            "": "k",
            "": "l",
            "": "m",
            "": "n",
            "": "o",
            "": "p",
            "": "r",
            "": "s",
            "": "t",
            "": "u",
            "": "v",
            "": "w",
            "": "x",
            "": "y",
            "": "z",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": ""
          });
          const unicodeAccents2 = {
            "": {
              "text": "\\'",
              "math": "\\acute"
            },
            "": {
              "text": "\\`",
              "math": "\\grave"
            },
            "": {
              "text": '\\"',
              "math": "\\ddot"
            },
            "": {
              "text": "\\~",
              "math": "\\tilde"
            },
            "": {
              "text": "\\=",
              "math": "\\bar"
            },
            "": {
              "text": "\\u",
              "math": "\\breve"
            },
            "": {
              "text": "\\v",
              "math": "\\check"
            },
            "": {
              "text": "\\^",
              "math": "\\hat"
            },
            "": {
              "text": "\\.",
              "math": "\\dot"
            },
            "": {
              "text": "\\r",
              "math": "\\mathring"
            },
            "": {
              "text": "\\H"
            },
            "": {
              "text": "\\c"
            }
          };
          const unicodeSymbols2 = {
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "a",
            "": "b",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "c",
            "": "d",
            "": "d",
            "": "d",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "e",
            "": "f",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "g",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "h",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "i",
            "": "j",
            "": "j",
            "": "k",
            "": "k",
            "": "k",
            "": "l",
            "": "l",
            "": "l",
            "": "m",
            "": "m",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "n",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "o",
            "": "p",
            "": "p",
            "": "r",
            "": "r",
            "": "r",
            "": "r",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "s",
            "": "t",
            "": "t",
            "": "t",
            "": "t",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "u",
            "": "v",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "w",
            "": "x",
            "": "x",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "y",
            "": "z",
            "": "z",
            "": "z",
            "": "z",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "A",
            "": "B",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "C",
            "": "D",
            "": "D",
            "": "D",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "E",
            "": "F",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "G",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "H",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "I",
            "": "J",
            "": "K",
            "": "K",
            "": "K",
            "": "L",
            "": "L",
            "": "L",
            "": "M",
            "": "M",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "N",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "O",
            "": "P",
            "": "P",
            "": "R",
            "": "R",
            "": "R",
            "": "R",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "S",
            "": "T",
            "": "T",
            "": "T",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "U",
            "": "V",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "W",
            "": "X",
            "": "X",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Y",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "Z",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": "",
            "": ""
          };
          class Parser2 {
            constructor(input, settings) {
              this.mode = void 0;
              this.gullet = void 0;
              this.settings = void 0;
              this.leftrightDepth = void 0;
              this.nextToken = void 0;
              this.mode = "math";
              this.gullet = new MacroExpander2(input, settings, this.mode);
              this.settings = settings;
              this.leftrightDepth = 0;
            }
            /**
             * Checks a result to make sure it has the right type, and throws an
             * appropriate error otherwise.
             */
            expect(text2, consume) {
              if (consume === void 0) {
                consume = true;
              }
              if (this.fetch().text !== text2) {
                throw new src_ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
              }
              if (consume) {
                this.consume();
              }
            }
            /**
             * Discards the current lookahead token, considering it consumed.
             */
            consume() {
              this.nextToken = null;
            }
            /**
             * Return the current lookahead token, or if there isn't one (at the
             * beginning, or if the previous lookahead token was consume()d),
             * fetch the next token as the new lookahead token and return it.
             */
            fetch() {
              if (this.nextToken == null) {
                this.nextToken = this.gullet.expandNextToken();
              }
              return this.nextToken;
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(newMode) {
              this.mode = newMode;
              this.gullet.switchMode(newMode);
            }
            /**
             * Main parsing function, which parses an entire input.
             */
            parse() {
              if (!this.settings.globalGroup) {
                this.gullet.beginGroup();
              }
              if (this.settings.colorIsTextColor) {
                this.gullet.macros.set("\\color", "\\textcolor");
              }
              try {
                const parse = this.parseExpression(false);
                this.expect("EOF");
                if (!this.settings.globalGroup) {
                  this.gullet.endGroup();
                }
                return parse;
              } finally {
                this.gullet.endGroups();
              }
            }
            /**
             * Fully parse a separate sequence of tokens as a separate job.
             * Tokens should be specified in reverse order, as in a MacroDefinition.
             */
            subparse(tokens) {
              const oldToken = this.nextToken;
              this.consume();
              this.gullet.pushToken(new Token3("}"));
              this.gullet.pushTokens(tokens);
              const parse = this.parseExpression(false);
              this.expect("}");
              this.nextToken = oldToken;
              return parse;
            }
            /**
             * Parses an "expression", which is a list of atoms.
             *
             * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
             *                 happens when functions have higher precedence than infix
             *                 nodes in implicit parses.
             *
             * `breakOnTokenText`: The text of the token that the expression should end
             *                     with, or `null` if something else should end the
             *                     expression.
             */
            parseExpression(breakOnInfix, breakOnTokenText) {
              const body = [];
              while (true) {
                if (this.mode === "math") {
                  this.consumeSpaces();
                }
                const lex = this.fetch();
                if (Parser2.endOfExpression.indexOf(lex.text) !== -1) {
                  break;
                }
                if (breakOnTokenText && lex.text === breakOnTokenText) {
                  break;
                }
                if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                  break;
                }
                const atom = this.parseAtom(breakOnTokenText);
                if (!atom) {
                  break;
                } else if (atom.type === "internal") {
                  continue;
                }
                body.push(atom);
              }
              if (this.mode === "text") {
                this.formLigatures(body);
              }
              return this.handleInfixNodes(body);
            }
            /**
             * Rewrites infix operators such as \over with corresponding commands such
             * as \frac.
             *
             * There can only be one infix operator per group.  If there's more than one
             * then the expression is ambiguous.  This can be resolved by adding {}.
             */
            handleInfixNodes(body) {
              let overIndex = -1;
              let funcName;
              for (let i = 0; i < body.length; i++) {
                if (body[i].type === "infix") {
                  if (overIndex !== -1) {
                    throw new src_ParseError("only one infix operator per group", body[i].token);
                  }
                  overIndex = i;
                  funcName = body[i].replaceWith;
                }
              }
              if (overIndex !== -1 && funcName) {
                let numerNode;
                let denomNode;
                const numerBody = body.slice(0, overIndex);
                const denomBody = body.slice(overIndex + 1);
                if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                  numerNode = numerBody[0];
                } else {
                  numerNode = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: numerBody
                  };
                }
                if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                  denomNode = denomBody[0];
                } else {
                  denomNode = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: denomBody
                  };
                }
                let node;
                if (funcName === "\\\\abovefrac") {
                  node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
                } else {
                  node = this.callFunction(funcName, [numerNode, denomNode], []);
                }
                return [node];
              } else {
                return body;
              }
            }
            /**
             * Handle a subscript or superscript with nice errors.
             */
            handleSupSubscript(name) {
              const symbolToken = this.fetch();
              const symbol = symbolToken.text;
              this.consume();
              this.consumeSpaces();
              let group;
              do {
                var _group;
                group = this.parseGroup(name);
              } while (((_group = group) == null ? void 0 : _group.type) === "internal");
              if (!group) {
                throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
              }
              return group;
            }
            /**
             * Converts the textual input of an unsupported command into a text node
             * contained within a color node whose color is determined by errorColor
             */
            formatUnsupportedCmd(text2) {
              const textordArray = [];
              for (let i = 0; i < text2.length; i++) {
                textordArray.push({
                  type: "textord",
                  mode: "text",
                  text: text2[i]
                });
              }
              const textNode = {
                type: "text",
                mode: this.mode,
                body: textordArray
              };
              const colorNode = {
                type: "color",
                mode: this.mode,
                color: this.settings.errorColor,
                body: [textNode]
              };
              return colorNode;
            }
            /**
             * Parses a group with optional super/subscripts.
             */
            parseAtom(breakOnTokenText) {
              const base2 = this.parseGroup("atom", breakOnTokenText);
              if ((base2 == null ? void 0 : base2.type) === "internal") {
                return base2;
              }
              if (this.mode === "text") {
                return base2;
              }
              let superscript;
              let subscript;
              while (true) {
                this.consumeSpaces();
                const lex = this.fetch();
                if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                  if (base2 && base2.type === "op") {
                    const limits = lex.text === "\\limits";
                    base2.limits = limits;
                    base2.alwaysHandleSupSub = true;
                  } else if (base2 && base2.type === "operatorname") {
                    if (base2.alwaysHandleSupSub) {
                      base2.limits = lex.text === "\\limits";
                    }
                  } else {
                    throw new src_ParseError("Limit controls must follow a math operator", lex);
                  }
                  this.consume();
                } else if (lex.text === "^") {
                  if (superscript) {
                    throw new src_ParseError("Double superscript", lex);
                  }
                  superscript = this.handleSupSubscript("superscript");
                } else if (lex.text === "_") {
                  if (subscript) {
                    throw new src_ParseError("Double subscript", lex);
                  }
                  subscript = this.handleSupSubscript("subscript");
                } else if (lex.text === "'") {
                  if (superscript) {
                    throw new src_ParseError("Double superscript", lex);
                  }
                  const prime = {
                    type: "textord",
                    mode: this.mode,
                    text: "\\prime"
                  };
                  const primes = [prime];
                  this.consume();
                  while (this.fetch().text === "'") {
                    primes.push(prime);
                    this.consume();
                  }
                  if (this.fetch().text === "^") {
                    primes.push(this.handleSupSubscript("superscript"));
                  }
                  superscript = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: primes
                  };
                } else if (uSubsAndSups2[lex.text]) {
                  const isSub = unicodeSubRegEx2.test(lex.text);
                  const subsupTokens = [];
                  subsupTokens.push(new Token3(uSubsAndSups2[lex.text]));
                  this.consume();
                  while (true) {
                    const token = this.fetch().text;
                    if (!uSubsAndSups2[token]) {
                      break;
                    }
                    if (unicodeSubRegEx2.test(token) !== isSub) {
                      break;
                    }
                    subsupTokens.unshift(new Token3(uSubsAndSups2[token]));
                    this.consume();
                  }
                  const body = this.subparse(subsupTokens);
                  if (isSub) {
                    subscript = {
                      type: "ordgroup",
                      mode: "math",
                      body
                    };
                  } else {
                    superscript = {
                      type: "ordgroup",
                      mode: "math",
                      body
                    };
                  }
                } else {
                  break;
                }
              }
              if (superscript || subscript) {
                return {
                  type: "supsub",
                  mode: this.mode,
                  base: base2,
                  sup: superscript,
                  sub: subscript
                };
              } else {
                return base2;
              }
            }
            /**
             * Parses an entire function, including its base and all of its arguments.
             */
            parseFunction(breakOnTokenText, name) {
              const token = this.fetch();
              const func = token.text;
              const funcData = src_functions[func];
              if (!funcData) {
                return null;
              }
              this.consume();
              if (name && name !== "atom" && !funcData.allowedInArgument) {
                throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
              } else if (this.mode === "text" && !funcData.allowedInText) {
                throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
              } else if (this.mode === "math" && funcData.allowedInMath === false) {
                throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
              }
              const {
                args,
                optArgs
              } = this.parseArguments(func, funcData);
              return this.callFunction(func, args, optArgs, token, breakOnTokenText);
            }
            /**
             * Call a function handler with a suitable context and arguments.
             */
            callFunction(name, args, optArgs, token, breakOnTokenText) {
              const context = {
                funcName: name,
                parser: this,
                token,
                breakOnTokenText
              };
              const func = src_functions[name];
              if (func && func.handler) {
                return func.handler(context, args, optArgs);
              } else {
                throw new src_ParseError("No function handler for " + name);
              }
            }
            /**
             * Parses the arguments of a function or environment
             */
            parseArguments(func, funcData) {
              const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
              if (totalArgs === 0) {
                return {
                  args: [],
                  optArgs: []
                };
              }
              const args = [];
              const optArgs = [];
              for (let i = 0; i < totalArgs; i++) {
                let argType = funcData.argTypes && funcData.argTypes[i];
                const isOptional = i < funcData.numOptionalArgs;
                if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
                funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
                  argType = "primitive";
                }
                const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
                if (isOptional) {
                  optArgs.push(arg);
                } else if (arg != null) {
                  args.push(arg);
                } else {
                  throw new src_ParseError("Null argument, please report this as a bug");
                }
              }
              return {
                args,
                optArgs
              };
            }
            /**
             * Parses a group when the mode is changing.
             */
            parseGroupOfType(name, type, optional) {
              switch (type) {
                case "color":
                  return this.parseColorGroup(optional);
                case "size":
                  return this.parseSizeGroup(optional);
                case "url":
                  return this.parseUrlGroup(optional);
                case "math":
                case "text":
                  return this.parseArgumentGroup(optional, type);
                case "hbox": {
                  const group = this.parseArgumentGroup(optional, "text");
                  return group != null ? {
                    type: "styling",
                    mode: group.mode,
                    body: [group],
                    style: "text"
                    // simulate \textstyle
                  } : null;
                }
                case "raw": {
                  const token = this.parseStringGroup("raw", optional);
                  return token != null ? {
                    type: "raw",
                    mode: "text",
                    string: token.text
                  } : null;
                }
                case "primitive": {
                  if (optional) {
                    throw new src_ParseError("A primitive argument cannot be optional");
                  }
                  const group = this.parseGroup(name);
                  if (group == null) {
                    throw new src_ParseError("Expected group as " + name, this.fetch());
                  }
                  return group;
                }
                case "original":
                case null:
                case void 0:
                  return this.parseArgumentGroup(optional);
                default:
                  throw new src_ParseError("Unknown group type as " + name, this.fetch());
              }
            }
            /**
             * Discard any space tokens, fetching the next non-space token.
             */
            consumeSpaces() {
              while (this.fetch().text === " ") {
                this.consume();
              }
            }
            /**
             * Parses a group, essentially returning the string formed by the
             * brace-enclosed tokens plus some position information.
             */
            parseStringGroup(modeName, optional) {
              const argToken = this.gullet.scanArgument(optional);
              if (argToken == null) {
                return null;
              }
              let str = "";
              let nextToken;
              while ((nextToken = this.fetch()).text !== "EOF") {
                str += nextToken.text;
                this.consume();
              }
              this.consume();
              argToken.text = str;
              return argToken;
            }
            /**
             * Parses a regex-delimited group: the largest sequence of tokens
             * whose concatenated strings match `regex`. Returns the string
             * formed by the tokens plus some position information.
             */
            parseRegexGroup(regex2, modeName) {
              const firstToken = this.fetch();
              let lastToken = firstToken;
              let str = "";
              let nextToken;
              while ((nextToken = this.fetch()).text !== "EOF" && regex2.test(str + nextToken.text)) {
                lastToken = nextToken;
                str += lastToken.text;
                this.consume();
              }
              if (str === "") {
                throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
              }
              return firstToken.range(lastToken, str);
            }
            /**
             * Parses a color description.
             */
            parseColorGroup(optional) {
              const res = this.parseStringGroup("color", optional);
              if (res == null) {
                return null;
              }
              const match2 = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
              if (!match2) {
                throw new src_ParseError("Invalid color: '" + res.text + "'", res);
              }
              let color2 = match2[0];
              if (/^[0-9a-f]{6}$/i.test(color2)) {
                color2 = "#" + color2;
              }
              return {
                type: "color-token",
                mode: this.mode,
                color: color2
              };
            }
            /**
             * Parses a size specification, consisting of magnitude and unit.
             */
            parseSizeGroup(optional) {
              let res;
              let isBlank = false;
              this.gullet.consumeSpaces();
              if (!optional && this.gullet.future().text !== "{") {
                res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
              } else {
                res = this.parseStringGroup("size", optional);
              }
              if (!res) {
                return null;
              }
              if (!optional && res.text.length === 0) {
                res.text = "0pt";
                isBlank = true;
              }
              const match2 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
              if (!match2) {
                throw new src_ParseError("Invalid size: '" + res.text + "'", res);
              }
              const data = {
                number: +(match2[1] + match2[2]),
                // sign + magnitude, cast to number
                unit: match2[3]
              };
              if (!validUnit3(data)) {
                throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
              }
              return {
                type: "size",
                mode: this.mode,
                value: data,
                isBlank
              };
            }
            /**
             * Parses an URL, checking escaped letters and allowed protocols,
             * and setting the catcode of % as an active character (as in \hyperref).
             */
            parseUrlGroup(optional) {
              this.gullet.lexer.setCatcode("%", 13);
              this.gullet.lexer.setCatcode("~", 12);
              const res = this.parseStringGroup("url", optional);
              this.gullet.lexer.setCatcode("%", 14);
              this.gullet.lexer.setCatcode("~", 13);
              if (res == null) {
                return null;
              }
              const url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
              return {
                type: "url",
                mode: this.mode,
                url
              };
            }
            /**
             * Parses an argument with the mode specified.
             */
            parseArgumentGroup(optional, mode) {
              const argToken = this.gullet.scanArgument(optional);
              if (argToken == null) {
                return null;
              }
              const outerMode = this.mode;
              if (mode) {
                this.switchMode(mode);
              }
              this.gullet.beginGroup();
              const expression = this.parseExpression(false, "EOF");
              this.expect("EOF");
              this.gullet.endGroup();
              const result = {
                type: "ordgroup",
                mode: this.mode,
                loc: argToken.loc,
                body: expression
              };
              if (mode) {
                this.switchMode(outerMode);
              }
              return result;
            }
            /**
             * Parses an ordinary group, which is either a single nucleus (like "x")
             * or an expression in braces (like "{x+y}") or an implicit group, a group
             * that starts at the current position, and ends right before a higher explicit
             * group ends, or at EOF.
             */
            parseGroup(name, breakOnTokenText) {
              const firstToken = this.fetch();
              const text2 = firstToken.text;
              let result;
              if (text2 === "{" || text2 === "\\begingroup") {
                this.consume();
                const groupEnd = text2 === "{" ? "}" : "\\endgroup";
                this.gullet.beginGroup();
                const expression = this.parseExpression(false, groupEnd);
                const lastToken = this.fetch();
                this.expect(groupEnd);
                this.gullet.endGroup();
                result = {
                  type: "ordgroup",
                  mode: this.mode,
                  loc: SourceLocation2.range(firstToken, lastToken),
                  body: expression,
                  // A group formed by \begingroup...\endgroup is a semi-simple group
                  // which doesn't affect spacing in math mode, i.e., is transparent.
                  // https://tex.stackexchange.com/questions/1930/when-should-one-
                  // use-begingroup-instead-of-bgroup
                  semisimple: text2 === "\\begingroup" || void 0
                };
              } else {
                result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
                if (result == null && text2[0] === "\\" && !implicitCommands2.hasOwnProperty(text2)) {
                  if (this.settings.throwOnError) {
                    throw new src_ParseError("Undefined control sequence: " + text2, firstToken);
                  }
                  result = this.formatUnsupportedCmd(text2);
                  this.consume();
                }
              }
              return result;
            }
            /**
             * Form ligature-like combinations of characters for text mode.
             * This includes inputs like "--", "---", "``" and "''".
             * The result will simply replace multiple textord nodes with a single
             * character in each value by a single textord node having multiple
             * characters in its value.  The representation is still ASCII source.
             * The group will be modified in place.
             */
            formLigatures(group) {
              let n = group.length - 1;
              for (let i = 0; i < n; ++i) {
                const a = group[i];
                const v = a.text;
                if (v === "-" && group[i + 1].text === "-") {
                  if (i + 1 < n && group[i + 2].text === "-") {
                    group.splice(i, 3, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation2.range(a, group[i + 2]),
                      text: "---"
                    });
                    n -= 2;
                  } else {
                    group.splice(i, 2, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation2.range(a, group[i + 1]),
                      text: "--"
                    });
                    n -= 1;
                  }
                }
                if ((v === "'" || v === "`") && group[i + 1].text === v) {
                  group.splice(i, 2, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation2.range(a, group[i + 1]),
                    text: v + v
                  });
                  n -= 1;
                }
              }
            }
            /**
             * Parse a single symbol out of the string. Here, we handle single character
             * symbols and special functions like \verb.
             */
            parseSymbol() {
              const nucleus = this.fetch();
              let text2 = nucleus.text;
              if (/^\\verb[^a-zA-Z]/.test(text2)) {
                this.consume();
                let arg = text2.slice(5);
                const star = arg.charAt(0) === "*";
                if (star) {
                  arg = arg.slice(1);
                }
                if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                  throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
                }
                arg = arg.slice(1, -1);
                return {
                  type: "verb",
                  mode: "text",
                  body: arg,
                  star
                };
              }
              if (unicodeSymbols2.hasOwnProperty(text2[0]) && !src_symbols[this.mode][text2[0]]) {
                if (this.settings.strict && this.mode === "math") {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
                }
                text2 = unicodeSymbols2[text2[0]] + text2.slice(1);
              }
              const match2 = combiningDiacriticalMarksEndRegex2.exec(text2);
              if (match2) {
                text2 = text2.substring(0, match2.index);
                if (text2 === "i") {
                  text2 = "";
                } else if (text2 === "j") {
                  text2 = "";
                }
              }
              let symbol;
              if (src_symbols[this.mode][text2]) {
                if (this.settings.strict && this.mode === "math" && extraLatin2.indexOf(text2) >= 0) {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
                }
                const group = src_symbols[this.mode][text2].group;
                const loc = SourceLocation2.range(nucleus);
                let s;
                if (ATOMS2.hasOwnProperty(group)) {
                  const family = group;
                  s = {
                    type: "atom",
                    mode: this.mode,
                    family,
                    loc,
                    text: text2
                  };
                } else {
                  s = {
                    type: group,
                    mode: this.mode,
                    loc,
                    text: text2
                  };
                }
                symbol = s;
              } else if (text2.charCodeAt(0) >= 128) {
                if (this.settings.strict) {
                  if (!supportedCodepoint2(text2.charCodeAt(0))) {
                    this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
                  } else if (this.mode === "math") {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
                  }
                }
                symbol = {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation2.range(nucleus),
                  text: text2
                };
              } else {
                return null;
              }
              this.consume();
              if (match2) {
                for (let i = 0; i < match2[0].length; i++) {
                  const accent3 = match2[0][i];
                  if (!unicodeAccents2[accent3]) {
                    throw new src_ParseError("Unknown accent ' " + accent3 + "'", nucleus);
                  }
                  const command = unicodeAccents2[accent3][this.mode] || unicodeAccents2[accent3].text;
                  if (!command) {
                    throw new src_ParseError("Accent " + accent3 + " unsupported in " + this.mode + " mode", nucleus);
                  }
                  symbol = {
                    type: "accent",
                    mode: this.mode,
                    loc: SourceLocation2.range(nucleus),
                    label: command,
                    isStretchy: false,
                    isShifty: true,
                    // $FlowFixMe
                    base: symbol
                  };
                }
              }
              return symbol;
            }
          }
          Parser2.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
          const parseTree3 = function(toParse, settings) {
            if (!(typeof toParse === "string" || toParse instanceof String)) {
              throw new TypeError("KaTeX can only parse string typed expression");
            }
            const parser = new Parser2(toParse, settings);
            delete parser.gullet.macros.current["\\df@tag"];
            let tree = parser.parse();
            delete parser.gullet.macros.current["\\current@color"];
            delete parser.gullet.macros.current["\\color"];
            if (parser.gullet.macros.get("\\df@tag")) {
              if (!settings.displayMode) {
                throw new src_ParseError("\\tag works only in display equations");
              }
              tree = [{
                type: "tag",
                mode: "text",
                body: tree,
                tag: parser.subparse([new Token3("\\df@tag")])
              }];
            }
            return tree;
          };
          var src_parseTree = parseTree3;
          let render3 = function(expression, baseNode, options) {
            baseNode.textContent = "";
            const node = renderToDomTree3(expression, options).toNode();
            baseNode.appendChild(node);
          };
          if (typeof document !== "undefined") {
            if (document.compatMode !== "CSS1Compat") {
              typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
              render3 = function() {
                throw new src_ParseError("KaTeX doesn't work in quirks mode.");
              };
            }
          }
          const renderToString3 = function(expression, options) {
            const markup = renderToDomTree3(expression, options).toMarkup();
            return markup;
          };
          const generateParseTree3 = function(expression, options) {
            const settings = new Settings2(options);
            return src_parseTree(expression, settings);
          };
          const renderError3 = function(error2, expression, options) {
            if (options.throwOnError || !(error2 instanceof src_ParseError)) {
              throw error2;
            }
            const node = buildCommon2.makeSpan(["katex-error"], [new SymbolNode2(expression)]);
            node.setAttribute("title", error2.toString());
            node.setAttribute("style", "color:" + options.errorColor);
            return node;
          };
          const renderToDomTree3 = function(expression, options) {
            const settings = new Settings2(options);
            try {
              const tree = src_parseTree(expression, settings);
              return buildTree3(tree, expression, settings);
            } catch (error2) {
              return renderError3(error2, expression, settings);
            }
          };
          const renderToHTMLTree3 = function(expression, options) {
            const settings = new Settings2(options);
            try {
              const tree = src_parseTree(expression, settings);
              return buildHTMLTree3(tree, expression, settings);
            } catch (error2) {
              return renderError3(error2, expression, settings);
            }
          };
          const version2 = "0.16.28";
          const __domTree2 = {
            Span: Span2,
            Anchor: Anchor2,
            SymbolNode: SymbolNode2,
            SvgNode: SvgNode2,
            PathNode: PathNode2,
            LineNode: LineNode2
          };
          var katex2 = {
            /**
             * Current KaTeX version
             */
            version: version2,
            /**
             * Renders the given LaTeX into an HTML+MathML combination, and adds
             * it as a child to the specified DOM node.
             */
            render: render3,
            /**
             * Renders the given LaTeX into an HTML+MathML combination string,
             * for sending to the client.
             */
            renderToString: renderToString3,
            /**
             * KaTeX error, usually during parsing.
             */
            ParseError: src_ParseError,
            /**
             * The schema of Settings
             */
            SETTINGS_SCHEMA: SETTINGS_SCHEMA2,
            /**
             * Parses the given LaTeX into KaTeX's internal parse tree structure,
             * without rendering to HTML or MathML.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __parse: generateParseTree3,
            /**
             * Renders the given LaTeX into an HTML+MathML internal DOM tree
             * representation, without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToDomTree: renderToDomTree3,
            /**
             * Renders the given LaTeX into an HTML internal DOM tree representation,
             * without MathML and without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToHTMLTree: renderToHTMLTree3,
            /**
             * extends internal font metrics object with a new object
             * each key in the new object represents a font name
            */
            __setFontMetrics: setFontMetrics2,
            /**
             * adds a new symbol to builtin symbols table
             */
            __defineSymbol: defineSymbol2,
            /**
             * adds a new function to builtin function list,
             * which directly produce parse tree elements
             * and have their own html/mathml builders
             */
            __defineFunction: defineFunction2,
            /**
             * adds a new macro to builtin macro list
             */
            __defineMacro: defineMacro2,
            /**
             * Expose the dom tree node types, which can be useful for type checking nodes.
             *
             * NOTE: These methods are not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __domTree: __domTree2
          };
          var katex_webpack = katex2;
          __webpack_exports__ = __webpack_exports__["default"];
          return __webpack_exports__;
        })()
      );
    });
  })(katex$1);
  return katex$1.exports;
}
var hasRequiredTexmath;
function requireTexmath() {
  if (hasRequiredTexmath) return texmath.exports;
  hasRequiredTexmath = 1;
  (function(module) {
    function escapeHTML(text2) {
      return text2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }
    function texmath2(md, options) {
      const delimiters2 = texmath2.mergeDelimiters(options && options.delimiters);
      const outerSpace = options && options.outerSpace || false;
      const katexOptions = options && options.katexOptions || {};
      katexOptions.throwOnError = katexOptions.throwOnError || false;
      katexOptions.macros = katexOptions.macros || options && options.macros;
      if (!texmath2.katex) {
        if (options && typeof options.engine === "object") {
          texmath2.katex = options.engine;
        } else texmath2.katex = requireKatex();
      }
      for (const rule of delimiters2.inline) {
        if (!!outerSpace && "outerSpace" in rule) rule.outerSpace = true;
        md.inline.ruler.before("escape", rule.name, texmath2.inline(rule));
        md.renderer.rules[rule.name] = (tokens, idx) => rule.tmpl.replace(/\$1/, texmath2.render(tokens[idx].content, !!rule.displayMode, katexOptions));
      }
      for (const rule of delimiters2.block) {
        md.block.ruler.before("fence", rule.name, texmath2.block(rule));
        md.renderer.rules[rule.name] = (tokens, idx) => rule.tmpl.replace(/\$2/, escapeHTML(tokens[idx].info)).replace(/\$1/, texmath2.render(tokens[idx].content, true, katexOptions));
      }
    }
    texmath2.mergeDelimiters = function(delims2) {
      const delimsArr = Array.isArray(delims2) ? delims2 : typeof delims2 === "string" ? [delims2] : ["dollars"];
      const delimiters2 = { inline: [], block: [] };
      for (const delim of delimsArr)
        if (delim in texmath2.rules) {
          delimiters2.inline.push(...texmath2.rules[delim].inline);
          delimiters2.block.push(...texmath2.rules[delim].block);
        }
      return delimiters2;
    };
    texmath2.inline = (rule) => function(state, silent) {
      const pos = state.pos;
      const str = state.src;
      const pre = str.startsWith(rule.tag, rule.rex.lastIndex = pos) && (!rule.pre || rule.pre(str, rule.outerSpace, pos));
      const match2 = pre && rule.rex.exec(str);
      const res = !!match2 && pos < rule.rex.lastIndex && (!rule.post || rule.post(str, rule.outerSpace, rule.rex.lastIndex - 1));
      if (res) {
        if (!silent) {
          const token = state.push(rule.name, "math", 0);
          token.content = match2[1];
          token.markup = rule.tag;
        }
        state.pos = rule.rex.lastIndex;
      }
      return res;
    };
    texmath2.block = (rule) => function block2(state, begLine, endLine, silent) {
      const pos = state.bMarks[begLine] + state.tShift[begLine];
      const str = state.src;
      const pre = str.startsWith(rule.tag, rule.rex.lastIndex = pos) && (!rule.pre || rule.pre(str, false, pos));
      const match2 = pre && rule.rex.exec(str);
      const res = !!match2 && pos < rule.rex.lastIndex && (!rule.post || rule.post(str, false, rule.rex.lastIndex - 1));
      if (res && !silent) {
        const endpos = rule.rex.lastIndex - 1;
        let curline;
        for (curline = begLine; curline < endLine; curline++)
          if (endpos >= state.bMarks[curline] + state.tShift[curline] && endpos <= state.eMarks[curline])
            break;
        const lineMax = state.lineMax;
        const parentType = state.parentType;
        state.lineMax = curline;
        state.parentType = "math";
        if (parentType === "blockquote")
          match2[1] = match2[1].replace(/(\n*?^(?:\s*>)+)/gm, "");
        let token = state.push(rule.name, "math", 0);
        token.block = true;
        token.tag = rule.tag;
        token.markup = "";
        token.content = match2[1];
        token.info = match2[match2.length - 1];
        token.map = [begLine, curline + 1];
        state.parentType = parentType;
        state.lineMax = lineMax;
        state.line = curline + 1;
      }
      return res;
    };
    texmath2.render = function(tex, displayMode, options) {
      options.displayMode = displayMode;
      let res;
      try {
        res = texmath2.katex.renderToString(tex, options);
      } catch (err) {
        res = escapeHTML(`${tex}:${err.message}`);
      }
      return res;
    };
    texmath2.use = function(katex2) {
      texmath2.katex = katex2;
      return texmath2;
    };
    texmath2.inlineRuleNames = ["math_inline", "math_inline_double"];
    texmath2.blockRuleNames = ["math_block", "math_block_eqno"];
    texmath2.$_pre = (str, outerSpace, beg) => {
      const prv = beg > 0 ? str[beg - 1].charCodeAt(0) : false;
      return outerSpace ? !prv || prv === 32 : !prv || prv !== 92 && (prv < 48 || prv > 57);
    };
    texmath2.$_post = (str, outerSpace, end) => {
      const nxt = str[end + 1] && str[end + 1].charCodeAt(0);
      return outerSpace ? !nxt || nxt === 32 || nxt === 46 || nxt === 44 || nxt === 59 : !nxt || nxt < 48 || nxt > 57;
    };
    texmath2.rules = {
      brackets: {
        inline: [
          {
            name: "math_inline",
            rex: /\\\((.+?)\\\)/gy,
            tmpl: "<eq>$1</eq>",
            tag: "\\("
          }
        ],
        block: [
          {
            name: "math_block_eqno",
            rex: /\\\[(((?!\\\]|\\\[)[\s\S])+?)\\\]\s*?\(([^)$\r\n]+?)\)/gmy,
            tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
            tag: "\\["
          },
          {
            name: "math_block",
            rex: /\\\[([\s\S]+?)\\\]/gmy,
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "\\["
          }
        ]
      },
      doxygen: {
        inline: [
          {
            name: "math_inline",
            rex: /\\f\$(.+?)\\f\$/gy,
            tmpl: "<eq>$1</eq>",
            tag: "\\f$"
          }
        ],
        block: [
          {
            name: "math_block_eqno",
            rex: /\\f\[([^]+?)\\f\]\s*?\(([^)\s]+?)\)/gmy,
            tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
            tag: "\\f["
          },
          {
            name: "math_block",
            rex: /\\f\[([^]+?)\\f\]/gmy,
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "\\f["
          }
        ]
      },
      gitlab: {
        inline: [
          {
            name: "math_inline",
            rex: /\$`(.+?)`\$/gy,
            tmpl: "<eq>$1</eq>",
            tag: "$`"
          }
        ],
        block: [
          {
            name: "math_block_eqno",
            rex: /`{3}math\s*([^`]+?)\s*?`{3}\s*\(([^)\r\n]+?)\)/gm,
            tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
            tag: "```math"
          },
          {
            name: "math_block",
            rex: /`{3}math\s*([^`]*?)\s*`{3}/gm,
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "```math"
          }
        ]
      },
      julia: {
        inline: [
          {
            name: "math_inline",
            rex: /`{2}([^`]+?)`{2}/gy,
            tmpl: "<eq>$1</eq>",
            tag: "``"
          },
          {
            name: "math_inline",
            rex: /\$((?:\S?)|(?:\S.*?\S))\$/gy,
            tmpl: "<eq>$1</eq>",
            tag: "$",
            spaceEnclosed: false,
            pre: texmath2.$_pre,
            post: texmath2.$_post
          }
        ],
        block: [
          {
            name: "math_block_eqno",
            rex: /`{3}math\s+?([^`]+?)\s+?`{3}\s*?\(([^)$\r\n]+?)\)/gmy,
            tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
            tag: "```math"
          },
          {
            name: "math_block",
            rex: /`{3}math\s+?([^`]+?)\s+?`{3}/gmy,
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "```math"
          }
        ]
      },
      kramdown: {
        inline: [
          {
            name: "math_inline",
            rex: /\${2}(.+?)\${2}/gy,
            tmpl: "<eq>$1</eq>",
            tag: "$$"
          }
        ],
        block: [
          {
            name: "math_block_eqno",
            rex: /\${2}([^$]+?)\${2}\s*?\(([^)\s]+?)\)/gmy,
            tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
            tag: "$$"
          },
          {
            name: "math_block",
            rex: /\${2}([^$]+?)\${2}/gmy,
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "$$"
          }
        ]
      },
      beg_end: {
        inline: [],
        block: [
          {
            name: "math_block",
            rex: /(\\(?:begin)\{([a-z]+)\}[\s\S]+?\\(?:end)\{\2\})/gmy,
            // regexp to match \begin{...}...\end{...} environment.
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "\\"
          }
        ]
      },
      dollars: {
        inline: [
          {
            name: "math_inline_double",
            rex: /\${2}([^$]*?[^\\])\${2}/gy,
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "$$",
            displayMode: true,
            pre: texmath2.$_pre,
            post: texmath2.$_post
          },
          {
            name: "math_inline",
            rex: /\$((?:[^\s\\])|(?:\S.*?[^\s\\]))\$/gy,
            tmpl: "<eq>$1</eq>",
            tag: "$",
            outerSpace: false,
            pre: texmath2.$_pre,
            post: texmath2.$_post
          }
        ],
        block: [
          {
            name: "math_block_eqno",
            rex: /\${2}([^$]*?[^\\])\${2}\s*?\(([^)\s]+?)\)/gmy,
            tmpl: '<section class="eqno"><eqn>$1</eqn><span>($2)</span></section>',
            tag: "$$"
          },
          {
            name: "math_block",
            rex: /\${2}([^$]*?[^\\])\${2}/gmy,
            tmpl: "<section><eqn>$1</eqn></section>",
            tag: "$$"
          }
        ]
      }
    };
    if (module.exports)
      module.exports = texmath2;
  })(texmath);
  return texmath.exports;
}
var texmathExports = requireTexmath();
const markdownItTexMath = /* @__PURE__ */ getDefaultExportFromCjs(texmathExports);
const Context = reactExports.createContext({});
async function replaceImageUrls(tokens, replacer) {
  const ops = tokens.map(async (token) => {
    if (token.type === "image") {
      const url = token.attrGet("src");
      if (url) {
        const newUrl = await replacer(url);
        token.attrSet("src", newUrl || url);
      }
    }
    if (token.children) {
      await replaceImageUrls(token.children, replacer);
    }
  });
  return Promise.all(ops);
}
async function mir(md, markdown, replacer) {
  const parsed = md.parse(markdown, { references: {} });
  await replaceImageUrls(parsed, replacer);
  return md.renderer.render(parsed, {}, {});
}
function RenderContextProvider(props) {
  const { content, githubToken, children } = props;
  const value = reactExports.useMemo(() => {
    const md = MarkdownIt({ html: true }).use(markdownItTexMath, {
      engine: katex$2,
      delimiters: "dollars",
      katexOptions: { macros: { "\\RR": "\\mathbb{R}" } }
    });
    const { url, name, download_url } = content;
    let baseUrl = "";
    let downloadPath = "";
    try {
      if (url) {
        const urlContent = new URL(url);
        baseUrl = `${urlContent.origin}${urlContent.pathname.replace(new RegExp(`${name}$`), "")}`;
      }
      if (download_url) {
        const parts = download_url.split("/");
        parts.pop();
        downloadPath = parts.join("/") + "/";
      }
    } catch {
    }
    const renderMdText = async (mdText) => {
      const ret = await mir(md, mdText, async (imageUrl) => {
        if (imageUrl.startsWith("http")) {
          return imageUrl;
        }
        const rawGitUrl = downloadPath + imageUrl;
        if (!baseUrl) {
          return rawGitUrl;
        }
        try {
          const response = await fetch(`${baseUrl}${imageUrl}`, {
            headers: githubToken ? {
              Authorization: `Bearer ${githubToken}`
            } : {}
          });
          const json = await response.json();
          return `data:image/jpeg;base64,${json.content}`;
        } catch (e) {
          console.error(e);
        }
        return rawGitUrl;
      }) || "";
      return ret;
    };
    return {
      content,
      md,
      renderMdText
    };
  }, [content, githubToken]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
}
const RenderContextProvider$1 = reactExports.memo(RenderContextProvider);
function useRenderContext() {
  return reactExports.useContext(Context);
}
const MarkdownArea = styled(Box)(({ theme }) => ({
  "& code": {
    backgroundColor: theme.palette.grey[800],
    padding: ".2em .3rem",
    borderRadius: ".2em"
  },
  "& img": {
    maxWidth: "100%",
    height: "auto"
  }
}));
function Question(props) {
  const { text: text2, sx, ...rest } = props;
  const { renderMdText } = useRenderContext();
  const [html, setHtml] = reactExports.useState("");
  reactExports.useEffect(() => {
    renderMdText(text2).then(setHtml);
  }, [text2, renderMdText]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MarkdownArea,
    {
      sx: [
        {
          fontSize: "1.5rem",
          lineHeight: "2rem",
          "& p": {
            margin: 0
          },
          wordBreak: "break-word"
        },
        ...Array.isArray(sx) ? sx : [sx]
      ],
      ...rest,
      dangerouslySetInnerHTML: { __html: html }
    }
  );
}
const Question$1 = reactExports.memo(Question);
function Answer(props) {
  const { text: text2, sx, ...boxProps } = props;
  const { renderMdText } = useRenderContext();
  const [html, setHtml] = reactExports.useState("");
  reactExports.useEffect(() => {
    renderMdText(text2).then(setHtml);
  }, [renderMdText, text2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MarkdownArea,
    {
      sx: [
        {
          fontSize: "1.2rem",
          "& p": {
            margin: 0
          },
          width: "100%",
          overflowX: "auto"
        },
        ...Array.isArray(sx) ? sx : [sx]
      ],
      dangerouslySetInnerHTML: { __html: html },
      ...boxProps
    }
  );
}
const Answer$1 = reactExports.memo(Answer);
function FlashCardCard(props) {
  const { className, item } = props;
  const { q, a, passRatio } = item;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { className, elevation: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { sx: { paddingBottom: "16px !important" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "row" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Question$1,
        {
          text: q,
          sx: {
            fontSize: ".8rem",
            color: "text.secondary",
            lineHeight: "inherit"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Answer$1,
        {
          text: a,
          sx: {
            fontSize: "1rem",
            marginTop: "4px"
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1 } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressWithLabel$1, { value: passRatio }) })
  ] }) }) });
}
const FlashCardCard$1 = reactExports.memo(FlashCardCard);
function FlashCardViewContent(props) {
  const { className } = props;
  const { queryParams } = useTypedSearchParams(routes.flashMan.cards.$config);
  const { owner, repo, path: path2 } = queryParams;
  const token = useGithubToken();
  const navigate = useNavigate();
  const [sortByPassRatio, setSortByPassRatio] = reactExports.useState(true);
  const { content } = useFlashCardContent(queryParams);
  const itemsWithSummary = useFlashCardItemSummaries(content ?? null, sortByPassRatio);
  if (!content) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { padding: 4, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "  ..." }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className,
      sx: {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { margin: "1rem", display: "flex", alignItems: "center", flexDirection: "row" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ContentBreadcrumbs$1, { owner, repo, path: path2, file: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                alignItems: "flex-end"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { component: "span", sx: { marginRight: ".4rem" }, children: [
                  "(",
                  itemsWithSummary.length,
                  ")"
                ] }),
                content.html_url && /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { href: content.html_url, target: "_blank", rel: "noopener noreferrer", children: "GitHub" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: () => setSortByPassRatio(!sortByPassRatio), children: sortByPassRatio ? /* @__PURE__ */ jsxRuntimeExports.jsx(SortIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ListIcon, {}) })
        ] }),
        itemsWithSummary.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { padding: "0 1rem 1rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            fullWidth: true,
            size: "large",
            startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(SchoolIcon, {}),
            onClick: () => {
              navigate(routes.flashMan.learn.$({ owner, repo, path: path2 }));
            },
            children: ""
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(RenderContextProvider$1, { content, githubToken: token, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, sx: { padding: "0 1rem 1rem" }, children: itemsWithSummary.map((item, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FlashCardCard$1, { item }) }, i)) }) })
      ]
    }
  );
}
function FlashCardView(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          sx: { display: "flex", alignItems: "center", justifyContent: "center", height: "50vh" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
        }
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(FlashCardViewContent, { ...props })
    }
  );
}
const FlashCardView$1 = reactExports.memo(FlashCardView);
function useStackedTitle(text2) {
  reactExports.useEffect(() => {
    const titlePrev = document.title;
    if (text2) {
      document.title = titlePrev ? `${text2} | ${titlePrev}` : text2;
    }
    return () => {
      if (text2) {
        document.title = titlePrev;
      }
    };
  }, [text2]);
}
function ContentNavigationBar({
  contentId,
  content,
  contentPrev,
  contentNext,
  centerButton
}) {
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: ({ palette }) => ({
        position: "sticky",
        bottom: 0,
        display: "flex",
        gap: 1,
        mt: 2,
        pt: 2,
        borderTop: 1,
        borderColor: "divider",
        backgroundColor: palette.background.paper,
        justifyContent: "space-evenly"
      }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "contained",
            size: "large",
            onClick: () => {
              navigate(
                routes.flashMan.learn.$({
                  owner: contentId.owner,
                  repo: contentId.repo,
                  path: contentPrev?.path || ""
                })
              );
            },
            disabled: !contentPrev,
            children: [
              "",
              contentPrev && content && /* @__PURE__ */ jsxRuntimeExports.jsx(ContentStatus$1, { simple: true, content })
            ]
          }
        ),
        centerButton,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "contained",
            size: "large",
            onClick: () => {
              navigate(
                routes.flashMan.learn.$({
                  owner: contentId.owner,
                  repo: contentId.repo,
                  path: contentNext?.path || ""
                })
              );
            },
            disabled: !contentNext,
            children: [
              "",
              contentNext && /* @__PURE__ */ jsxRuntimeExports.jsx(ContentStatus$1, { simple: true, content: contentNext })
            ]
          }
        )
      ]
    }
  );
}
const ContentNavigationBar$1 = reactExports.memo(ContentNavigationBar);
function ConnectedContentNavigationBarInner({
  contentId,
  centerButton
}) {
  const { content, contentPrev, contentNext } = useGithubCardContextNext(contentId);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ContentNavigationBar,
    {
      contentId,
      content,
      contentPrev,
      contentNext,
      centerButton
    }
  );
}
const ConnectedContentNavigationBar = reactExports.memo(ConnectedContentNavigationBarInner);
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero$1;
    compare2 = f;
    delta = f;
  }
  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero$1() {
  return 0;
}
function number$1(x) {
  return x === null ? NaN : +x;
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$1).center;
function count(values, valueof) {
  let count2 = 0;
  {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count2;
      }
    }
  }
  return count2;
}
function extent(values, valueof) {
  let min;
  let max;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min === void 0) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === void 0) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }
  return [min, max];
}
function identity$2(x) {
  return x;
}
var array = Array.prototype;
var slice = array.slice;
function constant$1(x) {
  return () => x;
}
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error2 = step / Math.pow(10, power), factor = error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0)) return [];
  if (start === stop) return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function nice(start, stop, count2) {
  let prestep;
  while (true) {
    const step = tickIncrement(start, stop, count2);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function thresholdSturges(values) {
  return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
}
function bin() {
  var value = identity$2, domain = extent, threshold = thresholdSturges;
  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i, n = data.length, x, step, values = new Array(n);
    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }
    var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
    if (!Array.isArray(tz)) {
      const max = x1, tn = +tz;
      if (domain === extent) [x0, x1] = nice(x0, x1, tn);
      tz = ticks(x0, x1, tn);
      if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);
      if (tz[tz.length - 1] >= x1) {
        if (max >= x1 && domain === extent) {
          const step2 = tickIncrement(x0, x1, tn);
          if (isFinite(step2)) {
            if (step2 > 0) {
              x1 = (Math.floor(x1 / step2) + 1) * step2;
            } else if (step2 < 0) {
              x1 = (Math.ceil(x1 * -step2) + 1) / -step2;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m = tz.length, a = 0, b = m;
    while (tz[a] <= x0) ++a;
    while (tz[b - 1] > x1) --b;
    if (a || b < m) tz = tz.slice(a, b), m = b - a;
    var bins = new Array(m + 1), bin2;
    for (i = 0; i <= m; ++i) {
      bin2 = bins[i] = [];
      bin2.x0 = i > 0 ? tz[i - 1] : x0;
      bin2.x1 = i < m ? tz[i] : x1;
    }
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x = values[i]) != null && x0 <= x && x <= x1) {
            const j = Math.floor((x0 - x) * step);
            bins[Math.min(m, j + (tz[j] <= x))].push(data[i]);
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x = values[i]) != null && x0 <= x && x <= x1) {
          bins[bisectRight(tz, x, 0, m)].push(data[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(_), histogram) : value;
  };
  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant$1([_[0], _[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : constant$1(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold;
  };
  return histogram;
}
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl$1(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl$1, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;
const K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0$1 = 4 / 29, t1$1 = 6 / 29, t2 = 3 * t1$1 * t1$1, t3 = t1$1 * t1$1 * t1$1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab$1(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define(Lab, lab$1, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
}
function lab2xyz(t) {
  return t > t1$1 ? t * t * t : t2 * (t - t0$1);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl$1(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define(Hcl, hcl$1, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));
var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix$1(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Cubehelix, cubehelix$1, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));
const constant = (x) => () => x;
function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant(isNaN(a) ? b : a);
}
const interpolateRgb = (function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb$1(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
})(1);
function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}
function date(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolate(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : string : b instanceof color ? interpolateRgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}
function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
function hsl(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl$1(start)).h, (end = hsl$1(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
const interpolateHsl = hsl(hue);
var hslLong = hsl(nogamma);
function lab(start, end) {
  var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l), a = nogamma(start.a, end.a), b = nogamma(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}
function hcl(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl$1(start)).h, (end = hcl$1(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
const interpolateHcl = hcl(hue);
var hclLong = hcl(nogamma);
function cubehelix(hue2) {
  return (function cubehelixGamma(y) {
    y = +y;
    function cubehelix2(start, end) {
      var h = hue2((start = cubehelix$1(start)).h, (end = cubehelix$1(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix2.gamma = cubehelixGamma;
    return cubehelix2;
  })(1);
}
const interpolateCubehelix = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);
function constants(x) {
  return function() {
    return x;
  };
}
function number(x) {
  return +x;
}
var unit = [0, 1];
function identity$1(x) {
  return x;
}
function normalize2(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize2(d1, d0), r0 = interpolate2(r1, r0);
  else d0 = normalize2(d0, d1), r0 = interpolate2(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range, interpolate2) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize2(domain[i], domain[i + 1]);
    r[i] = interpolate2(range[i], range[i + 1]);
  }
  return function(x) {
    var i2 = bisectRight(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp2 = identity$1, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp2 !== identity$1) clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp2(x)));
  }
  scale.invert = function(y) {
    return clamp2(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };
  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity$1, rescale()) : clamp2 !== identity$1;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity$1, identity$1);
}
function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}
function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};
function identity(x) {
  return x;
}
var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=") zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim(value);
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2) value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = (date2) => {
    const d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = (start, stop, step) => {
    const range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range;
    let previous;
    do
      range.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };
  interval.filter = (test2) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test2(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test2(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test2(date2)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
    };
  }
  return interval;
}
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
second.range;
const timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
timeMinute.range;
const utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
utcMinute.range;
const timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
timeHour.range;
const utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
utcHour.range;
const timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
timeDay.range;
const utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
utcDay.range;
const unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
unixDay.range;
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
timeMonth.range;
const utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
utcMonth.range;
const timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
timeYear.range;
const utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
utcYear.range;
function applyDomain(scale, config2) {
  if (config2.domain) {
    if ("nice" in scale || "quantiles" in scale) {
      scale.domain(config2.domain);
    } else if ("padding" in scale) {
      scale.domain(config2.domain);
    } else {
      scale.domain(config2.domain);
    }
  }
}
function applyRange(scale, config2) {
  if (config2.range) {
    if ("padding" in scale) {
      scale.range(config2.range);
    } else {
      scale.range(config2.range);
    }
  }
}
function applyAlign(scale, config2) {
  if ("align" in scale && "align" in config2 && typeof config2.align !== "undefined") {
    scale.align(config2.align);
  }
}
function applyBase(scale, config2) {
  if ("base" in scale && "base" in config2 && typeof config2.base !== "undefined") {
    scale.base(config2.base);
  }
}
function applyClamp(scale, config2) {
  if ("clamp" in scale && "clamp" in config2 && typeof config2.clamp !== "undefined") {
    scale.clamp(config2.clamp);
  }
}
function applyConstant(scale, config2) {
  if ("constant" in scale && "constant" in config2 && typeof config2.constant !== "undefined") {
    scale.constant(config2.constant);
  }
}
function applyExponent(scale, config2) {
  if ("exponent" in scale && "exponent" in config2 && typeof config2.exponent !== "undefined") {
    scale.exponent(config2.exponent);
  }
}
var interpolatorMap = {
  lab,
  hcl: interpolateHcl,
  "hcl-long": hclLong,
  hsl: interpolateHsl,
  "hsl-long": hslLong,
  cubehelix: interpolateCubehelix,
  "cubehelix-long": cubehelixLong,
  rgb: interpolateRgb
};
function createColorInterpolator(interpolate2) {
  switch (interpolate2) {
    case "lab":
    case "hcl":
    case "hcl-long":
    case "hsl":
    case "hsl-long":
    case "cubehelix":
    case "cubehelix-long":
    case "rgb":
      return interpolatorMap[interpolate2];
  }
  var type = interpolate2.type, gamma2 = interpolate2.gamma;
  var interpolator = interpolatorMap[type];
  return typeof gamma2 === "undefined" ? interpolator : interpolator.gamma(gamma2);
}
function applyInterpolate(scale, config2) {
  if ("interpolate" in config2 && "interpolate" in scale && typeof config2.interpolate !== "undefined") {
    var interpolator = createColorInterpolator(config2.interpolate);
    scale.interpolate(interpolator);
  }
}
var TEST_TIME = new Date(Date.UTC(2020, 1, 2, 3, 4, 5));
var TEST_FORMAT = "%Y-%m-%d %H:%M";
function isUtcScale(scale) {
  var output = scale.tickFormat(1, TEST_FORMAT)(TEST_TIME);
  return output === "2020-02-02 03:04";
}
var localTimeIntervals = {
  day: timeDay,
  hour: timeHour,
  minute: timeMinute,
  month: timeMonth,
  second,
  week: timeSunday,
  year: timeYear
};
var utcIntervals = {
  day: utcDay,
  hour: utcHour,
  minute: utcMinute,
  month: utcMonth,
  second,
  week: utcSunday,
  year: utcYear
};
function applyNice(scale, config2) {
  if ("nice" in config2 && typeof config2.nice !== "undefined" && "nice" in scale) {
    var nice2 = config2.nice;
    if (typeof nice2 === "boolean") {
      if (nice2) {
        scale.nice();
      }
    } else if (typeof nice2 === "number") {
      scale.nice(nice2);
    } else {
      var timeScale = scale;
      var isUtc = isUtcScale(timeScale);
      if (typeof nice2 === "string") {
        timeScale.nice(isUtc ? utcIntervals[nice2] : localTimeIntervals[nice2]);
      } else {
        var interval = nice2.interval, step = nice2.step;
        var parsedInterval = (isUtc ? utcIntervals[interval] : localTimeIntervals[interval]).every(step);
        if (parsedInterval != null) {
          timeScale.nice(parsedInterval);
        }
      }
    }
  }
}
function applyPadding(scale, config2) {
  if ("padding" in scale && "padding" in config2 && typeof config2.padding !== "undefined") {
    scale.padding(config2.padding);
  }
  if ("paddingInner" in scale && "paddingInner" in config2 && typeof config2.paddingInner !== "undefined") {
    scale.paddingInner(config2.paddingInner);
  }
  if ("paddingOuter" in scale && "paddingOuter" in config2 && typeof config2.paddingOuter !== "undefined") {
    scale.paddingOuter(config2.paddingOuter);
  }
}
function applyReverse(scale, config2) {
  if (config2.reverse) {
    var reversedRange = scale.range().slice().reverse();
    if ("padding" in scale) {
      scale.range(reversedRange);
    } else {
      scale.range(reversedRange);
    }
  }
}
function applyRound(scale, config2) {
  if ("round" in config2 && typeof config2.round !== "undefined") {
    if (config2.round && "interpolate" in config2 && typeof config2.interpolate !== "undefined") {
      console.warn("[visx/scale/applyRound] ignoring round: scale config contains round and interpolate. only applying interpolate. config:", config2);
    } else if ("round" in scale) {
      scale.round(config2.round);
    } else if ("interpolate" in scale && config2.round) {
      scale.interpolate(interpolateRound);
    }
  }
}
function applyUnknown(scale, config2) {
  if ("unknown" in scale && "unknown" in config2 && typeof config2.unknown !== "undefined") {
    scale.unknown(config2.unknown);
  }
}
function applyZero(scale, config2) {
  if ("zero" in config2 && config2.zero === true) {
    var domain = scale.domain();
    var a = domain[0], b = domain[1];
    var isDescending = b < a;
    var _ref = isDescending ? [b, a] : [a, b], min = _ref[0], max = _ref[1];
    var domainWithZero = [Math.min(0, min), Math.max(0, max)];
    scale.domain(isDescending ? domainWithZero.reverse() : domainWithZero);
  }
}
var ALL_OPERATORS = [
  // domain => nice => zero
  "domain",
  "nice",
  "zero",
  // interpolate before round
  "interpolate",
  "round",
  // set range then reverse
  "range",
  "reverse",
  // Order does not matter for these operators
  "align",
  "base",
  "clamp",
  "constant",
  "exponent",
  "padding",
  "unknown"
];
var operators = {
  domain: applyDomain,
  nice: applyNice,
  zero: applyZero,
  interpolate: applyInterpolate,
  round: applyRound,
  align: applyAlign,
  base: applyBase,
  clamp: applyClamp,
  constant: applyConstant,
  exponent: applyExponent,
  padding: applyPadding,
  range: applyRange,
  reverse: applyReverse,
  unknown: applyUnknown
};
function scaleOperator() {
  for (var _len = arguments.length, ops = new Array(_len), _key = 0; _key < _len; _key++) {
    ops[_key] = arguments[_key];
  }
  var selection = new Set(ops);
  var selectedOps = ALL_OPERATORS.filter(function(o) {
    return selection.has(o);
  });
  return function applyOperators(scale, config2) {
    if (typeof config2 !== "undefined") {
      selectedOps.forEach(function(op2) {
        operators[op2](scale, config2);
      });
    }
    return scale;
  };
}
var updateLinearScale = scaleOperator("domain", "range", "reverse", "clamp", "interpolate", "nice", "round", "zero");
function createLinearScale(config2) {
  return updateLinearScale(linear(), config2);
}
function HistogramSlider(props) {
  const { className, width, height, samples, value, onChange } = props;
  const { palette } = useTheme();
  const buckets = reactExports.useMemo(() => bin().domain([0, 100])(samples), [samples]);
  const xScale = reactExports.useMemo(() => {
    return createLinearScale({
      domain: [0, 100],
      range: [0, width]
    });
  }, [width]);
  const yScale = reactExports.useMemo(() => {
    const domain = extent(buckets, ({ length }) => length);
    return createLinearScale({
      domain,
      range: [height, 0],
      nice: true
    });
  }, [height, buckets]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width, height, children: buckets.map(({ length, x0 = 0, x1 = 0 }, i) => {
      const x = xScale(x0);
      const y = yScale(length);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          x,
          y,
          width: xScale(x1) - x,
          height: height - y,
          fill: x0 < value ? palette.success.main : palette.grey[800]
        },
        i
      );
    }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Slider,
      {
        sx: {
          width: "calc(100% - .4rem)"
        },
        step: 100 / buckets.length,
        marks: true,
        min: 0,
        max: 100,
        valueLabelDisplay: "auto",
        value,
        onChange: (_, v) => typeof v === "number" && onChange(v)
      }
    ) })
  ] });
}
const HistogramSlider$1 = reactExports.memo(HistogramSlider);
function LearnConfigEntryContent(props) {
  const { className, contentId } = props;
  const navigate = useNavigate();
  const [learnConfig, setLearnConfig] = useAtom(learnConfigAtom);
  const {
    shuffle,
    qaDirection,
    qaType,
    hideHint,
    soundOnLearning,
    ttsForQuestion,
    ttsForAnswer,
    ttsLang,
    passRatio
  } = learnConfig;
  const { content, contentPrev, contentNext } = useGithubCardContextNext(contentId);
  const flashCardItems = reactExports.useMemo(() => {
    if (!content?.flashCardItems) return [];
    return content.flashCardItems;
  }, [content]);
  const total = flashCardItems.length;
  const itemSummaries = useFlashCardItemSummaries(content ?? null, false);
  const passRatioList = reactExports.useMemo(() => itemSummaries.map((s) => s.passRatio), [itemSummaries]);
  const filteredCount = reactExports.useMemo(
    () => itemSummaries.filter((s) => s.passRatio < passRatio).length,
    [itemSummaries, passRatio]
  );
  const histogramContainerRef = reactExports.useRef(null);
  const [containerWidth, setContainerWidth] = reactExports.useState(300);
  reactExports.useEffect(() => {
    const el = histogramContainerRef.current;
    if (!el) return;
    const observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        setContainerWidth(entry.contentRect.width);
      }
    });
    observer.observe(el);
    return () => observer.disconnect();
  }, []);
  const handleConfigChange = reactExports.useCallback(
    (config2) => {
      setLearnConfig((prev) => ({ ...prev, ...config2 }));
    },
    [setLearnConfig]
  );
  const handleStart = reactExports.useCallback(() => {
    if (qaType === "one-from-many") {
      navigate(routes.flashMan.learn.oneFromMany.$(contentId));
    } else {
      navigate(routes.flashMan.learn.shortAnswer.$(contentId));
    }
  }, [qaType, navigate, contentId]);
  useStackedTitle(content?.name);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className,
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        padding: 2
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { transform: "translate(-.5rem, -.2rem)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              onClick: () => {
                navigate(routes.flashMan.cards.$(contentId));
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flexGrow: 1, mb: 3 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: content?.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
              " ",
              filteredCount,
              "/",
              total,
              " "
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { ref: histogramContainerRef, sx: { mb: 2 }, children: containerWidth > 0 && passRatioList.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          HistogramSlider$1,
          {
            width: containerWidth,
            height: 80,
            samples: passRatioList,
            value: passRatio,
            onChange: (v) => handleConfigChange({ passRatio: v })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flexGrow: 1,
              display: "flex",
              flexDirection: "column",
              gap: 2,
              "& .MuiFormControl-root": {
                width: "100%"
              }
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FormControlLabel,
                {
                  control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      checked: shuffle,
                      onChange: () => handleConfigChange({ shuffle: !shuffle })
                    }
                  ),
                  label: " "
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { component: "fieldset", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { component: "legend", children: "  " }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  RadioGroup,
                  {
                    row: true,
                    name: "qa-direction",
                    value: qaDirection,
                    onChange: (e) => handleConfigChange({ qaDirection: e.target.value }),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel, { value: "forward", control: /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, {}), label: " -> " }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel, { value: "reverse", control: /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, {}), label: " -> " })
                    ]
                  }
                )
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { component: "fieldset", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { component: "legend", children: " " }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  RadioGroup,
                  {
                    row: true,
                    name: "qa-type",
                    value: qaType,
                    onChange: (e) => handleConfigChange({ qaType: e.target.value }),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel, { value: "one-from-many", control: /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, {}), label: "" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel, { value: "short-answer", control: /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, {}), label: "" })
                    ]
                  }
                )
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FormControlLabel,
                {
                  control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      checked: hideHint,
                      onChange: (e) => handleConfigChange({ hideHint: e.target.checked })
                    }
                  ),
                  label: " "
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FormControlLabel,
                {
                  control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      checked: soundOnLearning,
                      onChange: (e) => handleConfigChange({ soundOnLearning: e.target.checked })
                    }
                  ),
                  label: ""
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FormControlLabel,
                {
                  control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      checked: ttsForQuestion,
                      onChange: (e) => handleConfigChange({ ttsForQuestion: e.target.checked })
                    }
                  ),
                  label: " "
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FormControlLabel,
                {
                  control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      checked: ttsForAnswer,
                      onChange: (e) => handleConfigChange({ ttsForAnswer: e.target.checked })
                    }
                  ),
                  label: " "
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { size: { xs: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { fullWidth: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { id: "tts-lang-label", children: "TTS " }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Select,
                  {
                    labelId: "tts-lang-label",
                    value: ttsLang,
                    label: "TTS ",
                    onChange: (e) => handleConfigChange({ ttsLang: e.target.value }),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "ko-KR", children: "" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "en-US", children: "" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "ja-JP", children: "" })
                    ]
                  }
                )
              ] }) })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContentNavigationBar$1,
          {
            contentId,
            content,
            contentPrev,
            contentNext,
            centerButton: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "contained", size: "large", onClick: handleStart, disabled: total === 0, children: [
              " ",
              content && /* @__PURE__ */ jsxRuntimeExports.jsx(ContentStatus$1, { simple: true, content })
            ] })
          }
        )
      ]
    }
  );
}
function LearnConfigEntry() {
  const { queryParams } = useTypedSearchParams(routes.flashMan.learn.$config);
  const { owner, repo, path: path2 } = queryParams;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          sx: { display: "flex", alignItems: "center", justifyContent: "center", height: "50vh" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
        }
      ),
      children: owner && repo && path2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(LearnConfigEntryContent, { contentId: { owner, repo, path: path2 } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: "Invalid parameters" }) })
    }
  );
}
const LearnConfigEntry$1 = reactExports.memo(LearnConfigEntry);
function shuffleArray(array2) {
  const shuffled = [...array2];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}
function useForegroundDuration() {
  const startTimeRef = reactExports.useRef(Date.now());
  const hiddenDurationRef = reactExports.useRef(0);
  const hiddenAtRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const onVisibilityChange = () => {
      if (document.hidden) {
        hiddenAtRef.current = Date.now();
      } else if (hiddenAtRef.current !== null) {
        hiddenDurationRef.current += Date.now() - hiddenAtRef.current;
        hiddenAtRef.current = null;
      }
    };
    document.addEventListener("visibilitychange", onVisibilityChange);
    return () => document.removeEventListener("visibilitychange", onVisibilityChange);
  }, []);
  const getStartTime = reactExports.useCallback(() => startTimeRef.current, []);
  const getDuration = reactExports.useCallback(() => {
    const now = Date.now();
    const hiddenNow = hiddenAtRef.current !== null ? now - hiddenAtRef.current : 0;
    return now - startTimeRef.current - hiddenDurationRef.current - hiddenNow;
  }, []);
  const resetDuration = reactExports.useCallback(() => {
    startTimeRef.current = Date.now();
    hiddenDurationRef.current = 0;
    hiddenAtRef.current = null;
  }, []);
  return { getStartTime, getDuration, resetDuration };
}
function useAddHistory(contentInfo) {
  const queryClient = useQueryClient();
  const bufferRef = reactExports.useRef([]);
  const { getDuration, resetDuration } = useForegroundDuration();
  const lastResultTimeRef = reactExports.useRef(Date.now());
  const addResult = reactExports.useCallback(
    (result, lineNo) => {
      if (!contentInfo) return;
      const now = Date.now();
      const duration2 = now - lastResultTimeRef.current;
      lastResultTimeRef.current = now;
      bufferRef.current.push({
        owner: contentInfo.owner,
        repo: contentInfo.repo,
        path: contentInfo.path,
        sha: contentInfo.sha,
        line_no: lineNo,
        type: result,
        duration: duration2
      });
    },
    [contentInfo]
  );
  const completeSession = reactExports.useCallback(async () => {
    if (!contentInfo) return;
    const totalDuration = getDuration();
    bufferRef.current.push({
      owner: contentInfo.owner,
      repo: contentInfo.repo,
      path: contentInfo.path,
      sha: contentInfo.sha,
      line_no: -1,
      type: "fin",
      duration: totalDuration
    });
    const items = bufferRef.current;
    bufferRef.current = [];
    resetDuration();
    lastResultTimeRef.current = Date.now();
    try {
      await addLearningHistories(items);
      await queryClient.invalidateQueries({
        queryKey: ["learningHistorySummary", contentInfo.sha]
      });
    } catch (e) {
      console.error("Failed to save learning histories:", e);
    }
  }, [contentInfo, getDuration, resetDuration, queryClient]);
  return { addResult, completeSession };
}
function useFlashCardQuiz(params) {
  const { owner, repo, path: path2 } = params;
  const token = useGithubToken();
  const { shuffle, qaDirection, passRatio } = useAtomValue(learnConfigAtom);
  const { content } = useFlashCardContent(params);
  const contentInfo = reactExports.useMemo(() => {
    if (!content || !owner || !repo || !path2 || !content.sha) return null;
    return { owner, repo, path: path2, sha: content.sha };
  }, [content, owner, repo, path2]);
  const { addResult: addHistoryResult, completeSession } = useAddHistory(contentInfo);
  const [currentIndex, setCurrentIndex] = reactExports.useState(0);
  const [results, setResults] = reactExports.useState(/* @__PURE__ */ new Map());
  const [isComplete, setIsComplete] = reactExports.useState(false);
  const summary = useLearningHistorySummary(content?.sha);
  const contentFlashCardItems = content?.flashCardItems;
  const flashCardItems = reactExports.useMemo(() => {
    if (!contentFlashCardItems) return [];
    const lineHistories = /* @__PURE__ */ new Map();
    for (const h of summary.histories) {
      if (h.type === "fin") continue;
      const entry = lineHistories.get(h.line_no) ?? { pass: 0, total: 0 };
      entry.total++;
      if (h.type === "pass") entry.pass++;
      lineHistories.set(h.line_no, entry);
    }
    const filtered = contentFlashCardItems.filter((item) => {
      const entry = lineHistories.get(item.lineNo);
      const ratio = entry && entry.total > 0 ? entry.pass / entry.total * 100 : 0;
      return ratio < passRatio;
    });
    const items = qaDirection === "reverse" ? filtered.map((item) => ({ ...item, q: item.a, a: item.q })) : filtered;
    return shuffle ? shuffleArray(items) : items;
  }, [contentFlashCardItems, qaDirection, shuffle, passRatio, summary.histories]);
  const currentItem = flashCardItems[currentIndex];
  const total = flashCardItems.length;
  const passCount = Array.from(results.values()).filter((r) => r === "pass").length;
  const failCount = Array.from(results.values()).filter((r) => r === "fail").length;
  const progress = total > 0 ? (passCount + failCount) / total * 100 : 0;
  const recordResult = reactExports.useCallback(
    (result) => {
      setResults((prev) => new Map(prev).set(currentIndex, result));
      if (currentItem) {
        addHistoryResult(result, currentItem.lineNo);
      }
    },
    [currentIndex, currentItem, addHistoryResult]
  );
  const advance = reactExports.useCallback(() => {
    if (currentIndex < total - 1) {
      setCurrentIndex((prev) => prev + 1);
    } else {
      setIsComplete(true);
      completeSession();
    }
  }, [currentIndex, total, completeSession]);
  const restart = reactExports.useCallback(() => {
    setCurrentIndex(0);
    setResults(/* @__PURE__ */ new Map());
    setIsComplete(false);
  }, []);
  useStackedTitle(content?.name);
  return {
    content,
    token,
    flashCardItems,
    currentIndex,
    currentItem,
    total,
    passCount,
    failCount,
    progress,
    isComplete,
    recordResult,
    advance,
    restart
  };
}
let voices = [];
function setVoiceList() {
  try {
    voices = window.speechSynthesis.getVoices();
  } catch {
  }
}
setVoiceList();
if (window.speechSynthesis.onvoiceschanged !== void 0) {
  window.speechSynthesis.onvoiceschanged = setVoiceList;
}
function useTts(lang = "ko-KR") {
  const utterRef = reactExports.useRef(new SpeechSynthesisUtterance());
  reactExports.useEffect(() => {
    const utter = utterRef.current;
    for (let i = 0; i < voices.length; i++) {
      if (voices[i].lang.indexOf(lang) >= 0 || voices[i].lang.indexOf(lang.replace("-", "_")) >= 0) {
        utter.voice = voices[i];
        utter.lang = lang;
        utter.pitch = 1;
        utter.rate = 1;
      }
    }
  }, [lang]);
  reactExports.useEffect(() => {
    return () => {
      window.speechSynthesis.cancel();
    };
  }, []);
  const play = reactExports.useCallback((text2) => {
    return new Promise((resolve) => {
      window.speechSynthesis.cancel();
      const utter = utterRef.current;
      utter.text = text2;
      utter.onend = () => resolve();
      utter.onerror = () => resolve();
      window.speechSynthesis.speak(utter);
    });
  }, []);
  return play;
}
function QuizEmptyState() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { padding: 4, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "  ." }) });
}
class SilentErrorBoundary extends reactExports.Component {
  state = { hasError: false };
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  render() {
    if (this.state.hasError) return null;
    return this.props.children;
  }
}
function getAccuracyColor(percent) {
  if (percent >= 80) return "success";
  if (percent >= 50) return "warning";
  return "error";
}
function QuizCompleteState({
  className,
  passCount,
  failCount,
  total,
  contentId,
  onRestart
}) {
  const navigate = useNavigate();
  const accuracy = total > 0 ? Math.round(passCount / total * 100) : 0;
  const progressColor = getAccuracyColor(accuracy);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className,
      sx: {
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: 2
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1, alignSelf: "flex-end" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              size: "small",
              onClick: () => {
                navigate(routes.flashMan.cards.$(contentId));
              },
              children: ""
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              size: "small",
              onClick: () => {
                navigate(routes.flashMan.learn.$(contentId));
              },
              children: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flexGrow: 1,
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              gap: 2
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressWithLabel$1, { value: accuracy, size: 120, color: progressColor }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: " !" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { component: "span", color: "success.main", fontWeight: "bold", children: [
                  " ",
                  passCount
                ] }),
                " / ",
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { component: "span", color: "error.main", fontWeight: "bold", children: [
                  " ",
                  failCount
                ] })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SilentErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ConnectedContentNavigationBar,
          {
            contentId,
            centerButton: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", size: "large", onClick: onRestart, children: "" })
          }
        ) }) })
      ]
    }
  );
}
function QuizProgressBar({
  currentIndex,
  total,
  passCount,
  failCount,
  progress,
  ...boxProps
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...mergeSlotProps(boxProps, {}), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", mb: 1 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
        currentIndex + 1,
        " / ",
        total
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { component: "span", color: "success.main", children: passCount }),
        " / ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { component: "span", color: "error.main", children: failCount })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgress, { variant: "determinate", value: progress, sx: { height: 8, borderRadius: 4 } })
  ] });
}
function QuizSuspenseWrapperInner({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          sx: { display: "flex", alignItems: "center", justifyContent: "center", height: "50vh" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
        }
      ),
      children
    }
  );
}
const QuizSuspenseWrapper = reactExports.memo(QuizSuspenseWrapperInner);
function makeAnswers(flashCardItems, questionIndex) {
  const item = flashCardItems[questionIndex];
  const refinedAnswers = flashCardItems.map(({ a }) => a.trim().toUpperCase());
  const uniqueAnswers = Array.from(new Set(refinedAnswers));
  if (uniqueAnswers.length <= 4) {
    return uniqueAnswers.map((a) => ({
      a: flashCardItems.find((i) => i.a.trim().toUpperCase() === a)?.a || a,
      correctAnswer: item.a.trim().toUpperCase() === a
    }));
  }
  const wrongAnswers = shuffleArray(flashCardItems.filter((i) => i.a !== item.a)).slice(0, 3).map(({ a }) => ({ a }));
  return shuffleArray([...wrongAnswers, { a: item.a, correctAnswer: true }]);
}
function OneFromManyViewContent(props) {
  const { className } = props;
  const { queryParams } = useTypedSearchParams(routes.flashMan.learn.oneFromMany.$config);
  const { owner, repo, path: path2 } = queryParams;
  const {
    content,
    token,
    flashCardItems,
    currentIndex,
    currentItem,
    total,
    passCount,
    failCount,
    progress,
    isComplete,
    recordResult,
    advance,
    restart
  } = useFlashCardQuiz({ owner, repo, path: path2 });
  const { isMobile } = useIsMobile();
  const navigate = useNavigate();
  const { ttsForQuestion, ttsForAnswer, ttsLang } = useAtomValue(learnConfigAtom);
  const playTts = useTts(ttsLang);
  const [stage, setStage] = reactExports.useState("Guessing");
  const [selected, setSelected] = reactExports.useState();
  const answers = reactExports.useMemo(() => {
    if (!currentItem || flashCardItems.length === 0) return [];
    return makeAnswers(flashCardItems, currentIndex);
  }, [flashCardItems, currentIndex, currentItem]);
  reactExports.useEffect(() => {
    if (!currentItem) return;
    const play = async () => {
      if (ttsForQuestion) {
        await playTts(currentItem.q);
      }
      if (ttsForAnswer) {
        for (const { a } of answers) {
          await playTts(a);
        }
      }
    };
    play();
  }, [currentIndex, currentItem, ttsForQuestion, ttsForAnswer, answers, playTts]);
  const replay = reactExports.useCallback(async () => {
    if (!currentItem) return;
    await playTts(currentItem.q);
    if (ttsForAnswer) {
      for (const { a } of answers) {
        await playTts(a);
      }
    }
  }, [currentItem, answers, ttsForAnswer, playTts]);
  const handleResult = reactExports.useCallback(
    (result) => {
      recordResult(result);
      setStage("Guessing");
      setSelected(void 0);
      advance();
    },
    [recordResult, advance]
  );
  const handleRestart = reactExports.useCallback(() => {
    restart();
    setStage("Guessing");
    setSelected(void 0);
  }, [restart]);
  reactExports.useEffect(() => {
    if (selected !== void 0 && answers[selected]) {
      const isCorrect = answers[selected].correctAnswer;
      const timeout = setTimeout(
        () => {
          handleResult(isCorrect ? "pass" : "fail");
        },
        isCorrect ? 1e3 : 3e3
      );
      return () => clearTimeout(timeout);
    }
  }, [selected, answers, handleResult]);
  reactExports.useEffect(() => {
    const handleKeyDown = (e) => {
      if (stage === "Guessing") {
        if (e.key === "s" || e.key === "S") {
          setStage("Studying");
        } else if (e.key === "a" || e.key === "A" || e.key === " " || e.key === "Enter") {
          setStage("Answering");
        }
      } else if (stage === "Studying") {
        if (e.key === " " || e.key === "Enter") {
          handleResult("fail");
        }
      } else if (stage === "Answering" && selected === void 0) {
        const num = parseInt(e.key);
        if (num >= 1 && num <= answers.length) {
          setSelected(num - 1);
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [stage, selected, answers.length, handleResult]);
  if (!content || flashCardItems.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(QuizEmptyState, {});
  }
  if (isComplete) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuizCompleteState,
      {
        className,
        passCount,
        failCount,
        total,
        contentId: { owner: owner || "", repo: repo || "", path: path2 },
        onRestart: handleRestart
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RenderContextProvider$1, { content, githubToken: token, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className: "OneFromManyView " + (className || ""),
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        padding: 2,
        minHeight: "100vh"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", mb: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              sx: { transform: "translate(-.5rem, -.2rem)" },
              onClick: () => {
                navigate(routes.flashMan.learn.$(queryParams));
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            QuizProgressBar,
            {
              sx: { flexGrow: 1 },
              currentIndex,
              total,
              passCount,
              failCount,
              progress
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { display: "flex", flexDirection: "column" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          CardContent,
          {
            sx: {
              flexGrow: 1,
              display: "flex",
              flexDirection: "column",
              padding: "1rem !important"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1, display: "flex", py: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Question$1, { text: currentItem?.q || "" }) }),
              stage === "Studying" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    borderTop: 1,
                    borderColor: "divider",
                    py: 2,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Answer$1, { text: currentItem?.a || "", sx: { color: "primary.main" } })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1, minHeight: "1rem" } }),
        stage === "Guessing" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
          (ttsForQuestion || ttsForAnswer) && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: replay, size: "large", children: /* @__PURE__ */ jsxRuntimeExports.jsx(HearingIcon, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              fullWidth: true,
              size: "large",
              onClick: () => setStage("Studying"),
              sx: { fontSize: "1.1rem" },
              children: " (S)"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "contained",
              fullWidth: true,
              size: "large",
              onClick: () => setStage("Answering"),
              sx: { fontSize: "1.1rem" },
              children: " (A)"
            }
          )
        ] }),
        stage === "Studying" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              onClick: () => {
                window.open(
                  `https://translate.google.co.kr/?hl=ko&sl=auto&text=${encodeURIComponent(currentItem?.q || "")}&op=translate`,
                  "_blank"
                );
              },
              sx: { fontSize: "1rem" },
              children: ""
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              onClick: () => {
                window.open(
                  `https://www.google.com/search?q=${encodeURIComponent(currentItem?.q || "")}`,
                  "_blank"
                );
              },
              sx: { fontSize: "1rem" },
              children: ""
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "contained",
              fullWidth: true,
              onClick: () => handleResult("fail"),
              sx: { fontSize: "1.1rem" },
              children: isMobile ? "" : " (Space)"
            }
          )
        ] }),
        stage === "Answering" && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", flexDirection: "column", gap: 1 }, children: answers.map((answer, i) => {
          let color2 = "primary";
          if (selected !== void 0) {
            if (answer.correctAnswer) {
              color2 = "success";
            } else if (selected === i) {
              color2 = "error";
            }
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              size: "large",
              color: color2,
              onClick: () => {
                if (selected === void 0) {
                  setSelected(i);
                }
              },
              sx: {
                justifyContent: "flex-start",
                textAlign: "left",
                fontSize: "1rem",
                py: 1.5
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Answer$1, { text: answer.a })
            },
            i
          );
        }) }),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", color: "text.secondary", sx: { mt: 2, textAlign: "center" }, children: [
          stage === "Guessing" && "S:  | A/Space/Enter: ",
          stage === "Studying" && "Space/Enter: ",
          stage === "Answering" && "1-4:  "
        ] })
      ]
    }
  ) });
}
function OneFromManyView(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QuizSuspenseWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OneFromManyViewContent, { ...props }) });
}
const OneFromManyView$1 = reactExports.memo(OneFromManyView);
function cleanUpString(s) {
  return s.toLowerCase().replace(/<br\/?>/g, "").replace(/[-!"'""'<>:\\.\\,?\s]/g, "");
}
function compareAnswer(source, target) {
  return cleanUpString(source) === cleanUpString(target);
}
const TextDiff = styled("div")(({ theme: { palette } }) => ({
  fontSize: "1.2rem",
  lineHeight: "1.8rem",
  wordBreak: "break-word",
  "& span": {
    color: palette.success.main
  },
  "& del": {
    opacity: 0,
    textDecoration: "none"
  },
  "& ins": {
    color: palette.warning.main
  },
  "&.showAnswer": {
    "& span": {
      color: palette.success.main
    },
    "& del": {
      color: palette.error.main,
      opacity: 1
    },
    "& ins": {
      color: palette.warning.main
    }
  }
}));
function ShortAnswerViewContent(props) {
  const { className } = props;
  const {
    queryParams: { owner = "", repo = "", path: path2 = "" }
  } = useTypedSearchParams(routes.flashMan.learn.shortAnswer.$config);
  const {
    content,
    token,
    flashCardItems,
    currentIndex,
    currentItem,
    total,
    passCount,
    failCount,
    progress,
    isComplete,
    recordResult,
    advance,
    restart
  } = useFlashCardQuiz({ owner, repo, path: path2 });
  const { ttsForQuestion, ttsLang } = useAtomValue(learnConfigAtom);
  const playTts = useTts(ttsLang);
  const [answer, setAnswer] = reactExports.useState("");
  const [correct, setCorrect] = reactExports.useState(void 0);
  const [showAnswer, setShowAnswer] = reactExports.useState(false);
  const [checking, setChecking] = reactExports.useState(false);
  const refShowAnswer = reactExports.useRef(false);
  const refTextArea = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (showAnswer) {
      refShowAnswer.current = true;
    }
  }, [showAnswer]);
  const handleResult = reactExports.useCallback(
    (result) => {
      recordResult(result);
      setCorrect(result === "pass");
      setTimeout(() => {
        setShowAnswer(false);
        setCorrect(void 0);
        setAnswer("");
        setChecking(false);
        refShowAnswer.current = false;
        advance();
        refTextArea.current?.focus();
      }, 1e3);
    },
    [recordResult, advance]
  );
  const handleAnswer = reactExports.useCallback(
    (e) => {
      const value = e.target.value;
      setAnswer(value);
      setShowAnswer(false);
      if (currentItem && compareAnswer(currentItem.a, value)) {
        handleResult(refShowAnswer.current ? "fail" : "pass");
      }
    },
    [currentItem, handleResult]
  );
  const handleKeyDown = reactExports.useCallback((e) => {
    if (e.key === "Enter") {
      setChecking((prev) => !prev);
      e.preventDefault();
      e.stopPropagation();
    }
    if (e.key === "?") {
      setShowAnswer((prev) => !prev);
      e.preventDefault();
      e.stopPropagation();
    }
  }, []);
  const [diff, setDiff] = reactExports.useState(null);
  reactExports.useEffect(() => {
    __vitePreload(() => import("./diff-Ba4fQ92W.js").then((n) => n.d), true ? __vite__mapDeps([0,1,2]) : void 0).then((module) => {
      console.log(module);
      setDiff(new (module.default || module)());
    });
  }, []);
  const { diffHtml, ratio } = reactExports.useMemo(() => {
    if (!currentItem || !diff) return { diffHtml: "", ratio: 0 };
    const target = currentItem.a.replaceAll("<br/>", "\n").toLowerCase();
    const textDiff = diff.main(target, answer.toLowerCase());
    const ratio2 = 100 * textDiff.filter(([match2]) => match2 === 0).reduce((ret, [, s]) => ret + s.length, 0) / target.length;
    const diffHtml2 = diff.prettyHtml(textDiff);
    return { ratio: ratio2, diffHtml: diffHtml2 };
  }, [currentItem, diff, answer]);
  reactExports.useEffect(() => {
    if (ttsForQuestion && currentItem) {
      playTts(currentItem.q);
    }
    refTextArea.current?.focus();
  }, [currentIndex, currentItem, ttsForQuestion, playTts]);
  const handleRestart = reactExports.useCallback(() => {
    restart();
    setAnswer("");
    setCorrect(void 0);
    setShowAnswer(false);
    setChecking(false);
    refShowAnswer.current = false;
  }, [restart]);
  if (!content || flashCardItems.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(QuizEmptyState, {});
  }
  if (isComplete) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      QuizCompleteState,
      {
        className,
        passCount,
        failCount,
        total,
        contentId: { owner, repo, path: path2 },
        onRestart: handleRestart
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RenderContextProvider$1, { content, githubToken: token, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className,
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        padding: 2
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          QuizProgressBar,
          {
            currentIndex,
            total,
            passCount,
            failCount,
            progress
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1, display: "flex", flexDirection: "column" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flexGrow: 1,
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              p: 2
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Question$1, { text: currentItem?.q || "", sx: { textAlign: "center", mb: 2 } }),
              correct === void 0 && (showAnswer || checking) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextDiff,
                {
                  className: showAnswer ? "showAnswer" : void 0,
                  dangerouslySetInnerHTML: { __html: diffHtml }
                }
              ),
              correct !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(TextDiff, { className: "showAnswer", dangerouslySetInnerHTML: { __html: diffHtml } }),
              correct === true && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: "." }) }),
              correct === false && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", children: "  ." }) })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              position: "sticky",
              bottom: 0,
              display: "flex",
              flexDirection: "column",
              gap: 1
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => handleResult("fail"), children: "" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1, display: "flex", alignItems: "center", px: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgress, { sx: { width: "100%" }, variant: "determinate", value: ratio }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: ratio < 80, onClick: () => handleResult("pass"), children: "" }),
                ttsForQuestion && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    onClick: () => {
                      if (currentItem) playTts(currentItem.q);
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(HearingIcon, {})
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    color: "secondary",
                    disabled: showAnswer,
                    onClick: () => {
                      setShowAnswer(true);
                      refTextArea.current?.focus();
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisibilityIcon, {})
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextareaAutosize,
                {
                  ref: refTextArea,
                  "aria-label": "answer input",
                  minRows: 3,
                  maxRows: 7,
                  placeholder: "  ",
                  style: {
                    fontSize: "1rem",
                    padding: ".5rem"
                  },
                  value: answer,
                  onChange: handleAnswer,
                  onKeyDown: handleKeyDown
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", sx: { textAlign: "center" }, children: "Enter:  | ?:  " })
            ]
          }
        )
      ]
    }
  ) });
}
function ShortAnswerView(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QuizSuspenseWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShortAnswerViewContent, { ...props }) });
}
const ShortAnswerView$1 = reactExports.memo(ShortAnswerView);
export {
  ContentView$1 as C,
  FlashCardView$1 as F,
  LearnConfigEntry$1 as L,
  OneFromManyView$1 as O,
  ShortAnswerView$1 as S
};
//# sourceMappingURL=ShortAnswerView-BpzofGa7.js.map
